<?xml version="1.0"?>
<doc>
    <assembly>
        <name>BestCS.Robotics</name>
    </assembly>
    <members>
        <member name="T:BestCS.Audition.Beat.EnergyBeatDetector">
            <summary>
              Energy-based beat detector.
            </summary>
            
            <remarks>
            <para>
              References:
              <list type="bullet">
                <item><description>
                  Frederic Patin, Beat Detection Algorithms. Available on:
                  http://www.gamedev.net/reference/programming/features/beatdetection. </description></item>
              </list>
            </para>
            </remarks>
            
        </member>
        <member name="T:BestCS.Audition.Beat.IBeatDetector">
            <summary>
              Common interface for Beat detectors.
            </summary>
        </member>
        <member name="E:BestCS.Audition.Beat.IBeatDetector.Beat">
            <summary>
              Raised when a beat has been detected.
            </summary>
        </member>
        <member name="M:BestCS.Audition.Beat.EnergyBeatDetector.#ctor(System.Int32)">
            <summary>
              Creates a new Energy-based beat detector.
            </summary>
            
            <param name="bufferSize">The size for the buffer.</param>
            
        </member>
        <member name="M:BestCS.Audition.Beat.EnergyBeatDetector.Detect(BestCS.Audio.Signal)">
            <summary>
              Detects if there is a beat in the given signal.
            </summary>
            
            <param name="signal">A signal (window).</param>
            
        </member>
        <member name="E:BestCS.Audition.Beat.EnergyBeatDetector.Beat">
            <summary>
              Raised when a beat has been detected.
            </summary>
            
        </member>
        <member name="P:BestCS.Audition.Beat.EnergyBeatDetector.AutoSensitivity">
            <summary>
              Gets or sets whether the detector should
              compute the best sensitivity automatically.
            </summary>
            
        </member>
        <member name="P:BestCS.Audition.Beat.EnergyBeatDetector.Sensitivity">
            <summary>
              Gets or sets the sensitivity of the detector.
            </summary>
            
        </member>
        <member name="T:BestCS.Fuzzy.Clause">
             <summary>
             This class represents a fuzzy clause, a linguistic expression of the type "Variable IS Value".
             </summary>
             
             <remarks><para>A Fuzzy Clause is used to verify if a linguistic variable can be considered
             as a specific value at a specific moment. Linguistic variables can only assume value of
             their linugistic labels. Because of the nature of the Fuzzy Logic, a Variable can be 
             several of its labels at the same time, with different membership values.</para>
             
             <para>For example, a linguistic variable "temperature" can be "hot" with a membership 0.3
             and "warm" with a membership 0.7 at the same time. To obtain those memberships, Fuzzy Clauses
             "temperature is hot" and "temperature is war" can be built.</para>
             
             <para>Typically Fuzzy Clauses are used to build Fuzzy Rules (<see cref="T:BestCS.Fuzzy.Rule"/>).</para>
             
             <para>Sample usage:</para>
             <code>
             // create a linguistic variable to represent temperature
             LinguisticVariable lvTemperature = new LinguisticVariable( "Temperature", 0, 80 );
            
             // create the linguistic labels (fuzzy sets) that compose the temperature 
             TrapezoidalFunction function1 = new TrapezoidalFunction( 10, 15, TrapezoidalFunction.EdgeType.Right );
             FuzzySet fsCold = new FuzzySet( "Cold", function1 );
             TrapezoidalFunction function2 = new TrapezoidalFunction( 10, 15, 20, 25 );
             FuzzySet fsCool = new FuzzySet( "Cool", function2 );
             TrapezoidalFunction function3 = new TrapezoidalFunction( 20, 25, 30, 35 );
             FuzzySet fsWarm = new FuzzySet( "Warm", function3 );
             TrapezoidalFunction function4 = new TrapezoidalFunction( 30, 35, TrapezoidalFunction.EdgeType.Left );
             FuzzySet fsHot  = new FuzzySet( "Hot" , function4 );
            
             // adding labels to the variable
             lvTemperature.AddLabel( fsCold );
             lvTemperature.AddLabel( fsCool );
             lvTemperature.AddLabel( fsWarm );
             lvTemperature.AddLabel( fsHot  );
             
             // creating the Clause
             Clause fuzzyClause = new Clause( lvTemperature, fsHot );
             // setting the numerical input of the variable to evaluate the Clause
             lvTemperature.NumericInput = 35;
             float result = fuzzyClause.Evaluate( );
             Console.WriteLine ( result.ToString( ) );
             </code>    
             </remarks>
             
        </member>
        <member name="M:BestCS.Fuzzy.Clause.#ctor(BestCS.Fuzzy.LinguisticVariable,BestCS.Fuzzy.FuzzySet)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Fuzzy.Clause"/> class.
            </summary>
            
            <param name="variable">Linguistic variable of the clause. </param>
            
            <param name="label">Label of the linguistic variable, a fuzzy set used as label into the linguistic variable.</param>
            
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The label indicated was not found in the linguistic variable.</exception>
            
        </member>
        <member name="M:BestCS.Fuzzy.Clause.Evaluate">
            <summary>
            Evaluates the fuzzy clause.
            </summary>
            
            <returns>Degree of membership [0..1] of the clause.</returns>
            
        </member>
        <member name="M:BestCS.Fuzzy.Clause.ToString">
            <summary>
            Returns the fuzzy clause in its linguistic representation.
            </summary>
            
            <returns>A string representing the fuzzy clause.</returns>
            
        </member>
        <member name="P:BestCS.Fuzzy.Clause.Variable">
            <summary>
            Gets the <see cref="T:BestCS.Fuzzy.LinguisticVariable"/> of the <see cref="T:BestCS.Fuzzy.Clause"/>.
            </summary>
        </member>
        <member name="P:BestCS.Fuzzy.Clause.Label">
            <summary>
            Gets the <see cref="T:BestCS.Fuzzy.FuzzySet"/> of the <see cref="T:BestCS.Fuzzy.Clause"/>.
            </summary>
        </member>
        <member name="T:BestCS.Fuzzy.Database">
            <summary>
            The class represents a fuzzy database, a set of linguistic variables used in a Fuzzy
            Inference System.
            </summary>
            
        </member>
        <member name="M:BestCS.Fuzzy.Database.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Fuzzy.Database"/> class.
            </summary>
            
        </member>
        <member name="M:BestCS.Fuzzy.Database.AddVariable(BestCS.Fuzzy.LinguisticVariable)">
            <summary>
            Adds a linguistic variable to the database. 
            </summary>
            
            <param name="variable">A linguistic variable to add.</param>
            
            <exception cref="T:System.NullReferenceException">The linguistic variable was not initialized.</exception>
            <exception cref="T:System.ArgumentException">The linguistic variable name already exists in the database.</exception>
            
        </member>
        <member name="M:BestCS.Fuzzy.Database.ClearVariables">
            <summary>
            Removes all the linguistic variables of the database. 
            </summary>
            
        </member>
        <member name="M:BestCS.Fuzzy.Database.GetVariable(System.String)">
            <summary>
            Returns an existing linguistic variable from the database.
            </summary>
            
            <param name="variableName">Name of the linguistic variable to retrieve.</param>
            
            <returns>Reference to named <see cref="T:BestCS.Fuzzy.LinguisticVariable"/>.</returns>
            
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The variable indicated was not found in the database.</exception>
            
        </member>
        <member name="T:BestCS.Fuzzy.CentroidDefuzzifier">
            <summary>
            This class implements the centroid defuzzification method.
            </summary>
            
            <remarks><para>In many applications, a Fuzzy Inference System is used to perform linguistic
            computation, but at the end of the inference process, a numerical value is needed. It does
            not mean that the system needs precision, but simply that a numerical value is required,
            most of the times because it will be used to control another system that needs the number.
            To obtain this numer, a defuzzification method is performed.</para>
            
            <para>This class implements the centroid defuzzification method. The output of a Fuzzy
            Inference System is a set of rules (see <see cref="T:BestCS.Fuzzy.Rule"/>) with firing strength greater
            than zero. Those firing strength apply a constraint to the consequent fuzzy sets
            (see <see cref="T:BestCS.Fuzzy.FuzzySet"/>) of the rules. Putting all those fuzzy sets togheter results
            in a a shape that is the linguistic output meaning. 
            </para>
            
            <para>The centroid method calculates the center of the area of this shape to obtain the
            numerical representation of the output. It uses a numerical approximation, so a number
            of intervals must be choosen. As the number of intervals grow, the precision of the
            numerical ouput grows. 
            </para>
            
            <para>For a sample usage of the <see cref="T:BestCS.Fuzzy.CentroidDefuzzifier"/> see <see cref="T:BestCS.Fuzzy.InferenceSystem"/>
            class.</para>
            </remarks>
            
        </member>
        <member name="T:BestCS.Fuzzy.IDefuzzifier">
            <summary>
            Interface which specifies set of methods required to be implemented by all defuzzification methods 
            that can be used in Fuzzy Inference Systems. 
            </summary>
            
            <remarks><para>In many applications, a Fuzzy Inference System is used to perform linguistic computation, 
            but at the end of the inference process, a numerical value is needed. It does not mean that the system 
            needs precision, but simply that a numerical value is required, most of the times because it will be used to 
            control another system that needs the number. To obtain this numer, a defuzzification method is performed.</para>
            
            <para>Several deffuzification methods were proposed, and they can be created as classes that 
            implements this interface.</para></remarks>
            
        </member>
        <member name="M:BestCS.Fuzzy.IDefuzzifier.Defuzzify(BestCS.Fuzzy.FuzzyOutput,BestCS.Fuzzy.INorm)">
            <summary>
            Defuzzification method to obtain the numerical representation of a fuzzy output.
            </summary>
            
            <param name="fuzzyOutput">A <see cref="T:BestCS.Fuzzy.FuzzyOutput"/> containing the output of
            several rules of a Fuzzy Inference System.</param>
            <param name="normOperator">A <see cref="T:BestCS.Fuzzy.INorm"/> operator to be used when constraining
            the label to the firing strength.</param>
            
            <returns>The numerical representation of the fuzzy output.</returns>
            
        </member>
        <member name="M:BestCS.Fuzzy.CentroidDefuzzifier.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Fuzzy.CentroidDefuzzifier"/> class.
            </summary>
            
            <param name="intervals">Number of segments that the speech universe will be splited
            to perform the numerical approximation of the center of area.</param>
            
        </member>
        <member name="M:BestCS.Fuzzy.CentroidDefuzzifier.Defuzzify(BestCS.Fuzzy.FuzzyOutput,BestCS.Fuzzy.INorm)">
            <summary>
            Centroid method to obtain the numerical representation of a fuzzy output. The numerical
            value will be the center of the shape formed by the several fuzzy labels with their
            constraints.
            </summary>
            
            <param name="fuzzyOutput">A <see cref="T:BestCS.Fuzzy.FuzzyOutput"/> containing the output of several
            rules of a Fuzzy Inference System.</param>
            <param name="normOperator">A <see cref="T:BestCS.Fuzzy.INorm"/> operator to be used when constraining
            the label to the firing strength.</param>
            
            <returns>The numerical representation of the fuzzy output.</returns>
            
            <exception cref="T:System.Exception">The numerical output is unavaliable. All memberships are zero.</exception>
            
        </member>
        <member name="T:BestCS.Fuzzy.FuzzyOutput">
            <summary>
            The class represents the output of a Fuzzy Inference System. 
            </summary>
            
            <remarks><para>The class keeps set of rule's output - pairs with the output fuzzy label
            and the rule's firing strength.
            </para>
            
            
            <para>Sample usage:</para>
            <code>
            // linguistic labels (fuzzy sets) that compose the distances
            FuzzySet fsNear = new FuzzySet( "Near",
                new TrapezoidalFunction( 15, 50, TrapezoidalFunction.EdgeType.Right ) );
            FuzzySet fsMedium = new FuzzySet( "Medium",
                new TrapezoidalFunction( 15, 50, 60, 100 ) );
            FuzzySet fsFar = new FuzzySet( "Far",
                new TrapezoidalFunction( 60, 100, TrapezoidalFunction.EdgeType.Left ) );
                        
            // front distance (input)
            LinguisticVariable lvFront = new LinguisticVariable( "FrontalDistance", 0, 120 );
            lvFront.AddLabel( fsNear );
            lvFront.AddLabel( fsMedium );
            lvFront.AddLabel( fsFar );
            
            // linguistic labels (fuzzy sets) that compose the angle
            FuzzySet fsZero = new FuzzySet( "Zero",
                new TrapezoidalFunction( -10, 5, 5, 10 ) );
            FuzzySet fsLP = new FuzzySet( "LittlePositive",
                new TrapezoidalFunction( 5, 10, 20, 25 ) );
            FuzzySet fsP = new FuzzySet( "Positive",
                new TrapezoidalFunction( 20, 25, 35, 40 ) );
            FuzzySet fsVP = new FuzzySet( "VeryPositive",
                new TrapezoidalFunction( 35, 40, TrapezoidalFunction.EdgeType.Left ) );
            
            // angle
            LinguisticVariable lvAngle = new LinguisticVariable( "Angle", -10, 50 );
            lvAngle.AddLabel( fsZero );
            lvAngle.AddLabel( fsLP );
            lvAngle.AddLabel( fsP );
            lvAngle.AddLabel( fsVP );
            
            // the database
            Database fuzzyDB = new Database( );
            fuzzyDB.AddVariable( lvFront );
            fuzzyDB.AddVariable( lvAngle );
            
            // creating the inference system
            InferenceSystem IS = new InferenceSystem( fuzzyDB, new CentroidDefuzzifier( 1000 ) );
            
            // going straight
            IS.NewRule( "Rule 1", "IF FrontalDistance IS Far THEN Angle IS Zero" );
            // turning left
            IS.NewRule( "Rule 2", "IF FrontalDistance IS Near THEN Angle IS Positive" );
            
            ...
            // inference section
            
            // setting inputs
            IS.SetInput( "FrontalDistance", 20 );
            
            // getting outputs
            try
            {
                FuzzyOutput fuzzyOutput = IS.ExecuteInference ( "Angle" );
            
                // showing the fuzzy output
                foreach ( FuzzyOutput.OutputConstraint oc in fuzzyOutput.OutputList )
                {
                    Console.WriteLine( oc.Label + " - " + oc.FiringStrength.ToString( ) );
                }
            }
            catch ( Exception )
            {
               ...
            }
            </code>  
            </remarks>
            
        </member>
        <member name="M:BestCS.Fuzzy.FuzzyOutput.#ctor(BestCS.Fuzzy.LinguisticVariable)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Fuzzy.FuzzyOutput"/> class.
            </summary>
            
            <param name="outputVar">A <see cref="T:BestCS.Fuzzy.LinguisticVariable"/> representing a Fuzzy Inference System's output.</param>
            
        </member>
        <member name="M:BestCS.Fuzzy.FuzzyOutput.AddOutput(System.String,System.Single)">
            <summary>
            Adds an output to the Fuzzy Output. 
            </summary>
            
            <param name="labelName">The name of a label representing a fuzzy rule's output.</param>
            <param name="firingStrength">The firing strength [0..1] of a fuzzy rule.</param>
            
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The label indicated was not found in the linguistic variable.</exception>
            
        </member>
        <member name="M:BestCS.Fuzzy.FuzzyOutput.ClearOutput">
            <summary>
            Removes all the linguistic variables of the database. 
            </summary>
            
        </member>
        <member name="P:BestCS.Fuzzy.FuzzyOutput.OutputList">
            <summary>
            A list with <see cref="T:BestCS.Fuzzy.FuzzyOutput.OutputConstraint"/> of a Fuzzy Inference System's output.
            </summary>
            
        </member>
        <member name="P:BestCS.Fuzzy.FuzzyOutput.OutputVariable">
            <summary>
            Gets the <see cref="T:BestCS.Fuzzy.LinguisticVariable"/> acting as a Fuzzy Inference System Output.
            </summary>
            
        </member>
        <member name="T:BestCS.Fuzzy.FuzzyOutput.OutputConstraint">
            <summary>
            Inner class to store the pair fuzzy label / firing strength of 
            a fuzzy output.
            </summary>
        </member>
        <member name="M:BestCS.Fuzzy.FuzzyOutput.OutputConstraint.#ctor(System.String,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Fuzzy.FuzzyOutput.OutputConstraint"/> class.
            </summary>
            
            <param name="label">A string representing the output label of a <see cref="T:BestCS.Fuzzy.Rule"/>.</param>
            <param name="firingStrength">The firing strength of a <see cref="T:BestCS.Fuzzy.Rule"/>, to be applied to its output label.</param>
            
        </member>
        <member name="P:BestCS.Fuzzy.FuzzyOutput.OutputConstraint.Label">
            <summary>
            The <see cref="T:BestCS.Fuzzy.FuzzySet"/> representing the output label of a <see cref="T:BestCS.Fuzzy.Rule"/>.
            </summary>
            
        </member>
        <member name="P:BestCS.Fuzzy.FuzzyOutput.OutputConstraint.FiringStrength">
            <summary>
            The firing strength of a <see cref="T:BestCS.Fuzzy.Rule"/>, to be applied to its output label.
            </summary>
            
        </member>
        <member name="T:BestCS.Fuzzy.FuzzySet">
            <summary>
            The class represents a fuzzy set.
            </summary>
            
            <remarks><para>The fuzzy sets are the base for all fuzzy applications. In a classical set, the membership of 
            a given value to the set can always be defined as true (1) or false (0). In fuzzy sets, this membership can be 
            a value in the range [0..1], representing the imprecision existent in many real world applications.</para>
            
            <para>Let us consider, for example, fuzzy sets representing some temperature. In a given application, there is the 
            need to represent a cool and warm temperature. Like in real life, the precise point when the temperature changes from 
            cool to warm is not easy to find, and does not makes sense. If we consider the cool around 20 degrees and warm around 
            30 degrees, it is not simple to find a break point. If we take the mean, we can consider values greater than or equal 
            25 to be warm. But we can still consider 25 a bit cool. And a bit warm at the same time. This is where fuzzy sets can 
            help.</para>
            
            <para>Fuzzy sets are often used to compose Linguistic Variables, used in Fuzzy Inference Systems.</para>
            
            <para>Sample usage:</para>
            <code>
            // creating 2 fuzzy sets to represent Cool and Warm
            TrapezoidalFunction function1 = new TrapezoidalFunction( 13, 18, 23, 28 );
            FuzzySet fsCool = new FuzzySet( "Cool", function1 );
            TrapezoidalFunction function2 = new TrapezoidalFunction( 23, 28, 33, 38 );
            FuzzySet fsWarm = new FuzzySet( "Warm", function2 );
            
            // show membership to the Cool set for some values 
            Console.WriteLine( "COOL" );
            for ( int i = 13; i &lt;= 28; i++ )
                Console.WriteLine( fsCool.GetMembership( i ) );
            
            // show membership to the Warm set for some values 
            Console.WriteLine( "WARM" );
            for ( int i = 23; i &lt;= 38; i++ )
                Console.WriteLine( fsWarm.GetMembership( i ) );
            </code>    
            </remarks>
            
        </member>
        <member name="M:BestCS.Fuzzy.FuzzySet.#ctor(System.String,BestCS.Fuzzy.IMembershipFunction)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Fuzzy.FuzzySet"/> class.
            </summary>
            
            <param name="name">Name of the fuzzy set.</param>
            <param name="function">Membership function that will define the shape of the fuzzy set. </param>
            
        </member>
        <member name="M:BestCS.Fuzzy.FuzzySet.GetMembership(System.Single)">
            <summary>
            Calculate membership of a given value to the fuzzy set.
            </summary>
            
            <param name="x">Value which membership needs to be calculated.</param>
            
            <returns>Degree of membership [0..1] of the value to the fuzzy set.</returns>
            
        </member>
        <member name="P:BestCS.Fuzzy.FuzzySet.Name">
            <summary>
            Name of the fuzzy set.
            </summary>
        </member>
        <member name="P:BestCS.Fuzzy.FuzzySet.LeftLimit">
            <summary>
            The leftmost x value of the fuzzy set's membership function.
            </summary>
            
        </member>
        <member name="P:BestCS.Fuzzy.FuzzySet.RightLimit">
            <summary>
            The rightmost x value of the fuzzy set's membership function.
            </summary>
            
        </member>
        <member name="T:BestCS.Fuzzy.InferenceSystem">
            <summary>
            This class represents a Fuzzy Inference System. 
            </summary>
            
            <remarks><para>A Fuzzy Inference System is a model capable of executing fuzzy computing.
            It is mainly composed by a <see cref="T:BestCS.Fuzzy.Database"/> with the linguistic variables
            (see <see cref="T:BestCS.Fuzzy.LinguisticVariable"/>) and a <see cref="T:BestCS.Fuzzy.Rulebase"/>
            with the fuzzy rules (see <see cref="T:BestCS.Fuzzy.Rule"/>) that represent the behavior of the system.
            The typical operation of a Fuzzy Inference System is:
            <list type="bullet">
            <item>Get the numeric inputs;</item>
            <item>Use the <see cref="T:BestCS.Fuzzy.Database"/> with the linguistic variables
            (see <see cref="T:BestCS.Fuzzy.LinguisticVariable"/>) to obtain linguistic meaning for each
            numerical input;</item>
            <item>Verify which rules (see <see cref="T:BestCS.Fuzzy.Rule"/>) of the <see cref="T:BestCS.Fuzzy.Rulebase"/> are
            activated by the input;</item>
            <item>Combine the consequent of the activated rules to obtain a <see cref="T:BestCS.Fuzzy.FuzzyOutput"/>;</item>
            <item>Use some defuzzifier (see <see cref="T:BestCS.Fuzzy.IDefuzzifier"/>) to obtain a numerical output. </item>
            </list>
            </para>
            
            <para>The following sample usage is a Fuzzy Inference System that controls an
            auto guided vehicle avoing frontal collisions:</para>
            <code>
            // linguistic labels (fuzzy sets) that compose the distances
            FuzzySet fsNear = new FuzzySet( "Near",
                new TrapezoidalFunction( 15, 50, TrapezoidalFunction.EdgeType.Right ) );
            FuzzySet fsMedium = new FuzzySet( "Medium",
                new TrapezoidalFunction( 15, 50, 60, 100 ) );
            FuzzySet fsFar = new FuzzySet( "Far",
                new TrapezoidalFunction( 60, 100, TrapezoidalFunction.EdgeType.Left ) );
                        
            // front distance (input)
            LinguisticVariable lvFront = new LinguisticVariable( "FrontalDistance", 0, 120 );
            lvFront.AddLabel( fsNear );
            lvFront.AddLabel( fsMedium );
            lvFront.AddLabel( fsFar );
            
            // linguistic labels (fuzzy sets) that compose the angle
            FuzzySet fsZero = new FuzzySet( "Zero",
                new TrapezoidalFunction( -10, 5, 5, 10 ) );
            FuzzySet fsLP = new FuzzySet( "LittlePositive",
                new TrapezoidalFunction( 5, 10, 20, 25 ) );
            FuzzySet fsP = new FuzzySet( "Positive",
                new TrapezoidalFunction( 20, 25, 35, 40 ) );
            FuzzySet fsVP = new FuzzySet( "VeryPositive",
                new TrapezoidalFunction( 35, 40, TrapezoidalFunction.EdgeType.Left ) );
            
            // angle
            LinguisticVariable lvAngle = new LinguisticVariable( "Angle", -10, 50 );
            lvAngle.AddLabel( fsZero );
            lvAngle.AddLabel( fsLP );
            lvAngle.AddLabel( fsP );
            lvAngle.AddLabel( fsVP );
            
            // the database
            Database fuzzyDB = new Database( );
            fuzzyDB.AddVariable( lvFront );
            fuzzyDB.AddVariable( lvAngle );
            
            // creating the inference system
            InferenceSystem IS = new InferenceSystem( fuzzyDB, new CentroidDefuzzifier( 1000 ) );
            
            // going Straight
            IS.NewRule( "Rule 1", "IF FrontalDistance IS Far THEN Angle IS Zero" );
            // Turning Left
            IS.NewRule( "Rule 2", "IF FrontalDistance IS Near THEN Angle IS Positive" );
            
            ...
            // inference section
            
            // setting inputs
            IS.SetInput( "FrontalDistance", 20 );
            
            // getting outputs
            try
            {
                float newAngle = IS.Evaluate( "Angle" );
            }
            catch ( Exception )
            {
            ...
            }
            </code>    
            </remarks>
            
        </member>
        <member name="M:BestCS.Fuzzy.InferenceSystem.#ctor(BestCS.Fuzzy.Database,BestCS.Fuzzy.IDefuzzifier)">
            <summary>
            Initializes a new Fuzzy <see cref="T:BestCS.Fuzzy.InferenceSystem"/>.
            </summary>
            
            <param name="database">A fuzzy <see cref="T:BestCS.Fuzzy.Database"/> containing the system linguistic variables.</param>
            <param name="defuzzifier">A defuzzyfier method used to evaluate the numeric uotput of the system.</param>
            
        </member>
        <member name="M:BestCS.Fuzzy.InferenceSystem.#ctor(BestCS.Fuzzy.Database,BestCS.Fuzzy.IDefuzzifier,BestCS.Fuzzy.INorm,BestCS.Fuzzy.ICoNorm)">
            <summary>
            Initializes a new Fuzzy <see cref="T:BestCS.Fuzzy.InferenceSystem"/>.
            </summary>
            
            <param name="database">A fuzzy <see cref="T:BestCS.Fuzzy.Database"/> containing the system linguistic
            variables.</param>
            <param name="defuzzifier">A defuzzyfier method used to evaluate the numeric otput
            of the system.</param>
            <param name="normOperator">A <see cref="T:BestCS.Fuzzy.INorm"/> operator used to evaluate the norms
            in the <see cref="T:BestCS.Fuzzy.InferenceSystem"/>. For more information of the norm evaluation see <see cref="T:BestCS.Fuzzy.Rule"/>.</param>
            <param name="conormOperator">A <see cref="T:BestCS.Fuzzy.ICoNorm"/> operator used to evaluate the
            conorms in the <see cref="T:BestCS.Fuzzy.InferenceSystem"/>. For more information of the conorm evaluation see <see cref="T:BestCS.Fuzzy.Rule"/>.</param>
            
        </member>
        <member name="M:BestCS.Fuzzy.InferenceSystem.NewRule(System.String,System.String)">
            <summary>
            Creates a new <see cref="T:BestCS.Fuzzy.Rule"/> and add it to the <see cref="T:BestCS.Fuzzy.Rulebase"/> of the 
            <see cref="T:BestCS.Fuzzy.InferenceSystem"/>.
            </summary>
            
            <param name="name">Name of the <see cref="T:BestCS.Fuzzy.Rule"/> to create.</param>
            <param name="rule">A string representing the fuzzy rule.</param>
            
            <returns>The new <see cref="T:BestCS.Fuzzy.Rule"/> reference. </returns>
            
        </member>
        <member name="M:BestCS.Fuzzy.InferenceSystem.SetInput(System.String,System.Single)">
            <summary>
            Sets a numerical input for one of the linguistic variables of the <see cref="T:BestCS.Fuzzy.Database"/>. 
            </summary>
            
            <param name="variableName">Name of the <see cref="T:BestCS.Fuzzy.LinguisticVariable"/>.</param>
            <param name="value">Numeric value to be used as input.</param>
            
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The variable indicated in <paramref name="variableName"/>
            was not found in the database.</exception>
            
        </member>
        <member name="M:BestCS.Fuzzy.InferenceSystem.GetLinguisticVariable(System.String)">
            <summary>
            Gets one of the <see cref="T:BestCS.Fuzzy.LinguisticVariable"/> of the <see cref="T:BestCS.Fuzzy.Database"/>. 
            </summary>
            
            <param name="variableName">Name of the <see cref="T:BestCS.Fuzzy.LinguisticVariable"/> to get.</param>
            
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The variable indicated in <paramref name="variableName"/>
            was not found in the database.</exception>
            
        </member>
        <member name="M:BestCS.Fuzzy.InferenceSystem.GetRule(System.String)">
            <summary>
            Gets one of the Rules of the <see cref="T:BestCS.Fuzzy.Rulebase"/>. 
            </summary>
            
            <param name="ruleName">Name of the <see cref="T:BestCS.Fuzzy.Rule"/> to get.</param>
            
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The rule indicated in <paramref name="ruleName"/>
            was not found in the rulebase.</exception>
            
        </member>
        <member name="M:BestCS.Fuzzy.InferenceSystem.Evaluate(System.String)">
            <summary>
            Executes the fuzzy inference, obtaining a numerical output for a choosen output
            linguistic variable. 
            </summary>
            
            <param name="variableName">Name of the <see cref="T:BestCS.Fuzzy.LinguisticVariable"/> to evaluate.</param>
            
            <returns>The numerical output of the Fuzzy Inference System for the choosen variable.</returns>
            
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The variable indicated was not found in the database.</exception>
            
        </member>
        <member name="M:BestCS.Fuzzy.InferenceSystem.ExecuteInference(System.String)">
            <summary>
            Executes the fuzzy inference, obtaining the <see cref="T:BestCS.Fuzzy.FuzzyOutput"/> of the system for the required
            <see cref="T:BestCS.Fuzzy.LinguisticVariable"/>. 
            </summary>
            
            <param name="variableName">Name of the <see cref="T:BestCS.Fuzzy.LinguisticVariable"/> to evaluate.</param>
            
            <returns>A <see cref="T:BestCS.Fuzzy.FuzzyOutput"/> containing the fuzzy output of the system for the
            <see cref="T:BestCS.Fuzzy.LinguisticVariable"/> specified in <paramref name="variableName"/>.</returns>
            
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The variable indicated was not found in the database.</exception>
            
        </member>
        <member name="T:BestCS.Fuzzy.LinguisticVariable">
             <summary>
             The class represents a linguistic variable.
             </summary>
             
             <remarks><para>Linguistic variables are variables that store linguistic values (labels). Fuzzy Inference Systems (FIS)
             use a set of linguistic variables, called the FIS database, to execute fuzzy computation (computing with words). A linguistic
             variable has a name and is composed by a set of <see cref="T:BestCS.Fuzzy.FuzzySet"/> called its linguistic labels. When declaring fuzzy 
             statements in a FIS, a linguistic variable can be only assigned or compared to one of its labels. </para>
             
             <para>Let us consider, for example, a linguistic variable <b>temperature</b>. In a given application, temperature can be 
             cold, cool, warm or hot. Those will be the variable's linguistic labels, each one a fuzzy set with its own membership 
             function. Ideally, the labels will represent concepts related to the variable's meaning. Futhermore, fuzzy statements like
             "temperature is warm" or "temperature is not cold" can be used to build a Fuzzy Inference Systems. 
             </para>
             
             <para>Sample usage:</para>
             <code>
             // create a linguistic variable to represent temperature
             LinguisticVariable lvTemperature = new LinguisticVariable( "Temperature", 0, 80 );
            
             // create the linguistic labels (fuzzy sets) that compose the temperature 
             TrapezoidalFunction function1 = new TrapezoidalFunction( 10, 15, TrapezoidalFunction.EdgeType.Right );
             FuzzySet fsCold = new FuzzySet( "Cold", function1 );
             TrapezoidalFunction function2 = new TrapezoidalFunction( 10, 15, 20, 25 );
             FuzzySet fsCool = new FuzzySet( "Cool", function2 );
             TrapezoidalFunction function3 = new TrapezoidalFunction( 20, 25, 30, 35 );
             FuzzySet fsWarm = new FuzzySet( "Warm", function3 );
             TrapezoidalFunction function4 = new TrapezoidalFunction( 30, 35, TrapezoidalFunction.EdgeType.Left );
             FuzzySet fsHot  = new FuzzySet( "Hot" , function4 );
            
             // adding labels to the variable
             lvTemperature.AddLabel( fsCold );
             lvTemperature.AddLabel( fsCool );
             lvTemperature.AddLabel( fsWarm );
             lvTemperature.AddLabel( fsHot  );
            
             // showing the shape of the linguistic variable - the shape of its labels memberships from start to end
             Console.WriteLine( "Cold; Cool; Warm; Hot" );
             for ( float x = 0; x &lt; 80; x += 0.2 )
             {
                 float y1 = lvTemperature.GetLabelMembership( "Cold", x );
                 float y2 = lvTemperature.GetLabelMembership( "Cool", x );
                 float y3 = lvTemperature.GetLabelMembership( "Warm", x );
                 float y4 = lvTemperature.GetLabelMembership( "Hot" , x );
            
                 Console.WriteLine( String.Format( "{0:N}; {1:N}; {2:N}; {3:N}", y1, y2, y3, y4 ) );
             }
             </code>    
             </remarks>
             
        </member>
        <member name="M:BestCS.Fuzzy.LinguisticVariable.#ctor(System.String,System.Single,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Fuzzy.LinguisticVariable"/> class.
            </summary>
            
            <param name="name">Name of the linguistic variable.</param>
            
            <param name="start">Left limit of the valid variable range.</param>
            
            <param name="end">Right limit of the valid variable range.</param>
            
        </member>
        <member name="M:BestCS.Fuzzy.LinguisticVariable.AddLabel(BestCS.Fuzzy.FuzzySet)">
            <summary>
            Adds a linguistic label to the variable. 
            </summary>
            
            <param name="label">A <see cref="T:BestCS.Fuzzy.FuzzySet"/> that will be a linguistic label of the linguistic variable.</param>
            
            <remarks>Linguistic labels are fuzzy sets (<see cref="T:BestCS.Fuzzy.FuzzySet"/>). Each
            label of the variable must have a unique name. The range of the label 
            (left and right limits) cannot be greater than 
            the linguistic variable range (start/end).</remarks>
            
            <exception cref="T:System.NullReferenceException">The fuzzy set was not initialized.</exception>
            <exception cref="T:System.ArgumentException">The linguistic label name already exists in the linguistic variable.</exception>
            <exception cref="T:System.ArgumentException">The left limit of the fuzzy set can not be lower than the linguistic variable's starting point.</exception>
            <exception cref="T:System.ArgumentException">"The right limit of the fuzzy set can not be greater than the linguistic variable's ending point."</exception>
            
        </member>
        <member name="M:BestCS.Fuzzy.LinguisticVariable.ClearLabels">
            <summary>
            Removes all the linguistic labels of the linguistic variable. 
            </summary>
            
        </member>
        <member name="M:BestCS.Fuzzy.LinguisticVariable.GetLabel(System.String)">
            <summary>
            Returns an existing label from the linguistic variable.
            </summary>
            
            <param name="labelName">Name of the label to retrieve.</param>
            
            <returns>Reference to named label (<see cref="T:BestCS.Fuzzy.FuzzySet"/>).</returns>
            
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The label indicated was not found in the linguistic variable.</exception>
            
        </member>
        <member name="M:BestCS.Fuzzy.LinguisticVariable.GetLabelMembership(System.String,System.Single)">
            <summary>
            Calculate the membership of a given value to a given label. Used to evaluate linguistics clauses like 
            "X IS A", where X is a value and A is a linguistic label.
            </summary>
            
            <param name="labelName">Label (fuzzy set) to evaluate value's membership.</param>
            <param name="value">Value which label's membership will to be calculated.</param>
            
            <returns>Degree of membership [0..1] of the value to the label (fuzzy set).</returns>
            
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The label indicated in labelName was not found in the linguistic variable.</exception>
            
        </member>
        <member name="P:BestCS.Fuzzy.LinguisticVariable.NumericInput">
            <summary>
            Numerical value of the input of this linguistic variable.
            </summary>
        </member>
        <member name="P:BestCS.Fuzzy.LinguisticVariable.Name">
            <summary>
            Name of the linguistic variable.
            </summary>
        </member>
        <member name="P:BestCS.Fuzzy.LinguisticVariable.Start">
            <summary>
            Left limit of the valid variable range.
            </summary>
        </member>
        <member name="P:BestCS.Fuzzy.LinguisticVariable.End">
            <summary>
            Right limit of the valid variable range.
            </summary>
        </member>
        <member name="T:BestCS.Fuzzy.IMembershipFunction">
            <summary>
            Interface which specifies set of methods required to be implemented by all membership
            functions.
            </summary>
            
            <remarks><para>All membership functions must implement this interface, which is used by
            <see cref="T:BestCS.Fuzzy.FuzzySet"/> class to calculate value's membership to a particular fuzzy set.
            </para></remarks>
            
        </member>
        <member name="M:BestCS.Fuzzy.IMembershipFunction.GetMembership(System.Single)">
            <summary>
            Calculate membership of a given value to the fuzzy set.
            </summary>
            
            <param name="x">Value which membership will to be calculated.</param>
            
            <returns>Degree of membership [0..1] of the value to the fuzzy set.</returns>
            
        </member>
        <member name="P:BestCS.Fuzzy.IMembershipFunction.LeftLimit">
            <summary>
            The leftmost x value of the membership function.
            </summary>
        </member>
        <member name="P:BestCS.Fuzzy.IMembershipFunction.RightLimit">
            <summary>
            The rightmost x value of the membership function.
            </summary>
        </member>
        <member name="T:BestCS.Fuzzy.PiecewiseLinearFunction">
            <summary>
            Membership function composed by several connected linear functions.
            </summary>
            
            <remarks><para>The piecewise linear is a generic function used by many specific fuzzy membership 
            functions, like the <see cref="T:BestCS.Fuzzy.TrapezoidalFunction">trappezoidal function</see>. This class must
            be instantiated with a sequence of points representing the edges of each one of the lines composing the 
            piecewise function.</para>
            
            <para><note>The x-axis points must be ordered (crescent), so the <see cref="M:BestCS.Fuzzy.PiecewiseLinearFunction.GetMembership(System.Single)"/> function will use each X value 
            as an ending point for one line and starting point of the next.</note></para>
            
            <para>While trapezoidal and half trapezoidal are classic functions used in fuzzy functions, this class supports any function
            or approximation that can be represented as a sequence of lines.</para>
            
            <para>Sample usage:</para>
            <code>
            // creating an array of points representing a typical trapezoidal function /-\
            Point [] points = new Point[4];
            // point where membership starts to rise
            points[0] = new Point( 10, 0 );
            // maximum membership (1) reached at the second point 
            points[1] = new Point( 20, 1 );
            // membership starts to fall at the third point 
            points[2] = new Point( 30, 1 );
            // membership gets to zero at the last point 
            points[3] = new Point( 40, 0 );
            // creating the instance
            PiecewiseLinearFunction membershipFunction = new PiecewiseLinearFunction( points );
            // getting membership for several points
            for ( int i = 5; i &lt; 45; i++ )
                Console.WriteLine( membershipFunction.GetMembership( i ) );
            </code>
            </remarks>
            
        </member>
        <member name="F:BestCS.Fuzzy.PiecewiseLinearFunction.points">
            <summary>
            Vector of (X,Y) coordinates for end/start of each line.
            </summary>
        </member>
        <member name="M:BestCS.Fuzzy.PiecewiseLinearFunction.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Fuzzy.PiecewiseLinearFunction"/> class. 
            </summary>
            
            <remarks><para>This constructor must be used only by inherited classes to create the
            points vector after the instantiation.</para></remarks>
            
        </member>
        <member name="M:BestCS.Fuzzy.PiecewiseLinearFunction.#ctor(BestCS.Point[])">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Fuzzy.PiecewiseLinearFunction"/> class.
            </summary>
            
            <param name="points">Array of (X,Y) coordinates of each start/end of the lines.</param>
            
            <remarks><para>Specified point must be in crescent order on X axis and their Y value
            must be in the range of [0, 1].</para></remarks>
            
            <exception cref="T:System.ArgumentException">Points must be in crescent order on X axis.</exception>
            <exception cref="T:System.ArgumentException">Y value of points must be in the range of [0, 1].</exception>
            
        </member>
        <member name="M:BestCS.Fuzzy.PiecewiseLinearFunction.GetMembership(System.Single)">
             <summary>
             Calculate membership of a given value to the piecewise function.
             </summary>
             
             <param name="x">Value which membership will to be calculated.</param>
             
             <returns>Degree of membership [0..1] of the value to the fuzzy set.</returns>
             
             <exception cref="T:System.NullReferenceException">Points of the membership function are not initialized.</exception>
            
        </member>
        <member name="P:BestCS.Fuzzy.PiecewiseLinearFunction.LeftLimit">
             <summary>
             The leftmost x value of the membership function, given by the first (X,Y) coordinate.
             </summary>
             
             <exception cref="T:System.NullReferenceException">Points of the membership function are not initialized.</exception>
            
        </member>
        <member name="P:BestCS.Fuzzy.PiecewiseLinearFunction.RightLimit">
             <summary>
             The rightmost x value of the membership function, given by the last (X,Y) coordinate.
             </summary>
             
             <exception cref="T:System.NullReferenceException">Points of the membership function are not initialized.</exception>
            
        </member>
        <member name="T:BestCS.Fuzzy.SingletonFunction">
            <summary>
            Membership function used in fuzzy singletons: fuzzy sets that have just one point with membership value 1. 
            </summary>
            
            <remarks><para>Sometimes it is needed to represent crisp (classical) number in the fuzzy domain. Several approaches 
            can be used, like adding some uncertain (fuzziness) in the original number (the number one, for instance, can be seen as a <see cref="T:BestCS.Fuzzy.TrapezoidalFunction"/>
            with -0.5, 1.0 and 0.5 parameters). Another approach is to declare fuzzy singletons: fuzzy sets with only one point returning a none zero membership.</para>
            
            <para>While trapezoidal and half trapezoidal are classic functions used in fuzzy functions, this class supports any function
            or approximation that can be represented as a sequence of lines.</para>
            
            <para>Sample usage:</para>
            <code>
            // creating the instance
            SingletonFunction membershipFunction = new SingletonFunction( 10 );
            // getting membership for several points
            for ( int i = 0; i &lt; 20; i++ )
                Console.WriteLine( membershipFunction.GetMembership( i ) );
            </code>
            </remarks>
            
        </member>
        <member name="F:BestCS.Fuzzy.SingletonFunction.support">
            <summary>
            The unique point where the membership value is 1.
            </summary>
        </member>
        <member name="M:BestCS.Fuzzy.SingletonFunction.#ctor(System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Fuzzy.SingletonFunction"/> class. 
            </summary>
            
            <param name="support">Support is the only value of x where the membership function is 1.</param>
            
        </member>
        <member name="M:BestCS.Fuzzy.SingletonFunction.GetMembership(System.Single)">
            <summary>
            Calculate membership of a given value to the singleton function.
            </summary>
            
            <param name="x">Value which membership will to be calculated.</param>
            
            <returns>Degree of membership {0,1} since singletons do not admit memberships different from 0 and 1. </returns>
            
        </member>
        <member name="P:BestCS.Fuzzy.SingletonFunction.LeftLimit">
            <summary>
            The leftmost x value of the membership function, the same value of the support.
            </summary>
            
        </member>
        <member name="P:BestCS.Fuzzy.SingletonFunction.RightLimit">
            <summary>
            The rightmost x value of the membership function, the same value of the support.
            </summary>
            
        </member>
        <member name="T:BestCS.Fuzzy.TrapezoidalFunction">
            <summary>
            Membership function in the shape of a trapezoid. Can be a half trapzoid if the left or the right side is missing. 
            </summary>
            
            <remarks><para>Since the <see cref="T:BestCS.Fuzzy.PiecewiseLinearFunction"/> can represent any piece wise linear
            function, it can represent trapezoids too. But as trapezoids are largely used in the creation of
            Linguistic Variables, this class simplifies the creation of them. </para>
            
            <para>Sample usage:</para>
            <code>
            // creating a typical triangular fuzzy set /\
            TrapezoidalFunction function1 = new TrapezoidalFunction( 10, 20, 30 );
            // creating a right fuzzy set, the rigth side of the set is fuzzy but the left is opened
            TrapezoidalFunction function2 = new TrapezoidalFunction( 10, 20, 30, TrapezoidalFunction.EdgeType.Right );
            </code>
            
            </remarks>
        </member>
        <member name="M:BestCS.Fuzzy.TrapezoidalFunction.#ctor(System.Int32)">
            <summary>
            A private constructor used only to reuse code inside of this default constructor.
            </summary>
            
            <param name="size">Size of points vector to create. This size depends of the shape of the 
            trapezoid.</param>
            
        </member>
        <member name="M:BestCS.Fuzzy.TrapezoidalFunction.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Fuzzy.TrapezoidalFunction"/> class.
            
            With four points the shape is known as flat fuzzy number or fuzzy interval (/--\).
            </summary>
            
            <param name="m1">X value where the degree of membership starts to raise.</param>
            <param name="m2">X value where the degree of membership reaches the maximum value.</param>
            <param name="m3">X value where the degree of membership starts to fall.</param>
            <param name="m4">X value where the degree of membership reaches the minimum value.</param>
            <param name="max">The maximum value that the membership will reach, [0, 1].</param>
            <param name="min">The minimum value that the membership will reach, [0, 1].</param>
            
        </member>
        <member name="M:BestCS.Fuzzy.TrapezoidalFunction.#ctor(System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Fuzzy.TrapezoidalFunction"/> class.
            
            With four points the shape is known as flat fuzzy number or fuzzy interval (/--\).
            </summary>
            
            <param name="m1">X value where the degree of membership starts to raise.</param>
            <param name="m2">X value where the degree of membership reaches the maximum value.</param>
            <param name="m3">X value where the degree of membership starts to fall.</param>
            <param name="m4">X value where the degree of membership reaches the minimum value.</param>
            
            <remarks>
            <para>Maximum membership value is set to <b>1.0</b> and the minimum is set to <b>0.0</b>.</para>
            </remarks>
            
        </member>
        <member name="M:BestCS.Fuzzy.TrapezoidalFunction.#ctor(System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Fuzzy.TrapezoidalFunction"/> class.
            
            With three points the shape is known as triangular fuzzy number or just fuzzy number (/\).
            </summary>
            
            <param name="m1">X value where the degree of membership starts to raise.</param>
            <param name="m2">X value where the degree of membership reaches the maximum value and starts to fall.</param>
            <param name="m3">X value where the degree of membership reaches the minimum value.</param>
            <param name="max">The maximum value that the membership will reach, [0, 1].</param>
            <param name="min">The minimum value that the membership will reach, [0, 1].</param>
            
        </member>
        <member name="M:BestCS.Fuzzy.TrapezoidalFunction.#ctor(System.Single,System.Single,System.Single)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Fuzzy.TrapezoidalFunction"/> class.
            
            With three points the shape is known as triangular fuzzy number or just fuzzy number (/\).
            </summary>
            
            <param name="m1">X value where the degree of membership starts to raise.</param>
            <param name="m2">X value where the degree of membership reaches the maximum value and starts to fall.</param>
            <param name="m3">X value where the degree of membership reaches the minimum value.</param>
            
            <remarks>
            <para>Maximum membership value is set to <b>1.0</b> and the minimum is set to <b>0.0</b>.</para>
            </remarks>
            
        </member>
        <member name="M:BestCS.Fuzzy.TrapezoidalFunction.#ctor(System.Single,System.Single,System.Single,System.Single,BestCS.Fuzzy.TrapezoidalFunction.EdgeType)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Fuzzy.TrapezoidalFunction"/> class.
            
            With two points and an edge this shape can be a left fuzzy number (/) or a right fuzzy number (\).
            </summary>
            
            <param name="m1">Edge = Left: X value where the degree of membership starts to raise.
            Edge = Right: X value where the function starts, with maximum degree of membership. </param>
            <param name="m2">Edge = Left: X value where the degree of membership reaches the maximum.
            Edge = Right: X value where the degree of membership reaches minimum value. </param>
            <param name="max">The maximum value that the membership will reach, [0, 1].</param>
            <param name="min">The minimum value that the membership will reach, [0, 1].</param>
            <param name="edge">Trapezoid's <see cref="T:BestCS.Fuzzy.TrapezoidalFunction.EdgeType"/>.</param>
            
        </member>
        <member name="M:BestCS.Fuzzy.TrapezoidalFunction.#ctor(System.Single,System.Single,BestCS.Fuzzy.TrapezoidalFunction.EdgeType)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Fuzzy.TrapezoidalFunction"/> class.
            
            With three points and an edge this shape can be a left fuzzy number (/--) or a right fuzzy number (--\).
            </summary>
            
            <param name="m1">Edge = Left: X value where the degree of membership starts to raise.
            Edge = Right: X value where the function starts, with maximum degree of membership. </param>
            <param name="m2">Edge = Left: X value where the degree of membership reaches the maximum.
            Edge = Right: X value where the degree of membership reaches minimum value. </param>
            <param name="edge">Trapezoid's <see cref="T:BestCS.Fuzzy.TrapezoidalFunction.EdgeType"/>.</param>
            
            <remarks>
            <para>Maximum membership value is set to <b>1.0</b> and the minimum is set to <b>0.0</b>.</para>
            </remarks>
            
        </member>
        <member name="T:BestCS.Fuzzy.TrapezoidalFunction.EdgeType">
            <summary>
            Enumeration used to create trapezoidal membership functions with half trapezoids.
            </summary>
            
            <remarks><para>If the value is Left, the trapezoid has the left edge, but right
            is open (/--). If the value is Right, the trapezoid has the right edge, but left
            is open (--\).</para></remarks>
            
        </member>
        <member name="F:BestCS.Fuzzy.TrapezoidalFunction.EdgeType.Left">
            <summary>
            The fuzzy side of the trapezoid is at the left side.
            </summary>
        </member>
        <member name="F:BestCS.Fuzzy.TrapezoidalFunction.EdgeType.Right">
            <summary>
            The fuzzy side of the trapezoid is at the right side.
            </summary>
        </member>
        <member name="T:BestCS.Fuzzy.ICoNorm">
            <summary>
            Interface with the common methods of a Fuzzy CoNorm.
            </summary>
            
            <remarks><para>All fuzzy operators that act as a CoNorm must implement this interface.
            </para></remarks>
            
        </member>
        <member name="M:BestCS.Fuzzy.ICoNorm.Evaluate(System.Single,System.Single)">
            <summary>
            Calculates the numerical result of a CoNorm (OR) operation applied to
            two fuzzy membership values.
            </summary>
            
            <param name="membershipA">A fuzzy membership value, [0..1].</param>
            <param name="membershipB">A fuzzy membership value, [0..1].</param>
            
            <returns>The numerical result the operation OR applied to <paramref name="membershipA"/>
            and <paramref name="membershipB"/>.</returns>
            
        </member>
        <member name="T:BestCS.Fuzzy.INorm">
            <summary>
            Interface with the common methods of a Fuzzy Norm.
            </summary>
            
            <remarks><para>All fuzzy operators that act as a Norm must implement this interface.
            </para></remarks>
            
        </member>
        <member name="M:BestCS.Fuzzy.INorm.Evaluate(System.Single,System.Single)">
            <summary>
            Calculates the numerical result of a Norm (AND) operation applied to
            two fuzzy membership values.
            </summary>
            
            <param name="membershipA">A fuzzy membership value, [0..1].</param>
            <param name="membershipB">A fuzzy membership value, [0..1].</param>
            
            <returns>The numerical result the operation AND applied to <paramref name="membershipA"/>
            and <paramref name="membershipB"/>.</returns>
            
        </member>
        <member name="T:BestCS.Fuzzy.IUnaryOperator">
            <summary>
            Interface with the common methods of Fuzzy Unary Operator.
            </summary>
            
            <remarks><para>All fuzzy operators that act as a Unary Operator (NOT, VERY, LITTLE) must implement this interface.
            </para></remarks>
            
        </member>
        <member name="M:BestCS.Fuzzy.IUnaryOperator.Evaluate(System.Single)">
            <summary>
            Calculates the numerical result of a Unary operation applied to one
            fuzzy membership value.
            </summary>
            
            <param name="membership">A fuzzy membership value, [0..1].</param>
            
            <returns>The numerical result of the operation applied to <paramref name="membership"/></returns>.
            
        </member>
        <member name="T:BestCS.Fuzzy.MaximumCoNorm">
            <summary>
            Maximum CoNorm, used to calculate the linguistic value of a OR operation. 
            </summary>
            
            <remarks><para>The maximum CoNorm uses a maximum operator to compute the OR
            among two fuzzy memberships.</para>
            
            <para>Sample usage:</para>
            <code>
            // creating 2 fuzzy sets to represent Cool (Temperature) and Near (Distance)
            TrapezoidalFunction function1 = new TrapezoidalFunction( 13, 18, 23, 28 );
            FuzzySet fsCool = new FuzzySet( "Cool", function1 );
            TrapezoidalFunction function2 = new TrapezoidalFunction( 23, 28, 33, 38 );
            FuzzySet fsNear = new FuzzySet( "Near", function2 );
            
            // getting memberships
            float m1 = fsCool.GetMembership( 15 );
            float m2 = fsNear.GetMembership( 35 );
            
            // computing the membership of "Cool OR Near"
            MaximumCoNorm OR = new MaximumCoNorm( );
            float result = OR.Evaluate( m1, m2 );
                         
            // show result
            Console.WriteLine( result );
            </code>
            </remarks>
            
            <seealso cref="T:BestCS.Fuzzy.ICoNorm"/>
            
        </member>
        <member name="M:BestCS.Fuzzy.MaximumCoNorm.Evaluate(System.Single,System.Single)">
            <summary>
            Calculates the numerical result of the OR operation applied to
            two fuzzy membership values.
            </summary>
            
            <param name="membershipA">A fuzzy membership value, [0..1].</param>
            <param name="membershipB">A fuzzy membership value, [0..1].</param>
            
            <returns>The numerical result of the binary operation OR applied to <paramref name="membershipA"/>
            and <paramref name="membershipB"/>.</returns>
            
        </member>
        <member name="T:BestCS.Fuzzy.MinimumNorm">
            <summary>
            Minimum Norm, used to calculate the linguistic value of a AND operation. 
            </summary>
            
            <remarks><para>The minimum Norm uses a minimum operator to compute the AND
            among two fuzzy memberships. </para>
            
            <para>Sample usage:</para>
            <code>
            // creating 2 fuzzy sets to represent Cool (Temperature) and Near (Distance)
            TrapezoidalFunction function1 = new TrapezoidalFunction( 13, 18, 23, 28 );
            FuzzySet fsCool = new FuzzySet( "Cool", function1 );
            TrapezoidalFunction function2 = new TrapezoidalFunction( 23, 28, 33, 38 );
            FuzzySet fsNear = new FuzzySet( "Near", function2 );
            
            // getting memberships
            float m1 = fsCool.GetMembership( 15 );
            float m2 = fsNear.GetMembership( 35 );
            
            // computing the membership of "Cool AND Near"
            MinimumNorm AND = new MinimumNorm( );
            float result = AND.Evaluate( m1, m2 );
                         
            // show result
            Console.WriteLine( result );
            </code>
            </remarks>
            
            <seealso cref="T:BestCS.Fuzzy.ProductNorm"/>
            
        </member>
        <member name="M:BestCS.Fuzzy.MinimumNorm.Evaluate(System.Single,System.Single)">
            <summary>
            Calculates the numerical result of the AND operation applied to
            two fuzzy membership values using the minimum rule.
            </summary>
            
            <param name="membershipA">A fuzzy membership value, [0..1].</param>
            
            <param name="membershipB">A fuzzy membership value, [0..1].</param>
            
            <returns>The numerical result of the AND operation applied to <paramref name="membershipA"/>
            and <paramref name="membershipB"/>.</returns>
            
        </member>
        <member name="T:BestCS.Fuzzy.NotOperator">
            <summary>
            NOT operator, used to calculate the complement of a fuzzy set. 
            </summary>
            
            <remarks><para>The NOT operator definition is (1 - m) for all the values of membership m of the fuzzy set.</para>
            
            <para>Sample usage:</para>
            <code>
            // creating a fuzzy sets to represent Cool (Temperature)
            TrapezoidalFunction function1 = new TrapezoidalFunction( 13, 18, 23, 28 );
            FuzzySet fsCool = new FuzzySet( "Cool", function1 );
            
            // getting membership
            float m1 = fsCool.GetMembership( 15 );
            
            // computing the membership of "NOT Cool"
            NotOperator NOT = new NotOperator( );
            float result = NOT.Evaluate( m1 );
                         
            // show result
            Console.WriteLine( result );
            </code>
            </remarks>
            
            <seealso cref="T:BestCS.Fuzzy.IUnaryOperator"/>
            
        </member>
        <member name="M:BestCS.Fuzzy.NotOperator.Evaluate(System.Single)">
            <summary>
            Calculates the numerical result of the NOT operation applied to
            a fuzzy membership value.
            </summary>
            
            <param name="membership">A fuzzy membership value, [0..1].</param>
            
            <returns>The numerical result of the unary operation NOT applied to <paramref name="membership"/>.</returns>
            
        </member>
        <member name="T:BestCS.Fuzzy.ProductNorm">
            <summary>
            Product Norm, used to calculate the linguistic value of a AND operation. 
            </summary>
            
            <remarks><para>The product Norm uses a multiplication operator to compute the
            AND among two fuzzy memberships.</para>
            
            <para>Sample usage:</para>
            <code>
            // creating 2 fuzzy sets to represent Cool (Temperature) and Near (Distance)
            TrapezoidalFunction function1 = new TrapezoidalFunction( 13, 18, 23, 28 );
            FuzzySet fsCool = new FuzzySet( "Cool", function1 );
            TrapezoidalFunction function2 = new TrapezoidalFunction( 23, 28, 33, 38 );
            FuzzySet fsNear = new FuzzySet( "Near", function2 );
            
            // getting memberships
            float m1 = fsCool.GetMembership( 15 );
            float m2 = fsNear.GetMembership( 35 );
            
            // computing the membership of "Cool AND Near"
            ProductNorm AND = new ProductNorm( );
            float result = AND.Evaluate( m1, m2 );
                         
            // show result
            Console.WriteLine( result );
            </code>
            </remarks>
            
            <seealso cref="T:BestCS.Fuzzy.MinimumNorm"/>
            
        </member>
        <member name="M:BestCS.Fuzzy.ProductNorm.Evaluate(System.Single,System.Single)">
            <summary>
            Calculates the numerical result of the AND operation applied to
            two fuzzy membership values using the product rule.
            </summary>
            
            <param name="membershipA">A fuzzy membership value, [0..1].</param>
            <param name="membershipB">A fuzzy membership value, [0..1].</param>
            
            <returns>The numerical result of the AND operation applied to <paramref name="membershipA"/>
            and <paramref name="membershipB"/>.</returns>
            
        </member>
        <member name="T:BestCS.Fuzzy.Rule">
             <summary>
             This class represents a Fuzzy Rule, a linguistic expression representing some behavioral
             aspect of a Fuzzy Inference System. 
             </summary>
             
             <remarks><para>
             A Fuzzy Rule is a fuzzy linguistic instruction that can be executed by a fuzzy system.
             The format of the Fuzzy Rule is:
             </para>
             
             <para><b>IF <i>antecedent</i> THEN <i>consequent</i></b></para>
             
             <para>The antecedent is composed by a set of fuzzy clauses (see <see cref="T:BestCS.Fuzzy.Clause"/>) connected
             by fuzzy operations, like <b>AND</b> or <b>OR</b>. The operator <b>NOT</b> can be used to negate expressions: </para>
             
             <para><b>...<i>Clause1</i> AND (<i>Clause2</i> OR <i>Clause3</i>) AND NOT <i>Clause4</i> ...</b></para>
                 
             <para>Fuzzy clauses are written in form <i>Variable IS Value</i>. The NOT operator can be used to negate linguistic values as well:<br/>
             <b>...<i>Variable1 IS Value1</i> AND <i>Variable2 IS NOT Value2</i> ...</b></para>
            
             <para>The consequent is a single of fuzzy clauses (<see cref="T:BestCS.Fuzzy.Clause"/>). To perform the
             linguistic computing, the <see cref="T:BestCS.Fuzzy.Rule"/> evaluates the clauses and then applies the fuzzy
             operators. Once this is done a value representing the confidence in the antecedent being
             true is obtained, and this is called firing strength of the <see cref="T:BestCS.Fuzzy.Rule"/>.</para>
             
             <para>The firing strength is used to discover with how much confidence the consequent
             of a rule is true.</para>
             
             <para>Sample usage:</para>
             <code>
             // create the linguistic labels (fuzzy sets) that compose the temperature 
             TrapezoidalFunction function1 = new TrapezoidalFunction(
                 10, 15, TrapezoidalFunction.EdgeType.Right );
             FuzzySet fsCold = new FuzzySet( "Cold", function1 );
             TrapezoidalFunction function2 = new TrapezoidalFunction( 10, 15, 20, 25 );
             FuzzySet fsCool = new FuzzySet( "Cool", function2 );
             TrapezoidalFunction function3 = new TrapezoidalFunction( 20, 25, 30, 35 );
             FuzzySet fsWarm = new FuzzySet( "Warm", function3 );
             TrapezoidalFunction function4 = new TrapezoidalFunction(
                 30, 35, TrapezoidalFunction.EdgeType.Left );
             FuzzySet fsHot = new FuzzySet( "Hot", function4 );
             
             // create a linguistic variable to represent steel temperature
             LinguisticVariable lvSteel = new LinguisticVariable( "Steel", 0, 80 );
             // adding labels to the variable
             lvSteel.AddLabel( fsCold );
             lvSteel.AddLabel( fsCool );
             lvSteel.AddLabel( fsWarm );
             lvSteel.AddLabel( fsHot );
             
             // create a linguistic variable to represent stove temperature
             LinguisticVariable lvStove = new LinguisticVariable( "Stove", 0, 80 );
             // adding labels to the variable
             lvStove.AddLabel( fsCold );
             lvStove.AddLabel( fsCool );
             lvStove.AddLabel( fsWarm );
             lvStove.AddLabel( fsHot );
             
             // create the linguistic labels (fuzzy sets) that compose the pressure
             TrapezoidalFunction function5 = new TrapezoidalFunction(
                 20, 40, TrapezoidalFunction.EdgeType.Right );
             FuzzySet fsLow = new FuzzySet( "Low", function5 );
             TrapezoidalFunction function6 = new TrapezoidalFunction( 20, 40, 60, 80 );
             FuzzySet fsMedium = new FuzzySet( "Medium", function6 );
             TrapezoidalFunction function7 = new TrapezoidalFunction(
                 60, 80, TrapezoidalFunction.EdgeType.Left );
             FuzzySet fsHigh = new FuzzySet( "High", function7 );
             // create a linguistic variable to represent pressure
             LinguisticVariable lvPressure = new LinguisticVariable( "Pressure", 0, 100 );
             // adding labels to the variable
             lvPressure.AddLabel( fsLow );
             lvPressure.AddLabel( fsMedium );
             lvPressure.AddLabel( fsHigh );
             
             // create a linguistic variable database
             Database db = new Database( );
             db.AddVariable( lvSteel );
             db.AddVariable( lvStove );
             db.AddVariable( lvPressure );
             
             // sample rules just to test the expression parsing
             Rule r1 = new Rule( db, "Test1", "IF Steel is not Cold and Stove is Hot then Pressure is Low" );
             Rule r2 = new Rule( db, "Test2", "IF Steel is Cold and not (Stove is Warm or Stove is Hot) then Pressure is Medium" );
             Rule r3 = new Rule( db, "Test3", "IF Steel is Cold and Stove is Warm or Stove is Hot then Pressure is High" );
             
             // testing the firing strength
             lvSteel.NumericInput = 12;
             lvStove.NumericInput = 35;
             float result = r1.EvaluateFiringStrength( );
             Console.WriteLine( result.ToString( ) );
             </code>    
             </remarks>
             
        </member>
        <member name="M:BestCS.Fuzzy.Rule.#ctor(BestCS.Fuzzy.Database,System.String,System.String,BestCS.Fuzzy.INorm,BestCS.Fuzzy.ICoNorm)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Fuzzy.Rule"/> class.
            </summary>
            
            <param name="fuzzyDatabase">A fuzzy <see cref="T:BestCS.Fuzzy.Database"/> containig the linguistic variables
            (see <see cref="T:BestCS.Fuzzy.LinguisticVariable"/>) that will be used in the Rule.</param>
            
            <param name="name">Name of this <see cref="T:BestCS.Fuzzy.Rule"/>.</param>
            
            <param name="rule">A string representing the <see cref="T:BestCS.Fuzzy.Rule"/>. It must be a "IF..THEN" statement.
            For a more detailed  description see <see cref="T:BestCS.Fuzzy.Rule"/> class.</param>
            
            <param name="normOperator">A class that implements a <see cref="T:BestCS.Fuzzy.INorm"/> interface to
            evaluate the AND operations of the Rule. </param>
            
            <param name="coNormOperator">A class that implements a <see cref="T:BestCS.Fuzzy.ICoNorm"/> interface
            to evaluate the OR operations of the Rule. </param>
            
        </member>
        <member name="M:BestCS.Fuzzy.Rule.#ctor(BestCS.Fuzzy.Database,System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Fuzzy.Rule"/> class using as
            CoNorm the <see cref="T:BestCS.Fuzzy.MaximumCoNorm"/> and as Norm the <see cref="T:BestCS.Fuzzy.MinimumNorm"/>.
            </summary>
            
            <param name="fuzzyDatabase">A fuzzy <see cref="T:BestCS.Fuzzy.Database"/> containig the linguistic variables
            (see <see cref="T:BestCS.Fuzzy.LinguisticVariable"/>) that will be used in the <see cref="T:BestCS.Fuzzy.Rule"/>.</param>
            
            <param name="name">Name of this <see cref="T:BestCS.Fuzzy.Rule"/>.</param>
            
            <param name="rule">A string representing the <see cref="T:BestCS.Fuzzy.Rule"/>. It must be a "IF..THEN"
            statement. For a more detailed description see <see cref="T:BestCS.Fuzzy.Rule"/> class.</param>
            
        </member>
        <member name="M:BestCS.Fuzzy.Rule.GetRPNExpression">
            <summary>
            Converts the RPN fuzzy expression into a string representation.
            </summary>
            
            <returns>String representation of the RPN fuzzy expression.</returns>
            
        </member>
        <member name="M:BestCS.Fuzzy.Rule.Priority(System.String)">
            <summary>
            Defines the priority of the fuzzy operators.
            </summary>
            
            <param name="Operator">A fuzzy operator or openning parenthesis.</param>
            
            <returns>A number indicating the priority of the operator, and zero for openning
            parenthesis.</returns>
            
        </member>
        <member name="M:BestCS.Fuzzy.Rule.ParseRule">
            <summary>
            Converts the Fuzzy Rule to RPN (Reverse Polish Notation). For debug proposes, the string representation of the 
            RPN expression can be acessed by calling <see cref="M:BestCS.Fuzzy.Rule.GetRPNExpression"/> method.
            </summary>
            
        </member>
        <member name="M:BestCS.Fuzzy.Rule.GetRuleTokens(System.String)">
            <summary>
            Performs a preprocessing on the rule, placing unary operators in proper position and breaking the string 
            space separated tokens.
            </summary>
            
            <param name="rule">Rule in string format.</param>
            
            <returns>An array of strings with tokens of the rule.</returns>
            
        </member>
        <member name="M:BestCS.Fuzzy.Rule.EvaluateFiringStrength">
            <summary>
            Evaluates the firing strength of the Rule, the degree of confidence that the consequent of this Rule
            must be executed.
            </summary>
            
            <returns>The firing strength [0..1] of the Rule.</returns>
            
        </member>
        <member name="P:BestCS.Fuzzy.Rule.Name">
            <summary>
            The name of the fuzzy rule.
            </summary>
            
        </member>
        <member name="P:BestCS.Fuzzy.Rule.Output">
            <summary>
            The fuzzy <see cref="T:BestCS.Fuzzy.Clause"/> that represents the consequent of the <see cref="T:BestCS.Fuzzy.Rule"/>.
            </summary>
            
        </member>
        <member name="T:BestCS.Fuzzy.Rulebase">
            <summary>
            The class represents a fuzzy rulebase, a set of fuzzy rules used in a Fuzzy Inference System.
            </summary>
            
        </member>
        <member name="M:BestCS.Fuzzy.Rulebase.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Fuzzy.Rulebase"/> class.
            </summary>
            
        </member>
        <member name="M:BestCS.Fuzzy.Rulebase.AddRule(BestCS.Fuzzy.Rule)">
            <summary>
            Adds a fuzzy rule to the database. 
            </summary>
            
            <param name="rule">A fuzzy <see cref="T:BestCS.Fuzzy.Rule"/> to add to the database.</param>
            
            <exception cref="T:System.NullReferenceException">The fuzzy rule was not initialized.</exception>
            <exception cref="T:System.ArgumentException">The fuzzy rule name already exists in the rulebase.</exception>
            
        </member>
        <member name="M:BestCS.Fuzzy.Rulebase.ClearRules">
            <summary>
            Removes all the fuzzy rules of the database. 
            </summary>
            
        </member>
        <member name="M:BestCS.Fuzzy.Rulebase.GetRule(System.String)">
            <summary>
            Returns an existing fuzzy rule from the rulebase.
            </summary>
            
            <param name="ruleName">Name of the fuzzy <see cref="T:BestCS.Fuzzy.Rule"/> to retrieve.</param>
            
            <returns>Reference to named <see cref="T:BestCS.Fuzzy.Rule"/>.</returns>
            
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The rule indicated in ruleName was not found in the rulebase.</exception>
            
        </member>
        <member name="M:BestCS.Fuzzy.Rulebase.GetRules">
            <summary>
            Gets all the rules of the rulebase.
            </summary>
            
            <returns>An array with all the rulebase rules.</returns>
            
        </member>
        <member name="T:BestCS.Genetic.BinaryChromosome">
            <summary>
            Binary chromosome, which supports length from 2 till 64.
            </summary>
            
            <remarks><para>The binary chromosome is the simplest type of chromosomes,
            which is represented by a set of bits. Maximum number of bits comprising
            the chromosome is 64.</para></remarks>
            
        </member>
        <member name="T:BestCS.Genetic.ChromosomeBase">
            <summary>
            Chromosomes' base class.
            </summary>
            
            <remarks><para>The base class provides implementation of some <see cref="T:BestCS.Genetic.IChromosome"/>
            methods and properties, which are identical to all types of chromosomes.</para></remarks>
            
        </member>
        <member name="T:BestCS.Genetic.IChromosome">
            <summary>
            Chromosome interface.
            </summary>
            
            <remarks><para>The interfase should be implemented by all classes, which implement
            particular chromosome type.</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.IChromosome.Generate">
            <summary>
            Generate random chromosome value.
            </summary>
            
            <remarks><para>Regenerates chromosome's value using random number generator.</para>
            </remarks>
            
        </member>
        <member name="M:BestCS.Genetic.IChromosome.CreateNew">
            <summary>
            Create new random chromosome with same parameters (factory method).
            </summary>
            
            <remarks><para>The method creates new chromosome of the same type, but randomly
            initialized. The method is useful as factory method for those classes, which work
            with chromosome's interface, but not with particular chromosome class.</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.IChromosome.Clone">
            <summary>
            Clone the chromosome.
            </summary>
            
            <remarks><para>The method clones the chromosome returning the exact copy of it.</para>
            </remarks>
            
        </member>
        <member name="M:BestCS.Genetic.IChromosome.Mutate">
            <summary>
            Mutation operator.
            </summary>
            
            <remarks><para>The method performs chromosome's mutation, changing its part randomly.</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.IChromosome.Crossover(BestCS.Genetic.IChromosome)">
            <summary>
            Crossover operator.
            </summary>
            
            <param name="pair">Pair chromosome to crossover with.</param>
            
            <remarks><para>The method performs crossover between two chromosomes  interchanging some parts of chromosomes.</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.IChromosome.Evaluate(BestCS.Genetic.IFitnessFunction)">
            <summary>
            Evaluate chromosome with specified fitness function.
            </summary>
            
            <param name="function">Fitness function to use for evaluation of the chromosome.</param>
            
            <remarks><para>Calculates chromosome's fitness using the specifed fitness function.</para></remarks>
            
        </member>
        <member name="P:BestCS.Genetic.IChromosome.Fitness">
            <summary>
            Chromosome's fintess value.
            </summary>
            
            <remarks><para>The fitness value represents chromosome's usefulness - the greater the
            value, the more useful it.</para></remarks>
            
        </member>
        <member name="F:BestCS.Genetic.ChromosomeBase.fitness">
            <summary>
            Chromosome's fintess value.
            </summary>
        </member>
        <member name="M:BestCS.Genetic.ChromosomeBase.Generate">
            <summary>
            Generate random chromosome value.
            </summary>
            
            <remarks><para>Regenerates chromosome's value using random number generator.</para>
            </remarks>
            
        </member>
        <member name="M:BestCS.Genetic.ChromosomeBase.CreateNew">
            <summary>
            Create new random chromosome with same parameters (factory method).
            </summary>
            
            <remarks><para>The method creates new chromosome of the same type, but randomly
            initialized. The method is useful as factory method for those classes, which work
            with chromosome's interface, but not with particular chromosome class.</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.ChromosomeBase.Clone">
            <summary>
            Clone the chromosome.
            </summary>
            
            <remarks><para>The method clones the chromosome returning the exact copy of it.</para>
            </remarks>
            
        </member>
        <member name="M:BestCS.Genetic.ChromosomeBase.Mutate">
            <summary>
            Mutation operator.
            </summary>
            
            <remarks><para>The method performs chromosome's mutation, changing its part randomly.</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.ChromosomeBase.Crossover(BestCS.Genetic.IChromosome)">
            <summary>
            Crossover operator.
            </summary>
            
            <param name="pair">Pair chromosome to crossover with.</param>
            
            <remarks><para>The method performs crossover between two chromosomes  interchanging some parts of chromosomes.</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.ChromosomeBase.Evaluate(BestCS.Genetic.IFitnessFunction)">
             <summary>
             Evaluate chromosome with specified fitness function.
             </summary>
             
             <param name="function">Fitness function to use for evaluation of the chromosome.</param>
             
             <remarks><para>Calculates chromosome's fitness using the specifed fitness function.</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.ChromosomeBase.CompareTo(System.Object)">
            <summary>
            Compare two chromosomes.
            </summary>
            
            <param name="o">Binary chromosome to compare to.</param>
            
            <returns>Returns comparison result, which equals to 0 if fitness values
            of both chromosomes are equal, 1 if fitness value of this chromosome
            is less than fitness value of the specified chromosome, -1 otherwise.</returns>
            
        </member>
        <member name="P:BestCS.Genetic.ChromosomeBase.Fitness">
            <summary>
            Chromosome's fintess value.
            </summary>
            
            <remarks><para>Fitness value (usefulness) of the chromosome calculate by calling
            <see cref="M:BestCS.Genetic.ChromosomeBase.Evaluate(BestCS.Genetic.IFitnessFunction)"/> method. The greater the value, the more useful the chromosome.
            </para></remarks>
            
        </member>
        <member name="F:BestCS.Genetic.BinaryChromosome.MaxLength">
            <summary>
            Chromosome's maximum length.
            </summary>
            
            <remarks><para>Maxim chromosome's length in bits, which is supported
            by the class</para></remarks>
            
        </member>
        <member name="F:BestCS.Genetic.BinaryChromosome.length">
            <summary>
            Chromosome's length in bits.
            </summary>
        </member>
        <member name="F:BestCS.Genetic.BinaryChromosome.val">
            <summary>
            Numerical chromosome's value.
            </summary>
        </member>
        <member name="F:BestCS.Genetic.BinaryChromosome.rand">
            <summary>
            Random number generator for chromosoms generation, crossover, mutation, etc.
            </summary>
        </member>
        <member name="M:BestCS.Genetic.BinaryChromosome.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Genetic.BinaryChromosome"/> class.
            </summary>
            
            <param name="length">Chromosome's length in bits, [2, <see cref="F:BestCS.Genetic.BinaryChromosome.MaxLength"/>].</param>
            
        </member>
        <member name="M:BestCS.Genetic.BinaryChromosome.#ctor(BestCS.Genetic.BinaryChromosome)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Genetic.BinaryChromosome"/> class.
            </summary>
            
            <param name="source">Source chromosome to copy.</param>
            
            <remarks><para>This is a copy constructor, which creates the exact copy
            of specified chromosome.</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.BinaryChromosome.ToString">
            <summary>
            Get string representation of the chromosome.
            </summary>
            
            <returns>Returns string representation of the chromosome.</returns>
            
        </member>
        <member name="M:BestCS.Genetic.BinaryChromosome.Generate">
            <summary>
            Generate random chromosome value.
            </summary>
            
            <remarks><para>Regenerates chromosome's value using random number generator.</para>
            </remarks>
            
        </member>
        <member name="M:BestCS.Genetic.BinaryChromosome.CreateNew">
            <summary>
            Create new random chromosome with same parameters (factory method).
            </summary>
            
            <remarks><para>The method creates new chromosome of the same type, but randomly
            initialized. The method is useful as factory method for those classes, which work
            with chromosome's interface, but not with particular chromosome type.</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.BinaryChromosome.Clone">
             <summary>
             Clone the chromosome.
             </summary>
             
             <returns>Return's clone of the chromosome.</returns>
             
             <remarks><para>The method clones the chromosome returning the exact copy of it.</para>
             </remarks>
            
        </member>
        <member name="M:BestCS.Genetic.BinaryChromosome.Mutate">
            <summary>
            Mutation operator.
            </summary>
            
            <remarks><para>The method performs chromosome's mutation, changing randomly
            one of its bits.</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.BinaryChromosome.Crossover(BestCS.Genetic.IChromosome)">
             <summary>
             Crossover operator.
             </summary>
             
             <param name="pair">Pair chromosome to crossover with.</param>
             
             <remarks><para>The method performs crossover between two chromosomes  interchanging
             range of bits between these chromosomes.</para></remarks>
            
        </member>
        <member name="P:BestCS.Genetic.BinaryChromosome.Length">
            <summary>
            Chromosome's length.
            </summary>
            
            <remarks><para>Length of the chromosome in bits.</para></remarks>
            
        </member>
        <member name="P:BestCS.Genetic.BinaryChromosome.Value">
            <summary>
            Chromosome's value.
            </summary>
            
            <remarks><para>Current numerical value of the chromosome.</para></remarks>
            
        </member>
        <member name="P:BestCS.Genetic.BinaryChromosome.MaxValue">
            <summary>
            Max possible chromosome's value.
            </summary>
            
            <remarks><para>Maximum possible numerical value, which may be represented
            by the chromosome of current length.</para></remarks>
            
        </member>
        <member name="T:BestCS.Genetic.DoubleArrayChromosome">
            <summary>
            Double array chromosome.
            </summary>
            
            <remarks><para>Double array chromosome represents array of double values.
            Array length is in the range of [2, 65536].
            </para>
            
            <para>See documentation to <see cref="M:BestCS.Genetic.DoubleArrayChromosome.Mutate"/> and <see cref="M:BestCS.Genetic.DoubleArrayChromosome.Crossover(BestCS.Genetic.IChromosome)"/> methods
            for information regarding implemented mutation and crossover operators.</para>
            </remarks>
            
        </member>
        <member name="F:BestCS.Genetic.DoubleArrayChromosome.MaxLength">
            <summary>
            Chromosome's maximum length.
            </summary>
            
            <remarks><para>Maxim chromosome's length in array elements.</para></remarks>
            
        </member>
        <member name="F:BestCS.Genetic.DoubleArrayChromosome.chromosomeGenerator">
            <summary>
            Chromosome generator.
            </summary>
            
            <remarks><para>This random number generator is used to initialize chromosome's genes,
            which is done by calling <see cref="M:BestCS.Genetic.DoubleArrayChromosome.Generate"/> method.</para></remarks>
            
        </member>
        <member name="F:BestCS.Genetic.DoubleArrayChromosome.mutationMultiplierGenerator">
            <summary>
            Mutation multiplier generator.
            </summary>
            
            <remarks><para>This random number generator is used to generate random multiplier values,
            which are used to multiply chromosome's genes during mutation.</para></remarks>
            
        </member>
        <member name="F:BestCS.Genetic.DoubleArrayChromosome.mutationAdditionGenerator">
            <summary>
            Mutation addition generator.
            </summary>
            
            <remarks><para>This random number generator is used to generate random addition values,
            which are used to add to chromosome's genes during mutation.</para></remarks>
            
        </member>
        <member name="F:BestCS.Genetic.DoubleArrayChromosome.rand">
            <summary>
            Random number generator for crossover and mutation points selection.
            </summary>
            
            <remarks><para>This random number generator is used to select crossover
            and mutation points.</para></remarks>
            
        </member>
        <member name="F:BestCS.Genetic.DoubleArrayChromosome.length">
            <summary>
            Chromosome's length in number of elements.
            </summary>
        </member>
        <member name="F:BestCS.Genetic.DoubleArrayChromosome.val">
            <summary>
            Chromosome's value.
            </summary>
        </member>
        <member name="M:BestCS.Genetic.DoubleArrayChromosome.#ctor(BestCS.Math.Random.IRandomNumberGenerator,BestCS.Math.Random.IRandomNumberGenerator,BestCS.Math.Random.IRandomNumberGenerator,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Genetic.DoubleArrayChromosome"/> class.
            </summary>
            
            <param name="chromosomeGenerator">Chromosome generator - random number generator, which is 
            used to initialize chromosome's genes, which is done by calling <see cref="M:BestCS.Genetic.DoubleArrayChromosome.Generate"/> method
            or in class constructor.</param>
            <param name="mutationMultiplierGenerator">Mutation multiplier generator - random number
            generator, which is used to generate random multiplier values, which are used to
            multiply chromosome's genes during mutation.</param>
            <param name="mutationAdditionGenerator">Mutation addition generator - random number
            generator, which is used to generate random addition values, which are used to
            add to chromosome's genes during mutation.</param>
            <param name="length">Chromosome's length in array elements, [2, <see cref="F:BestCS.Genetic.DoubleArrayChromosome.MaxLength"/>].</param>
            
            <remarks><para>The constructor initializes the new chromosome randomly by calling
            <see cref="M:BestCS.Genetic.DoubleArrayChromosome.Generate"/> method.</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.DoubleArrayChromosome.#ctor(BestCS.Math.Random.IRandomNumberGenerator,BestCS.Math.Random.IRandomNumberGenerator,BestCS.Math.Random.IRandomNumberGenerator,System.Double[])">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Genetic.DoubleArrayChromosome"/> class.
            </summary>
            
            <param name="chromosomeGenerator">Chromosome generator - random number generator, which is 
            used to initialize chromosome's genes, which is done by calling <see cref="M:BestCS.Genetic.DoubleArrayChromosome.Generate"/> method
            or in class constructor.</param>
            <param name="mutationMultiplierGenerator">Mutation multiplier generator - random number
            generator, which is used to generate random multiplier values, which are used to
            multiply chromosome's genes during mutation.</param>
            <param name="mutationAdditionGenerator">Mutation addition generator - random number
            generator, which is used to generate random addition values, which are used to
            add to chromosome's genes during mutation.</param>
            <param name="values">Values used to initialize the chromosome.</param>
            
            <remarks><para>The constructor initializes the new chromosome with specified <paramref name="values">values</paramref>.
            </para></remarks>
            
            <exception cref="T:System.ArgumentOutOfRangeException">Invalid length of values array.</exception>
            
        </member>
        <member name="M:BestCS.Genetic.DoubleArrayChromosome.#ctor(BestCS.Genetic.DoubleArrayChromosome)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Genetic.DoubleArrayChromosome"/> class.
            </summary>
            
            <param name="source">Source chromosome to copy.</param>
            
            <remarks><para>This is a copy constructor, which creates the exact copy
            of specified chromosome.</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.DoubleArrayChromosome.ToString">
            <summary>
            Get string representation of the chromosome.
            </summary>
            
            <returns>Returns string representation of the chromosome.</returns>
            
        </member>
        <member name="M:BestCS.Genetic.DoubleArrayChromosome.Generate">
             <summary>
             Generate random chromosome value.
             </summary>
             
             <remarks><para>Regenerates chromosome's value using random number generator.</para>
             </remarks>
            
        </member>
        <member name="M:BestCS.Genetic.DoubleArrayChromosome.CreateNew">
             <summary>
             Create new random chromosome with same parameters (factory method).
             </summary>
             
             <remarks><para>The method creates new chromosome of the same type, but randomly
             initialized. The method is useful as factory method for those classes, which work
             with chromosome's interface, but not with particular chromosome type.</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.DoubleArrayChromosome.Clone">
             <summary>
             Clone the chromosome.
             </summary>
             
             <returns>Return's clone of the chromosome.</returns>
             
             <remarks><para>The method clones the chromosome returning the exact copy of it.</para>
             </remarks>
            
        </member>
        <member name="M:BestCS.Genetic.DoubleArrayChromosome.Mutate">
            <summary>
            Mutation operator.
            </summary>
            
            <remarks><para>The method performs chromosome's mutation, adding random number
            to chromosome's gene or multiplying the gene by random number. These random
            numbers are generated with help of <see cref="F:BestCS.Genetic.DoubleArrayChromosome.mutationMultiplierGenerator">mutation
            multiplier</see> and <see cref="F:BestCS.Genetic.DoubleArrayChromosome.mutationAdditionGenerator">mutation
            addition</see> generators.</para>
            
            <para>The exact type of mutation applied to the particular gene
            is selected randomly each time and depends on <see cref="P:BestCS.Genetic.DoubleArrayChromosome.MutationBalancer"/>.
            Before mutation is done a random number is generated in [0, 1] range - if the
            random number is smaller than <see cref="P:BestCS.Genetic.DoubleArrayChromosome.MutationBalancer"/>, then multiplication
            mutation is done, otherwise addition mutation.
            </para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.DoubleArrayChromosome.Crossover(BestCS.Genetic.IChromosome)">
             <summary>
             Crossover operator.
             </summary>
             
             <param name="pair">Pair chromosome to crossover with.</param>
             
             <remarks><para>The method performs crossover between two chromosomes, selecting
             randomly the exact type of crossover to perform, which depends on <see cref="P:BestCS.Genetic.DoubleArrayChromosome.CrossoverBalancer"/>.
             Before crossover is done a random number is generated in [0, 1] range - if the
             random number is smaller than <see cref="P:BestCS.Genetic.DoubleArrayChromosome.CrossoverBalancer"/>, then the first crossover
             type is used, otherwise second type is used.</para>
             
             <para>The <b>first crossover type</b> is based on interchanging
             range of genes (array elements) between these chromosomes and is known
             as one point crossover. A crossover point is selected randomly and chromosomes
             interchange genes, which start from the selected point.</para>
             
             <para>The <b>second crossover type</b> is aimed to produce one child, which genes'
             values are between corresponding genes of parents, and another child, which genes'
             values are outside of the range formed by corresponding genes of parents. 
             Let take, for example, two genes with 1.0 and 3.0 value (of course chromosomes have
             more genes, but for simplicity lets think about one). First of all we randomly choose
             a factor in the [0, 1] range, let's take 0.4. Then, for each pair of genes (we have
             one pair) we calculate difference value, which is 2.0 in our case. In the result well
             have two children  one between and one outside of the range formed by parents genes' values.
             We may have 1.8 and 3.8 children, or we may have 0.2 and 2.2 children. As we can see
             we add/subtract (chosen randomly) <i>difference * factor</i>. So, this gives us exploration
             in between and in near outside. The randomly chosen factor is applied to all genes
             of the chromosomes participating in crossover.</para>
             </remarks>
            
        </member>
        <member name="P:BestCS.Genetic.DoubleArrayChromosome.Length">
             <summary>
             Chromosome's length.
             </summary>
             
             <remarks><para>Length of the chromosome in array elements.</para></remarks>
            
        </member>
        <member name="P:BestCS.Genetic.DoubleArrayChromosome.Value">
             <summary>
             Chromosome's value.
             </summary>
             
             <remarks><para>Current value of the chromosome.</para></remarks>
            
        </member>
        <member name="P:BestCS.Genetic.DoubleArrayChromosome.MutationBalancer">
            <summary>
            Mutation balancer to control mutation type, [0, 1].
            </summary>
            
            <remarks><para>The property controls type of mutation, which is used more
            frequently. A radnom number is generated each time before doing mutation -
            if the random number is smaller than the specified balance value, then one
            mutation type is used, otherwse another. See <see cref="M:BestCS.Genetic.DoubleArrayChromosome.Mutate"/> method
            for more information.</para>
            
            <para>Default value is set to <b>0.5</b>.</para>
            </remarks>
            
        </member>
        <member name="P:BestCS.Genetic.DoubleArrayChromosome.CrossoverBalancer">
            <summary>
            Crossover balancer to control crossover type, [0, 1].
            </summary>
            
            <remarks><para>The property controls type of crossover, which is used more
            frequently. A radnom number is generated each time before doing crossover -
            if the random number is smaller than the specified balance value, then one
            crossover type is used, otherwse another. See <see cref="M:BestCS.Genetic.DoubleArrayChromosome.Crossover(BestCS.Genetic.IChromosome)"/> method
            for more information.</para>
            
            <para>Default value is set to <b>0.5</b>.</para>
            </remarks>
            
        </member>
        <member name="T:BestCS.Genetic.ExtendedGeneFunction">
             <summary>
             Genetic programming gene, which represents arithmetic functions, common mathematical functions
             and arguments.
             </summary>
            
             <remarks><para>Extended gene function may represent arithmetic functions (+, -, *, /),
             some common mathematical functions (sin, cos, ln, exp, sqrt) or an argument to functions.
             This class is used by Genetic Programming (or Gene Expression Programming)
             chromosomes to build arbitrary expressions with help of genetic operators.</para>
             </remarks>
            
        </member>
        <member name="T:BestCS.Genetic.IGPGene">
            <summary>
            Genetic Programming's gene interface.
            </summary>
            
            <remarks><para>This is a gene interface, which is used for building chromosomes
            in Genetic Programming (GP) and Gene Expression Programming (GEP).
            </para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.IGPGene.Clone">
            <summary>
            Clone gene.
            </summary>
            
            <remarks><para>The method clones gene returning the exact copy of it.</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.IGPGene.Generate">
            <summary>
            Randomize gene with random type and value.
            </summary>
            
            <remarks><para>The method randomizes a gene, setting its type and value randomly.</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.IGPGene.Generate(BestCS.Genetic.GPGeneType)">
            <summary>
            Randomize gene with random value.
            </summary>
            
            <param name="type">Gene type to set.</param>
            
            <remarks><para>The method randomizes a gene, setting its value randomly, but type
            is set to the specified one.</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.IGPGene.CreateNew">
            <summary>
            Creates new gene with random type and value.
            </summary>
            
            <remarks><para>The method creates new randomly initialized gene .
            The method is useful as factory method for those classes, which work with gene's interface,
            but not with particular gene class.</para>
            </remarks>
            
        </member>
        <member name="M:BestCS.Genetic.IGPGene.CreateNew(BestCS.Genetic.GPGeneType)">
            <summary>
            Creates new gene with certain type and random value.
            </summary>
            
            <param name="type">Gene type to create.</param>
            
            <remarks><para>The method creates new gene with specified type, but random value.
            The method is useful as factory method for those classes, which work with gene's interface,
            but not with particular gene class.</para>
            </remarks>
            
        </member>
        <member name="P:BestCS.Genetic.IGPGene.GeneType">
            <summary>
            Gene type.
            </summary>
            
            <remarks><para>The property represents type of a gene - function, argument, etc.</para>
            </remarks>
            
        </member>
        <member name="P:BestCS.Genetic.IGPGene.ArgumentsCount">
            <summary>
            Arguments count.
            </summary>
            
            <remarks><para>Arguments count of a particular function gene.</para></remarks>
            
        </member>
        <member name="P:BestCS.Genetic.IGPGene.MaxArgumentsCount">
            <summary>
            Maximum arguments count.
            </summary>
            
            <remarks><para>Maximum arguments count of a function gene. The property may be used
            by chromosomes' classes to allocate correctly memory for functions' arguments,
            for example.</para></remarks>
            
        </member>
        <member name="F:BestCS.Genetic.ExtendedGeneFunction.FunctionsCount">
            <summary>
            Number of different functions supported by the class.
            </summary>
        </member>
        <member name="F:BestCS.Genetic.ExtendedGeneFunction.rand">
            <summary>
            Random number generator for chromosoms generation.
            </summary>
        </member>
        <member name="M:BestCS.Genetic.ExtendedGeneFunction.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Genetic.ExtendedGeneFunction"/> class.
            </summary>
            
            <param name="variablesCount">Total amount of variables in the task which is supposed
            to be solved.</param>
            
            <remarks><para>The constructor creates randomly initialized gene with random type
            and value by calling <see cref="M:BestCS.Genetic.ExtendedGeneFunction.Generate"/> method.</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.ExtendedGeneFunction.#ctor(System.Int32,BestCS.Genetic.GPGeneType)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Genetic.ExtendedGeneFunction"/> class.
            </summary>
            
            <param name="variablesCount">Total amount of variables in the task which is supposed
            to be solved.</param>
            <param name="type">Gene type to set.</param>
            
            <remarks><para>The constructor creates randomly initialized gene with random
            value and preset gene type.</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.ExtendedGeneFunction.ToString">
             <summary>
             Get string representation of the gene.
             </summary>
             
             <returns>Returns string representation of the gene.</returns>
            
        </member>
        <member name="M:BestCS.Genetic.ExtendedGeneFunction.Clone">
            <summary>
            Clone the gene.
            </summary>
            
            <remarks><para>The method clones the chromosome returning the exact copy of it.</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.ExtendedGeneFunction.Generate">
            <summary>
            Randomize gene with random type and value.
            </summary>
            
            <remarks><para>The method randomizes the gene, setting its type and value randomly.</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.ExtendedGeneFunction.Generate(BestCS.Genetic.GPGeneType)">
             <summary>
             Randomize gene with random value.
             </summary>
             
             <param name="type">Gene type to set.</param>
             
             <remarks><para>The method randomizes a gene, setting its value randomly, but type
             is set to the specified one.</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.ExtendedGeneFunction.CreateNew">
             <summary>
             Creates new gene with random type and value.
             </summary>
             
             <remarks><para>The method creates new randomly initialized gene .
             The method is useful as factory method for those classes, which work with gene's interface,
             but not with particular gene class.</para>
             </remarks>
            
        </member>
        <member name="M:BestCS.Genetic.ExtendedGeneFunction.CreateNew(BestCS.Genetic.GPGeneType)">
             <summary>
             Creates new gene with certain type and random value.
             </summary>
             
             <param name="type">Gene type to create.</param>
             
             <remarks><para>The method creates new gene with specified type, but random value.
             The method is useful as factory method for those classes, which work with gene's interface,
             but not with particular gene class.</para>
             </remarks>
            
        </member>
        <member name="P:BestCS.Genetic.ExtendedGeneFunction.GeneType">
            <summary>
            Gene type.
            </summary>
            
            <remarks><para>The property represents type of a gene - function, argument, etc.</para>
            </remarks>
            
        </member>
        <member name="P:BestCS.Genetic.ExtendedGeneFunction.ArgumentsCount">
            <summary>
            Arguments count.
            </summary>
            
            <remarks><para>Arguments count of a particular function gene.</para></remarks>
            
        </member>
        <member name="P:BestCS.Genetic.ExtendedGeneFunction.MaxArgumentsCount">
            <summary>
            Maximum arguments count.
            </summary>
            
            <remarks><para>Maximum arguments count of a function gene supported by the class.
            The property may be used by chromosomes' classes to allocate correctly memory for
            functions' arguments, for example.</para></remarks>
            
        </member>
        <member name="T:BestCS.Genetic.ExtendedGeneFunction.Functions">
            <summary>
            Enumeration of supported functions.
            </summary>
        </member>
        <member name="F:BestCS.Genetic.ExtendedGeneFunction.Functions.Add">
            <summary>
            Addition operator.
            </summary>
        </member>
        <member name="F:BestCS.Genetic.ExtendedGeneFunction.Functions.Subtract">
            <summary>
            Suntraction operator.
            </summary>
        </member>
        <member name="F:BestCS.Genetic.ExtendedGeneFunction.Functions.Multiply">
            <summary>
            Multiplication operator.
            </summary>
        </member>
        <member name="F:BestCS.Genetic.ExtendedGeneFunction.Functions.Divide">
            <summary>
            Division operator.
            </summary>
        </member>
        <member name="F:BestCS.Genetic.ExtendedGeneFunction.Functions.Sin">
            <summary>
            Sine function.
            </summary>
        </member>
        <member name="F:BestCS.Genetic.ExtendedGeneFunction.Functions.Cos">
            <summary>
            Cosine function.
            </summary>
        </member>
        <member name="F:BestCS.Genetic.ExtendedGeneFunction.Functions.Ln">
            <summary>
            Natural logarithm function.
            </summary>
        </member>
        <member name="F:BestCS.Genetic.ExtendedGeneFunction.Functions.Exp">
            <summary>
            Exponent function.
            </summary>
        </member>
        <member name="F:BestCS.Genetic.ExtendedGeneFunction.Functions.Sqrt">
            <summary>
            Square root function.
            </summary>
        </member>
        <member name="T:BestCS.Genetic.GEPChromosome">
            <summary>
            The chromosome represents a Gene Expression, which is used for
            different tasks of Genetic Expression Programming (GEP).
            </summary>
            
            <remarks><para>This type of chromosome represents combination of ideas taken from
            Genetic Algorithms (GA), where chromosomes are linear structures of fixed length, and
            Genetic Programming (GP), where chromosomes are expression trees. The GEP chromosome
            is also a fixed length linear structure, but with some additional features which
            make it possible to generate valid expression tree from any GEP chromosome.</para>
            
            <para>The theory of Gene Expression Programming is well described in the next paper:
            <b>Ferreira, C., 2001. Gene Expression Programming: A New Adaptive Algorithm for Solving
            Problems. Complex Systems, Vol. 13, issue 2: 87-129</b>. A copy of the paper may be
            obtained on the
            <a href="http://www.gene-expression-programming.com/">gene expression programming</a> web site.</para>
            </remarks>
            
        </member>
        <member name="F:BestCS.Genetic.GEPChromosome.headLength">
            <summary>
            Length of GEP chromosome's head.
            </summary>
            
            <remarks><para>GEP chromosome's head is a part of chromosome, which may contain both
            functions' and arguments' nodes. The rest of chromosome (tail) may contain only arguments' nodes.
            </para></remarks>
            
        </member>
        <member name="F:BestCS.Genetic.GEPChromosome.length">
            <summary>
            GEP chromosome's length.
            </summary>
            
            <remarks><para><note>The variable keeps chromosome's length, but not expression length represented by the
            chromosome.</note></para></remarks>
            
        </member>
        <member name="F:BestCS.Genetic.GEPChromosome.genes">
            <summary>
            Array of chromosome's genes.
            </summary>
        </member>
        <member name="F:BestCS.Genetic.GEPChromosome.rand">
            <summary>
            Random generator used for chromosoms' generation.
            </summary>
        </member>
        <member name="M:BestCS.Genetic.GEPChromosome.#ctor(BestCS.Genetic.IGPGene,System.Int32)">
             <summary>
             Initializes a new instance of the <see cref="T:BestCS.Genetic.GEPChromosome"/> class.
             </summary>
             
             <param name="ancestor">A gene, which is used as generator for the genetic tree.</param>
             <param name="headLength">Length of GEP chromosome's head (see <see cref="F:BestCS.Genetic.GEPChromosome.headLength"/>).</param>
             
             <remarks><para>This constructor creates a randomly generated GEP chromosome,
             which has all genes of the same type and properties as the specified <paramref name="ancestor"/>.
             </para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.GEPChromosome.#ctor(BestCS.Genetic.GEPChromosome)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Genetic.GEPChromosome"/> class.
            </summary>
            
            <param name="source">Source GEP chromosome to clone from.</param>
            
        </member>
        <member name="M:BestCS.Genetic.GEPChromosome.ToString">
            <summary>
            Get string representation of the chromosome by providing its expression in
            reverse polish notation (postfix notation).
            </summary>
            
            <returns>Returns string representation of the expression represented by the GEP
            chromosome.</returns>
            
        </member>
        <member name="M:BestCS.Genetic.GEPChromosome.ToStringNative">
            <summary>
            Get string representation of the chromosome. 
            </summary>
            
            <returns>Returns the chromosome in native linear representation.</returns>
            
            <remarks><para><note>The method is used for debugging mostly.</note></para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.GEPChromosome.Generate">
             <summary>
             Generate random chromosome value.
             </summary>
             
             <remarks><para>Regenerates chromosome's value using random number generator.</para>
             </remarks>
            
        </member>
        <member name="M:BestCS.Genetic.GEPChromosome.GetTree">
            <summary>
            Get tree representation of the chromosome.
            </summary>
            
            <returns>Returns expression's tree represented by the chromosome.</returns>
            
            <remarks><para>The method builds expression's tree for the native linear representation
            of the GEP chromosome.</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.GEPChromosome.CreateNew">
            <summary>
            Create new random chromosome with same parameters (factory method).
            </summary>
            
            <remarks><para>The method creates new chromosome of the same type, but randomly
            initialized. The method is useful as factory method for those classes, which work
            with chromosome's interface, but not with particular chromosome type.</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.GEPChromosome.Clone">
             <summary>
             Clone the chromosome.
             </summary>
             
             <returns>Return's clone of the chromosome.</returns>
             
             <remarks><para>The method clones the chromosome returning the exact copy of it.</para>
             </remarks>
            
        </member>
        <member name="M:BestCS.Genetic.GEPChromosome.Mutate">
            <summary>
            Mutation operator.
            </summary>
            
            <remarks><para>The method performs chromosome's mutation by calling on of the methods
            randomly: <see cref="M:BestCS.Genetic.GEPChromosome.MutateGene"/>, <see cref="M:BestCS.Genetic.GEPChromosome.TransposeIS"/>, <see cref="M:BestCS.Genetic.GEPChromosome.TransposeRoot"/>.
            </para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.GEPChromosome.MutateGene">
            <summary>
            Usual gene mutation.
            </summary>
            
            <remarks><para>The method performs usual gene mutation by randomly changing randomly selected
            gene.</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.GEPChromosome.TransposeIS">
            <summary>
            Transposition of IS elements (insertion sequence).
            </summary>
            
            <remarks><para>The method performs transposition of IS elements by copying randomly selected region
            of genes into chromosome's head (into randomly selected position). First gene of the chromosome's head 
            is not affected - can not be selected as target point.</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.GEPChromosome.TransposeRoot">
             <summary>
             Root transposition.
             </summary>
            
             <remarks><para>The method performs root transposition of the GEP chromosome - inserting
             new root of the chromosome and shifting existing one. The method first of all randomly selects
             a function gene in chromosome's head - starting point of the sequence to put into chromosome's
             head. Then it randomly selects the length of the sequence making sure that the entire sequence is
             located within head. Once the starting point and the length of the sequence are known, it is copied
             into chromosome's head shifting existing elements in the head.</para>
             </remarks>
            
        </member>
        <member name="M:BestCS.Genetic.GEPChromosome.Crossover(BestCS.Genetic.IChromosome)">
            <summary>
            Crossover operator.
            </summary>
            
            <param name="pair">Pair chromosome to crossover with.</param>
            
            <remarks><para>The method performs one-point or two-point crossover selecting
            them randomly with equal probability.</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.GEPChromosome.RecombinationOnePoint(BestCS.Genetic.GEPChromosome)">
            <summary>
            One-point recombination (crossover).
            </summary>
            
            <param name="pair">Pair chromosome to crossover with.</param>
            
        </member>
        <member name="M:BestCS.Genetic.GEPChromosome.RecombinationTwoPoint(BestCS.Genetic.GEPChromosome)">
            <summary>
            Two point recombination (crossover).
            </summary>
            
            <param name="pair">Pair chromosome to crossover with.</param>
            
        </member>
        <member name="M:BestCS.Genetic.GEPChromosome.Recombine(BestCS.Genetic.IGPGene[],BestCS.Genetic.IGPGene[],System.Int32,System.Int32)">
             <summary>
             Swap parts of two chromosomes.
             </summary>
             
             <param name="src1">First chromosome participating in genes' interchange.</param>
             <param name="src2">Second chromosome participating in genes' interchange.</param>
             <param name="point">Index of the first gene in the interchange sequence.</param>
             <param name="length">Length of the interchange sequence - number of genes
             to interchange.</param>
            
             <remarks><para>The method performs interchanging of genes between two chromosomes
             starting from the <paramref name="point"/> position.</para></remarks>
            
        </member>
        <member name="T:BestCS.Genetic.GPTreeChromosome">
            <summary>
            Tree chromosome represents a tree of genes, which is is used for
            different tasks of Genetic Programming (GP).
            </summary>
            
            <remarks><para>This type of chromosome represents a tree, where each node
            is represented by <see cref="T:BestCS.Genetic.GPTreeNode"/> containing <see cref="T:BestCS.Genetic.IGPGene"/>.
            Depending on type of genes used to build the tree, it may represent different
            types of expressions aimed to solve different type of tasks. For example, a
            particular implementation of <see cref="T:BestCS.Genetic.IGPGene"/> interface may represent
            simple algebraic operations and their arguments.
            </para>
            
            <para>See documentation to <see cref="T:BestCS.Genetic.IGPGene"/> implementations for additional
            information about possible Genetic Programming trees.</para>
            </remarks>
            
        </member>
        <member name="F:BestCS.Genetic.GPTreeChromosome.rand">
            <summary>
            Random generator used for chromosoms' generation.
            </summary>
        </member>
        <member name="M:BestCS.Genetic.GPTreeChromosome.#ctor(BestCS.Genetic.IGPGene)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Genetic.GPTreeChromosome"/> class.
            </summary>
            
            <param name="ancestor">A gene, which is used as generator for the genetic tree.</param>
            
            <remarks><para>This constructor creates a randomly generated genetic tree,
            which has all genes of the same type and properties as the specified <paramref name="ancestor"/>.
            </para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.GPTreeChromosome.#ctor(BestCS.Genetic.GPTreeChromosome)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Genetic.GPTreeChromosome"/> class.
            </summary>
            
            <param name="source">Source genetic tree to clone from.</param>
            
            <remarks><para>This constructor creates new genetic tree as a copy of the
            specified <paramref name="source"/> tree.</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.GPTreeChromosome.ToString">
             <summary>
             Get string representation of the chromosome by providing its expression in
             reverse polish notation (postfix notation).
             </summary>
             
             <returns>Returns string representation of the genetic tree.</returns>
             
             <remarks><para>The method returns string representation of the tree's root node
             (see <see cref="M:BestCS.Genetic.GPTreeNode.ToString"/>).</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.GPTreeChromosome.Generate">
             <summary>
             Generate random chromosome value.
             </summary>
             
             <remarks><para>Regenerates chromosome's value using random number generator.</para>
             </remarks>
            
        </member>
        <member name="M:BestCS.Genetic.GPTreeChromosome.Generate(BestCS.Genetic.GPTreeNode,System.Int32)">
            <summary>
            Generate chromosome's subtree of specified level.
            </summary>
            
            <param name="node">Sub tree's node to generate.</param>
            <param name="level">Sub tree's level to generate.</param>
            
        </member>
        <member name="M:BestCS.Genetic.GPTreeChromosome.CreateNew">
            <summary>
            Create new random chromosome with same parameters (factory method).
            </summary>
            
            <remarks><para>The method creates new chromosome of the same type, but randomly
            initialized. The method is useful as factory method for those classes, which work
            with chromosome's interface, but not with particular chromosome type.</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.GPTreeChromosome.Clone">
             <summary>
             Clone the chromosome.
             </summary>
             
             <returns>Return's clone of the chromosome.</returns>
             
             <remarks><para>The method clones the chromosome returning the exact copy of it.</para>
             </remarks>
            
        </member>
        <member name="M:BestCS.Genetic.GPTreeChromosome.Mutate">
             <summary>
             Mutation operator.
             </summary>
             
             <remarks><para>The method performs chromosome's mutation by regenerating tree's
             randomly selected node.</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.GPTreeChromosome.Crossover(BestCS.Genetic.IChromosome)">
             <summary>
             Crossover operator.
             </summary>
             
             <param name="pair">Pair chromosome to crossover with.</param>
             
             <remarks><para>The method performs crossover between two chromosomes  interchanging
             randomly selected sub trees.</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.GPTreeChromosome.RandomSwap(BestCS.Genetic.GPTreeNode)">
            <summary>
            Crossover helper routine - selects random node of chromosomes tree and
            swaps it with specified node.
            </summary>
        </member>
        <member name="M:BestCS.Genetic.GPTreeChromosome.Trim(BestCS.Genetic.GPTreeNode,System.Int32)">
            <summary>
            Trim tree node, so its depth does not exceed specified level.
            </summary>
        </member>
        <member name="P:BestCS.Genetic.GPTreeChromosome.MaxInitialLevel">
             <summary>
             Maximum initial level of genetic trees, [1, 25].
             </summary>
             
             <remarks><para>The property sets maximum possible initial depth of new
             genetic programming tree. For example, if it is set to 1, then largest initial
             tree may have a root and one level of children.</para>
             
             <para>Default value is set to <b>3</b>.</para>
             </remarks>
            
        </member>
        <member name="P:BestCS.Genetic.GPTreeChromosome.MaxLevel">
             <summary>
             Maximum level of genetic trees, [1, 50].
             </summary>
             
             <remarks><para>The property sets maximum possible depth of 
             genetic programming tree, which may be created with mutation and crossover operators.
             This property guarantees that genetic programmin tree will never have
             higher depth, than the specified value.</para>
             
             <para>Default value is set to <b>5</b>.</para>
             </remarks>
            
        </member>
        <member name="T:BestCS.Genetic.GPTreeNode">
            <summary>
            Represents tree node of genetic programming tree.
            </summary>
            
            <remarks><para>In genetic programming a chromosome is represented by a tree, which
            is represented by <see cref="T:BestCS.Genetic.GPTreeChromosome"/> class. The <see cref="T:BestCS.Genetic.GPTreeNode"/>
            class represents single node of such genetic programming tree.</para>
            
            <para>Each node may or may not have children. This means that particular node of a genetic
            programming tree may represent its sub tree or even entire tree.</para>
            </remarks>
            
        </member>
        <member name="F:BestCS.Genetic.GPTreeNode.Gene">
            <summary>
            Gene represented by the chromosome.
            </summary>
        </member>
        <member name="F:BestCS.Genetic.GPTreeNode.Children">
            <summary>
            List of node's children.
            </summary>
        </member>
        <member name="M:BestCS.Genetic.GPTreeNode.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Genetic.GPTreeNode"/> class.
            </summary>
            
        </member>
        <member name="M:BestCS.Genetic.GPTreeNode.#ctor(BestCS.Genetic.IGPGene)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Genetic.GPTreeNode"/> class.
            </summary>
            
        </member>
        <member name="M:BestCS.Genetic.GPTreeNode.ToString">
            <summary>
            Get string representation of the node.
            </summary>
            
            <returns>Returns string representation of the node.</returns>
            
            <remarks><para>String representation of the node lists all node's children and
            then the node itself. Such node's string representations equals to
            its reverse polish notation.</para>
            
            <para>For example, if nodes value is '+' and its children are '3' and '5', then
            nodes string representation is "3 5 +".</para>
            </remarks>
            
        </member>
        <member name="M:BestCS.Genetic.GPTreeNode.Clone">
            <summary>
            Clone the tree node.
            </summary>
            
            <returns>Returns exact clone of the node.</returns>
            
        </member>
        <member name="T:BestCS.Genetic.GPGeneType">
            <summary>
            Types of genes in Genetic Programming.
            </summary>
        </member>
        <member name="F:BestCS.Genetic.GPGeneType.Function">
            <summary>
            Function gene - represents function to be executed.
            </summary>
        </member>
        <member name="F:BestCS.Genetic.GPGeneType.Argument">
            <summary>
            Argument gene - represents argument of function.
            </summary>
        </member>
        <member name="T:BestCS.Genetic.SimpleGeneFunction">
             <summary>
             Genetic programming gene, which represents simple arithmetic functions and arguments.
             </summary>
            
             <remarks><para>Simple gene function may represent an arithmetic function (+, -, *, /) or
             an argument to function. This class is used by Genetic Programming (or Gene Expression Programming)
             chromosomes to build arbitrary expressions with help of genetic operators.</para>
             </remarks>
            
        </member>
        <member name="F:BestCS.Genetic.SimpleGeneFunction.FunctionsCount">
            <summary>
            Number of different functions supported by the class.
            </summary>
        </member>
        <member name="F:BestCS.Genetic.SimpleGeneFunction.rand">
            <summary>
            Random number generator for chromosoms generation.
            </summary>
        </member>
        <member name="M:BestCS.Genetic.SimpleGeneFunction.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Genetic.SimpleGeneFunction"/> class.
            </summary>
            
            <param name="variablesCount">Total amount of variables in the task which is supposed
            to be solved.</param>
            
            <remarks><para>The constructor creates randomly initialized gene with random type
            and value by calling <see cref="M:BestCS.Genetic.SimpleGeneFunction.Generate"/> method.</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.SimpleGeneFunction.#ctor(System.Int32,BestCS.Genetic.GPGeneType)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Genetic.SimpleGeneFunction"/> class.
            </summary>
            
            <param name="variablesCount">Total amount of variables in the task which is supposed
            to be solved.</param>
            <param name="type">Gene type to set.</param>
            
            <remarks><para>The constructor creates randomly initialized gene with random
            value and preset gene type.</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.SimpleGeneFunction.ToString">
            <summary>
            Get string representation of the gene.
            </summary>
            
            <returns>Returns string representation of the gene.</returns>
            
        </member>
        <member name="M:BestCS.Genetic.SimpleGeneFunction.Clone">
            <summary>
            Clone the gene.
            </summary>
            
            <remarks><para>The method clones the chromosome returning the exact copy of it.</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.SimpleGeneFunction.Generate">
            <summary>
            Randomize gene with random type and value.
            </summary>
            
            <remarks><para>The method randomizes the gene, setting its type and value randomly.</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.SimpleGeneFunction.Generate(BestCS.Genetic.GPGeneType)">
             <summary>
             Randomize gene with random value.
             </summary>
             
             <param name="type">Gene type to set.</param>
             
             <remarks><para>The method randomizes a gene, setting its value randomly, but type
             is set to the specified one.</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.SimpleGeneFunction.CreateNew">
            <summary>
            Creates new gene with random type and value.
            </summary>
            
            <remarks><para>The method creates new randomly initialized gene .
            The method is useful as factory method for those classes, which work with gene's interface,
            but not with particular gene class.</para>
            </remarks>
            
        </member>
        <member name="M:BestCS.Genetic.SimpleGeneFunction.CreateNew(BestCS.Genetic.GPGeneType)">
            <summary>
            Creates new gene with certain type and random value.
            </summary>
            
            <param name="type">Gene type to create.</param>
            
            <remarks><para>The method creates new gene with specified type, but random value.
            The method is useful as factory method for those classes, which work with gene's interface,
            but not with particular gene class.</para>
            </remarks>
            
        </member>
        <member name="P:BestCS.Genetic.SimpleGeneFunction.GeneType">
            <summary>
            Gene type.
            </summary>
            
            <remarks><para>The property represents type of a gene - function, argument, etc.</para>
            </remarks>
            
        </member>
        <member name="P:BestCS.Genetic.SimpleGeneFunction.ArgumentsCount">
            <summary>
            Arguments count.
            </summary>
            
            <remarks><para>Arguments count of a particular function gene.</para></remarks>
            
        </member>
        <member name="P:BestCS.Genetic.SimpleGeneFunction.MaxArgumentsCount">
            <summary>
            Maximum arguments count.
            </summary>
            
            <remarks><para>Maximum arguments count of a function gene supported by the class.
            The property may be used by chromosomes' classes to allocate correctly memory for
            functions' arguments, for example.</para></remarks>
            
        </member>
        <member name="T:BestCS.Genetic.SimpleGeneFunction.Functions">
            <summary>
            Enumeration of supported functions.
            </summary>
        </member>
        <member name="F:BestCS.Genetic.SimpleGeneFunction.Functions.Add">
            <summary>
            Addition operator.
            </summary>
        </member>
        <member name="F:BestCS.Genetic.SimpleGeneFunction.Functions.Subtract">
            <summary>
            Suntraction operator.
            </summary>
        </member>
        <member name="F:BestCS.Genetic.SimpleGeneFunction.Functions.Multiply">
            <summary>
            Multiplication operator.
            </summary>
        </member>
        <member name="F:BestCS.Genetic.SimpleGeneFunction.Functions.Divide">
            <summary>
            Division operator.
            </summary>
        </member>
        <member name="T:BestCS.Genetic.PermutationChromosome">
            <summary>
            Permutation chromosome.
            </summary>
            
            <remarks><para>Permutation chromosome is based on short array chromosome,
            but has two features:</para>
            <list type="bullet">
            <item>all genes are unique within chromosome, i.e. there are no two genes
            with the same value;</item>
            <item>maximum value of each gene is equal to chromosome length minus 1.</item>
            </list>
            </remarks>
            
        </member>
        <member name="T:BestCS.Genetic.ShortArrayChromosome">
            <summary>
            Short array chromosome.
            </summary>
            
            <remarks><para>Short array chromosome represents array of unsigned short values.
            Array length is in the range of [2, 65536].
            </para></remarks>
        </member>
        <member name="F:BestCS.Genetic.ShortArrayChromosome.MaxLength">
            <summary>
            Chromosome's maximum length.
            </summary>
            
            <remarks><para>Maxim chromosome's length in array elements.</para></remarks>
            
        </member>
        <member name="F:BestCS.Genetic.ShortArrayChromosome.length">
            <summary>
            Chromosome's length in number of elements.
            </summary>
        </member>
        <member name="F:BestCS.Genetic.ShortArrayChromosome.maxValue">
            <summary>
            Maximum value of chromosome's gene (element).
            </summary>
        </member>
        <member name="F:BestCS.Genetic.ShortArrayChromosome.val">
            <summary>
            Chromosome's value.
            </summary>
        </member>
        <member name="F:BestCS.Genetic.ShortArrayChromosome.rand">
            <summary>
            Random number generator for chromosoms generation, crossover, mutation, etc.
            </summary>
        </member>
        <member name="M:BestCS.Genetic.ShortArrayChromosome.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Genetic.ShortArrayChromosome"/> class.
            </summary>
            
            <param name="length">Chromosome's length in array elements, [2, <see cref="F:BestCS.Genetic.ShortArrayChromosome.MaxLength"/>].</param>
            
            <remarks>This constructor initializes chromosome setting genes' maximum value to
            maximum posible value of <see langword="ushort"/> type.</remarks>
            
        </member>
        <member name="M:BestCS.Genetic.ShortArrayChromosome.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Genetic.ShortArrayChromosome"/> class.
            </summary>
            
            <param name="length">Chromosome's length in array elements, [2, <see cref="F:BestCS.Genetic.ShortArrayChromosome.MaxLength"/>].</param>
            <param name="maxValue">Maximum value of chromosome's gene (array element).</param>
            
        </member>
        <member name="M:BestCS.Genetic.ShortArrayChromosome.#ctor(BestCS.Genetic.ShortArrayChromosome)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Genetic.ShortArrayChromosome"/> class.
            </summary>
            
            <param name="source">Source chromosome to copy.</param>
            
            <remarks><para>This is a copy constructor, which creates the exact copy
            of specified chromosome.</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.ShortArrayChromosome.ToString">
             <summary>
             Get string representation of the chromosome.
             </summary>
             
             <returns>Returns string representation of the chromosome.</returns>
            
        </member>
        <member name="M:BestCS.Genetic.ShortArrayChromosome.Generate">
            <summary>
            Generate random chromosome value.
            </summary>
            
            <remarks><para>Regenerates chromosome's value using random number generator.</para>
            </remarks>
            
        </member>
        <member name="M:BestCS.Genetic.ShortArrayChromosome.CreateNew">
             <summary>
             Create new random chromosome with same parameters (factory method).
             </summary>
             
             <remarks><para>The method creates new chromosome of the same type, but randomly
             initialized. The method is useful as factory method for those classes, which work
             with chromosome's interface, but not with particular chromosome type.</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.ShortArrayChromosome.Clone">
             <summary>
             Clone the chromosome.
             </summary>
             
             <returns>Return's clone of the chromosome.</returns>
             
             <remarks><para>The method clones the chromosome returning the exact copy of it.</para>
             </remarks>
            
        </member>
        <member name="M:BestCS.Genetic.ShortArrayChromosome.Mutate">
            <summary>
            Mutation operator.
            </summary>
            
            <remarks><para>The method performs chromosome's mutation, changing randomly
            one of its genes (array elements).</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.ShortArrayChromosome.Crossover(BestCS.Genetic.IChromosome)">
             <summary>
             Crossover operator.
             </summary>
             
             <param name="pair">Pair chromosome to crossover with.</param>
             
             <remarks><para>The method performs crossover between two chromosomes  interchanging
             range of genes (array elements) between these chromosomes.</para></remarks>
            
        </member>
        <member name="P:BestCS.Genetic.ShortArrayChromosome.Length">
             <summary>
             Chromosome's length.
             </summary>
             
             <remarks><para>Length of the chromosome in array elements.</para></remarks>
            
        </member>
        <member name="P:BestCS.Genetic.ShortArrayChromosome.Value">
             <summary>
             Chromosome's value.
             </summary>
             
             <remarks><para>Current value of the chromosome.</para></remarks>
            
        </member>
        <member name="P:BestCS.Genetic.ShortArrayChromosome.MaxValue">
            <summary>
            Max possible value of single chromosomes element - gene.
            </summary>
            
            <remarks><para>Maximum possible numerical value, which may be represented
            by single chromosome's gene (array element).</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.PermutationChromosome.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Genetic.PermutationChromosome"/> class.
            </summary>
        </member>
        <member name="M:BestCS.Genetic.PermutationChromosome.#ctor(BestCS.Genetic.PermutationChromosome)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Genetic.PermutationChromosome"/> class.
            </summary>
            
            <param name="source">Source chromosome to copy.</param>
            
            <remarks><para>This is a copy constructor, which creates the exact copy
            of specified chromosome.</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.PermutationChromosome.Generate">
             <summary>
             Generate random chromosome value.
             </summary>
             
             <remarks><para>Regenerates chromosome's value using random number generator.</para>
             </remarks>
            
        </member>
        <member name="M:BestCS.Genetic.PermutationChromosome.CreateNew">
             <summary>
             Create new random chromosome with same parameters (factory method).
             </summary>
             
             <remarks><para>The method creates new chromosome of the same type, but randomly
             initialized. The method is useful as factory method for those classes, which work
             with chromosome's interface, but not with particular chromosome type.</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.PermutationChromosome.Clone">
             <summary>
             Clone the chromosome.
             </summary>
             
             <returns>Return's clone of the chromosome.</returns>
             
             <remarks><para>The method clones the chromosome returning the exact copy of it.</para>
             </remarks>
            
        </member>
        <member name="M:BestCS.Genetic.PermutationChromosome.Mutate">
             <summary>
             Mutation operator.
             </summary>
             
             <remarks><para>The method performs chromosome's mutation, swapping two randomly
             chosen genes (array elements).</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.PermutationChromosome.Crossover(BestCS.Genetic.IChromosome)">
             <summary>
             Crossover operator.
             </summary>
             
             <param name="pair">Pair chromosome to crossover with.</param>
             
             <remarks><para>The method performs crossover between two chromosomes  interchanging
             some parts between these chromosomes.</para></remarks>
            
        </member>
        <member name="T:BestCS.Genetic.IFitnessFunction">
            <summary>
            Fitness function interface.
            </summary>
            
            <remarks>The interface should be implemented by all fitness function
            classes, which are supposed to be used for calculation of chromosomes
            fitness values. All fitness functions should return positive (<b>greater
            then zero</b>) value, which indicates how good is the evaluated chromosome - 
            the greater the value, the better the chromosome.
            </remarks>
        </member>
        <member name="M:BestCS.Genetic.IFitnessFunction.Evaluate(BestCS.Genetic.IChromosome)">
             <summary>
             Evaluates chromosome.
             </summary>
             
             <param name="chromosome">Chromosome to evaluate.</param>
             
             <returns>Returns chromosome's fitness value.</returns>
            
             <remarks>The method calculates fitness value of the specified
             chromosome.</remarks>
            
        </member>
        <member name="T:BestCS.Genetic.OptimizationFunction1D">
             <summary>Base class for one dimensional function optimizations.</summary>
             
             <remarks><para>The class is aimed to be used for one dimensional function
             optimization problems. It implements all methods of <see cref="T:BestCS.Genetic.IFitnessFunction"/>
             interface and requires overriding only one method -
             <see cref="M:BestCS.Genetic.OptimizationFunction1D.OptimizationFunction(System.Double)"/>, which represents the
             function to optimize.</para>
             
             <para><note>The optimization function should be greater
             than 0 on the specified optimization range.</note></para>
             
             <para>The class works only with binary chromosomes (<see cref="T:BestCS.Genetic.BinaryChromosome"/>).</para>
             
             <para>Sample usage:</para>
             <code>
             // define optimization function
             public class UserFunction : OptimizationFunction1D
             {
            	    public UserFunction( ) :
                     base( new Range( 0, 255 ) ) { }
            
             	public override double OptimizationFunction( double x )
            		{
            			return Math.Cos( x / 23 ) * Math.Sin( x / 50 ) + 2;
            		}
             }
             ...
             // create genetic population
             Population population = new Population( 40,
            		new BinaryChromosome( 32 ),
            		new UserFunction( ),
            		new EliteSelection( ) );
            	
             while ( true )
             {
            	    // run one epoch of the population
                 population.RunEpoch( );
                 // ...
             }
             </code>
             </remarks>
            
        </member>
        <member name="M:BestCS.Genetic.OptimizationFunction1D.#ctor(BestCS.Range)">
             <summary>
             Initializes a new instance of the <see cref="T:BestCS.Genetic.OptimizationFunction1D"/> class.
             </summary>
            
             <param name="range">Specifies range for optimization.</param>
            
        </member>
        <member name="M:BestCS.Genetic.OptimizationFunction1D.Evaluate(BestCS.Genetic.IChromosome)">
             <summary>
             Evaluates chromosome.
             </summary>
             
             <param name="chromosome">Chromosome to evaluate.</param>
             
             <returns>Returns chromosome's fitness value.</returns>
            
             <remarks>The method calculates fitness value of the specified
             chromosome.</remarks>
            
        </member>
        <member name="M:BestCS.Genetic.OptimizationFunction1D.Translate(BestCS.Genetic.IChromosome)">
             <summary>
             Translates genotype to phenotype.
             </summary>
             
             <param name="chromosome">Chromosome, which genoteype should be
             translated to phenotype.</param>
            
             <returns>Returns chromosome's fenotype - the actual solution
             encoded by the chromosome.</returns> 
             
             <remarks>The method returns double value, which represents function's
             input point encoded by the specified chromosome.</remarks>
            
        </member>
        <member name="M:BestCS.Genetic.OptimizationFunction1D.OptimizationFunction(System.Double)">
             <summary>
             Function to optimize.
             </summary>
            
             <param name="x">Function's input value.</param>
             
             <returns>Returns function output value.</returns>
             
             <remarks>The method should be overloaded by inherited class to
             specify the optimization function.</remarks>
            
        </member>
        <member name="P:BestCS.Genetic.OptimizationFunction1D.Range">
            <summary>
            Optimization range.
            </summary>
            
            <remarks>Defines function's input range. The function's extreme point will
            be searched in this range only.
            </remarks>
            
        </member>
        <member name="P:BestCS.Genetic.OptimizationFunction1D.Mode">
             <summary>
             Optimization mode.
             </summary>
            
             <remarks>Defines optimization mode - what kind of extreme point to search.</remarks> 
            
        </member>
        <member name="T:BestCS.Genetic.OptimizationFunction1D.Modes">
             <summary>
             Optimization modes.
             </summary>
            
             <remarks>The enumeration defines optimization modes for
             the one dimensional function optimization.</remarks> 
            
        </member>
        <member name="F:BestCS.Genetic.OptimizationFunction1D.Modes.Maximization">
            <summary>
            Search for function's maximum value.
            </summary>
        </member>
        <member name="F:BestCS.Genetic.OptimizationFunction1D.Modes.Minimization">
            <summary>
            Search for function's minimum value.
            </summary>
        </member>
        <member name="T:BestCS.Genetic.OptimizationFunction2D">
             <summary>Base class for two dimenstional function optimization.</summary>
            
             <remarks><para>The class is aimed to be used for two dimensional function
             optimization problems. It implements all methods of <see cref="T:BestCS.Genetic.IFitnessFunction"/>
             interface and requires overriding only one method -
             <see cref="M:BestCS.Genetic.OptimizationFunction2D.OptimizationFunction(System.Double,System.Double)"/>, which represents the
             function to optimize.</para>
             
             <para><note>The optimization function should be greater
             than 0 on the specified optimization range.</note></para>
             
             <para>The class works only with binary chromosomes (<see cref="T:BestCS.Genetic.BinaryChromosome"/>).</para>
             
             <para>Sample usage:</para>
             <code>
             // define optimization function
             public class UserFunction : OptimizationFunction2D
             {
            		public UserFunction( ) :
            			base( new Range( -4, 4 ), new Range( -4, 4 ) ) { }
            
             	public override double OptimizationFunction( double x, double y )
            		{
            			return ( Math.Cos( y ) * x * y ) / ( 2 - Math.Sin( x ) );
            		}
             }
             ...
             // create genetic population
             Population population = new Population( 40,
            		new BinaryChromosome( 32 ),
            		new UserFunction( ),
            		new EliteSelection( ) );
            	// run one epoch of the population
            	population.RunEpoch( );
             </code>
             </remarks>
            
        </member>
        <member name="M:BestCS.Genetic.OptimizationFunction2D.#ctor(BestCS.Range,BestCS.Range)">
             <summary>
             Initializes a new instance of the <see cref="T:BestCS.Genetic.OptimizationFunction2D"/> class.
             </summary>
            
             <param name="rangeX">Specifies X variable's range.</param>
             <param name="rangeY">Specifies Y variable's range.</param>
            
        </member>
        <member name="M:BestCS.Genetic.OptimizationFunction2D.Evaluate(BestCS.Genetic.IChromosome)">
             <summary>
             Evaluates chromosome.
             </summary>
             
             <param name="chromosome">Chromosome to evaluate.</param>
             
             <returns>Returns chromosome's fitness value.</returns>
            
             <remarks>The method calculates fitness value of the specified
             chromosome.</remarks>
            
        </member>
        <member name="M:BestCS.Genetic.OptimizationFunction2D.Translate(BestCS.Genetic.IChromosome)">
             <summary>
             Translates genotype to phenotype 
             </summary>
             
             <param name="chromosome">Chromosome, which genoteype should be
             translated to phenotype</param>
            
             <returns>Returns chromosome's fenotype - the actual solution
             encoded by the chromosome</returns> 
             
             <remarks>The method returns array of two double values, which
             represent function's input point (X and Y) encoded by the specified
             chromosome.</remarks>
            
        </member>
        <member name="M:BestCS.Genetic.OptimizationFunction2D.OptimizationFunction(System.Double,System.Double)">
             <summary>
             Function to optimize.
             </summary>
            
             <param name="x">Function X input value.</param>
             <param name="y">Function Y input value.</param>
             
             <returns>Returns function output value.</returns>
             
             <remarks>The method should be overloaded by inherited class to
             specify the optimization function.</remarks>
            
        </member>
        <member name="P:BestCS.Genetic.OptimizationFunction2D.RangeX">
            <summary>
            X variable's optimization range.
            </summary>
            
            <remarks>Defines function's X range. The function's extreme will
            be searched in this range only.
            </remarks>
            
        </member>
        <member name="P:BestCS.Genetic.OptimizationFunction2D.RangeY">
            <summary>
            Y variable's optimization range.
            </summary>
            
            <remarks>Defines function's Y range. The function's extreme will
            be searched in this range only.
            </remarks>
            
        </member>
        <member name="P:BestCS.Genetic.OptimizationFunction2D.Mode">
             <summary>
             Optimization mode.
             </summary>
            
             <remarks>Defines optimization mode - what kind of extreme to search.</remarks> 
            
        </member>
        <member name="T:BestCS.Genetic.OptimizationFunction2D.Modes">
             <summary>
             Optimization modes.
             </summary>
            
             <remarks>The enumeration defines optimization modes for
             the two dimensional function optimization.</remarks> 
            
        </member>
        <member name="F:BestCS.Genetic.OptimizationFunction2D.Modes.Maximization">
            <summary>
            Search for function's maximum value.
            </summary>
        </member>
        <member name="F:BestCS.Genetic.OptimizationFunction2D.Modes.Minimization">
            <summary>
            Search for function's minimum value.
            </summary>
        </member>
        <member name="T:BestCS.Genetic.SymbolicRegressionFitness">
            <summary>
            Fitness function for symbolic regression (function approximation) problem
            </summary>
            
            <remarks><para>The fitness function calculates fitness value of
            <see cref="T:BestCS.Genetic.GPTreeChromosome">GP</see> and <see cref="T:BestCS.Genetic.GEPChromosome">GEP</see>
            chromosomes with the aim of solving symbolic regression problem. The fitness function's
            value is computed as:
            <code>100.0 / ( error + 1 )</code>
            where <b>error</b> equals to the sum of absolute differences between function values (computed using
            the function encoded by chromosome) and input values (function to be approximated).</para>
            
            <para>Sample usage:</para>
            <code>
            // constants
            double[] constants = new double[5] { 1, 2, 3, 5, 7 };
            // function to be approximated
            double[,] data = new double[5, 2] {
            	{1, 1}, {2, 3}, {3, 6}, {4, 10}, {5, 15} };
            // create population
            Population population = new Population( 100,
            	new GPTreeChromosome( new SimpleGeneFunction( 1 + constants.Length ) ),
            	new SymbolicRegressionFitness( data, constants ),
            	new EliteSelection( ) );
            // run one epoch of the population
            population.RunEpoch( );
            </code>
            </remarks>
            
        </member>
        <member name="M:BestCS.Genetic.SymbolicRegressionFitness.#ctor(System.Double[0:,0:],System.Double[])">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Genetic.SymbolicRegressionFitness"/> class.
            </summary>
            
            <param name="data">Function to be approximated.</param>
            <param name="constants">Array of constants to be used as additional
            paramters for genetic expression.</param>
            
            <remarks><para>The <paramref name="data"/> parameter defines the function to be approximated and
            represents a two dimensional array of (x, y) points.</para>
            
            <para>The <paramref name="constants"/> parameter is an array of constants, which can be used as
            additional variables for a genetic expression. The actual amount of variables for
            genetic expression equals to the amount of constants plus one - the <b>x</b> variable.</para>
            </remarks>
            
        </member>
        <member name="M:BestCS.Genetic.SymbolicRegressionFitness.Evaluate(BestCS.Genetic.IChromosome)">
             <summary>
             Evaluates chromosome.
             </summary>
             
             <param name="chromosome">Chromosome to evaluate.</param>
             
             <returns>Returns chromosome's fitness value.</returns>
            
             <remarks>The method calculates fitness value of the specified
             chromosome.</remarks>
            
        </member>
        <member name="M:BestCS.Genetic.SymbolicRegressionFitness.Translate(BestCS.Genetic.IChromosome)">
             <summary>
             Translates genotype to phenotype .
             </summary>
             
             <param name="chromosome">Chromosome, which genoteype should be
             translated to phenotype.</param>
            
             <returns>Returns chromosome's fenotype - the actual solution
             encoded by the chromosome.</returns> 
             
             <remarks>The method returns string value, which represents approximation
             expression written in polish postfix notation.</remarks>
            
        </member>
        <member name="T:BestCS.Genetic.TimeSeriesPredictionFitness">
            <summary>
            Fitness function for times series prediction problem
            </summary>
            
            <remarks><para>The fitness function calculates fitness value of
            <see cref="T:BestCS.Genetic.GPTreeChromosome">GP</see> and <see cref="T:BestCS.Genetic.GEPChromosome">GEP</see>
            chromosomes with the aim of solving times series prediction problem using
            sliding window method. The fitness function's value is computed as:
            <code>100.0 / ( error + 1 )</code>
            where <b>error</b> equals to the sum of absolute differences between predicted value
            and actual future value.</para>
            
            <para>Sample usage:</para>
            <code>
            // number of points from the past used to predict new one
            int windowSize = 5;
            // time series to predict
            double[] data = new double[13] { 1, 2, 4, 7, 11, 16, 22, 29, 37, 46, 56, 67, 79 };
            // constants
            double[] constants = new double[10] { 1, 2, 3, 5, 7, 11, 13, 17, 19, 23 };
            // create population
            Population population = new Population( 100,
            new GPTreeChromosome( new SimpleGeneFunction( windowSize + constants.Length ) ),
            new TimeSeriesPredictionFitness( data, windowSize, 1, constants ),
            new EliteSelection( ) );
            // run one epoch of the population
            population.RunEpoch( );
            </code>
            </remarks>
            
        </member>
        <member name="M:BestCS.Genetic.TimeSeriesPredictionFitness.#ctor(System.Double[],System.Int32,System.Int32,System.Double[])">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Genetic.TimeSeriesPredictionFitness"/> class.
            </summary>
            
            <param name="data">Time series to be predicted.</param>
            <param name="windowSize">Window size - number of past samples used
            to predict future value.</param>
            <param name="predictionSize">Prediction size - number of values to be predicted. These
            values are excluded from training set.</param>
            <param name="constants">Array of constants to be used as additional
            paramters for genetic expression.</param>
            
            <remarks><para>The <paramref name="data"/> parameter is a one dimensional array, which defines times
            series to predict. The amount of learning samples is equal to the number of samples
            in the provided time series, minus window size, minus prediction size.</para>
            
            <para>The <paramref name="predictionSize"/> parameter specifies the amount of samples, which should
            be excluded from training set. This set of samples may be used for future verification
            of the prediction model.</para>
            
            <para>The <paramref name="constants"/> parameter is an array of constants, which can be used as
            additional variables for a genetic expression. The actual amount of variables for
            genetic expression equals to the amount of constants plus the window size.</para>
            </remarks>
            
        </member>
        <member name="M:BestCS.Genetic.TimeSeriesPredictionFitness.Evaluate(BestCS.Genetic.IChromosome)">
             <summary>
             Evaluates chromosome.
             </summary>
             
             <param name="chromosome">Chromosome to evaluate.</param>
             
             <returns>Returns chromosome's fitness value.</returns>
            
             <remarks>The method calculates fitness value of the specified
             chromosome.</remarks>
            
        </member>
        <member name="M:BestCS.Genetic.TimeSeriesPredictionFitness.Translate(BestCS.Genetic.IChromosome)">
             <summary>
             Translates genotype to phenotype.
             </summary>
             
             <param name="chromosome">Chromosome, which genoteype should be
             translated to phenotype.</param>
            
             <returns>Returns chromosome's fenotype - the actual solution
             encoded by the chromosome.</returns> 
             
             <remarks><para>The method returns string value, which represents prediction
             expression written in polish postfix notation.</para>
             
             <para>The interpretation of the prediction expression is very simple. For example, let's
             take a look at sample expression, which was received with window size equal to 5:
             <code lang="none">$0 $1 - $5 / $2 *</code>
             The above expression in postfix polish notation should be interpreted as a next expression:
             <code lang="none">( ( x[t - 1] - x[t - 2] ) / const1 ) * x[t - 3]</code>
             </para>
             </remarks>
            
        </member>
        <member name="T:BestCS.Genetic.Population">
            <summary>
            Population of chromosomes.
            </summary>
            
            <remarks><para>The class represents population - collection of individuals (chromosomes)
            and provides functionality for common population's life cycle - population growing
            with help of genetic operators and selection of chromosomes to new generation
            with help of selection algorithm. The class may work with any type of chromosomes
            implementing <see cref="T:BestCS.Genetic.IChromosome"/> interface, use any type of fitness functions
            implementing <see cref="T:BestCS.Genetic.IFitnessFunction"/> interface and use any type of selection
            algorithms implementing <see cref="T:BestCS.Genetic.ISelectionMethod"/> interface.</para>
            </remarks>
            
        </member>
        <member name="M:BestCS.Genetic.Population.#ctor(System.Int32,BestCS.Genetic.IChromosome,BestCS.Genetic.IFitnessFunction,BestCS.Genetic.ISelectionMethod)">
             <summary>
             Initializes a new instance of the <see cref="T:BestCS.Genetic.Population"/> class.
             </summary>
             
             <param name="size">Initial size of population.</param>
             <param name="ancestor">Ancestor chromosome to use for population creatioin.</param>
             <param name="fitnessFunction">Fitness function to use for calculating
             chromosome's fitness values.</param>
             <param name="selectionMethod">Selection algorithm to use for selection
             chromosome's to new generation.</param>
             
             <remarks>Creates new population of specified size. The specified ancestor
             becomes first member of the population and is used to create other members
             with same parameters, which were used for ancestor's creation.</remarks>
             
             <exception cref="T:System.ArgumentException">Too small population's size was specified. The
             exception is thrown in the case if <paramref name="size"/> is smaller than 2.</exception>
            
        </member>
        <member name="M:BestCS.Genetic.Population.Regenerate">
            <summary>
            Regenerate population.
            </summary>
            
            <remarks>The method regenerates population filling it with random chromosomes.</remarks>
            
        </member>
        <member name="M:BestCS.Genetic.Population.Crossover">
            <summary>
            Do crossover in the population.
            </summary>
            
            <remarks>The method walks through the population and performs crossover operator
            taking each two chromosomes in the order of their presence in the population.
            The total amount of paired chromosomes is determined by
            <see cref="P:BestCS.Genetic.Population.CrossoverRate">crossover rate</see>.</remarks>
            
        </member>
        <member name="M:BestCS.Genetic.Population.Mutate">
            <summary>
            Do mutation in the population.
            </summary>
            
            <remarks>The method walks through the population and performs mutation operator
            taking each chromosome one by one. The total amount of mutated chromosomes is
            determined by <see cref="P:BestCS.Genetic.Population.MutationRate">mutation rate</see>.</remarks>
            
        </member>
        <member name="M:BestCS.Genetic.Population.Selection">
            <summary>
            Do selection.
            </summary>
            
            <remarks>The method applies selection operator to the current population. Using
            specified selection algorithm it selects members to the new generation from current
            generates and adds certain amount of random members, if is required
            (see <see cref="P:BestCS.Genetic.Population.RandomSelectionPortion"/>).</remarks>
            
        </member>
        <member name="M:BestCS.Genetic.Population.RunEpoch">
            <summary>
            Run one epoch of the population.
            </summary>
            
            <remarks>The method runs one epoch of the population, doing crossover, mutation
            and selection by calling <see cref="M:BestCS.Genetic.Population.Crossover"/>, <see cref="M:BestCS.Genetic.Population.Mutate"/> and
            <see cref="M:BestCS.Genetic.Population.Selection"/>.</remarks>
            
        </member>
        <member name="M:BestCS.Genetic.Population.Shuffle">
            <summary>
            Shuffle randomly current population.
            </summary>
            
            <remarks><para>Population shuffling may be useful in cases when selection
            operator results in not random order of chromosomes (for example, after elite
            selection population may be ordered in ascending/descending order).</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.Population.AddChromosome(BestCS.Genetic.IChromosome)">
            <summary>
            Add chromosome to the population.
            </summary>
            
            <param name="chromosome">Chromosome to add to the population.</param>
            
            <remarks><para>The method adds specified chromosome to the current population.
            Manual adding of chromosome maybe useful, when it is required to add some initialized
            chromosomes instead of random.</para>
            
            <para><note>Adding chromosome manually should be done very carefully, since it
            may break the population. The manually added chromosome must have the same type
            and initialization parameters as the ancestor passed to constructor.</note></para>
            </remarks>
            
        </member>
        <member name="M:BestCS.Genetic.Population.Migrate(BestCS.Genetic.Population,System.Int32,BestCS.Genetic.ISelectionMethod)">
            <summary>
            Perform migration between two populations.
            </summary>
            
            <param name="anotherPopulation">Population to do migration with.</param>
            <param name="numberOfMigrants">Number of chromosomes from each population to migrate.</param>
            <param name="migrantsSelector">Selection algorithm used to select chromosomes to migrate.</param>
            
            <remarks><para>The method performs migration between two populations - current and the
            <paramref name="anotherPopulation">specified one</paramref>. During migration
            <paramref name="numberOfMigrants">specified number</paramref> of chromosomes is choosen from
            each population using <paramref name="migrantsSelector">specified selection algorithms</paramref>
            and put into another population replacing worst members there.</para></remarks>
            
        </member>
        <member name="M:BestCS.Genetic.Population.Resize(System.Int32)">
            <summary>
            Resize population to the new specified size.
            </summary>
            
            <param name="newPopulationSize">New size of population.</param>
            
            <remarks><para>The method does resizing of population. In the case if population
            should grow, it just adds missing number of random members. In the case if
            population should get smaller, the <see cref="P:BestCS.Genetic.Population.SelectionMethod">population's
            selection method</see> is used to reduce the population.</para></remarks>
            
            <exception cref="T:System.ArgumentException">Too small population's size was specified. The
            exception is thrown in the case if <paramref name="newPopulationSize"/> is smaller than 2.</exception>
            
        </member>
        <member name="M:BestCS.Genetic.Population.Resize(System.Int32,BestCS.Genetic.ISelectionMethod)">
             <summary>
             Resize population to the new specified size.
             </summary>
             
             <param name="newPopulationSize">New size of population.</param>
             <param name="membersSelector">Selection algorithm to use in the case
             if population should get smaller.</param>
             
             <remarks><para>The method does resizing of population. In the case if population
             should grow, it just adds missing number of random members. In the case if
             population should get smaller, the specified selection method is used to
             reduce the population.</para></remarks>
             
             <exception cref="T:System.ArgumentException">Too small population's size was specified. The
             exception is thrown in the case if <paramref name="newPopulationSize"/> is smaller than 2.</exception>
            
        </member>
        <member name="P:BestCS.Genetic.Population.CrossoverRate">
            <summary>
            Crossover rate, [0.1, 1].
            </summary>
            
            <remarks><para>The value determines the amount of chromosomes which participate
            in crossover.</para>
            
            <para>Default value is set to <b>0.75</b>.</para>
            </remarks>
            
        </member>
        <member name="P:BestCS.Genetic.Population.MutationRate">
            <summary>
            Mutation rate, [0.1, 1].
            </summary>
            
            <remarks><para>The value determines the amount of chromosomes which participate
            in mutation.</para>
            
            <para>Defaul value is set to <b>0.1</b>.</para></remarks>
            
        </member>
        <member name="P:BestCS.Genetic.Population.RandomSelectionPortion">
            <summary>
            Random selection portion, [0, 0.9].
            </summary>
            
            <remarks><para>The value determines the amount of chromosomes which will be
            randomly generated for the new population. The property controls the amount
            of chromosomes, which are selected to a new population using
            <see cref="P:BestCS.Genetic.Population.SelectionMethod">selection operator</see>, and amount of random
            chromosomes added to the new population.</para>
            
            <para>Default value is set to <b>0</b>.</para></remarks>
            
        </member>
        <member name="P:BestCS.Genetic.Population.AutoShuffling">
            <summary>
            Determines of auto shuffling is on or off.
            </summary>
            
            <remarks><para>The property specifies if automatic shuffling needs to be done
            on each <see cref="M:BestCS.Genetic.Population.RunEpoch">epoch</see> by calling <see cref="M:BestCS.Genetic.Population.Shuffle"/>
            method.</para>
            
            <para>Default value is set to <see langword="false"/>.</para></remarks>
            
        </member>
        <member name="P:BestCS.Genetic.Population.SelectionMethod">
            <summary>
            Selection method to use with the population.
            </summary>
            
            <remarks><para>The property sets selection method which is used to select
            population members for a new population - filter population after reproduction
            was done with operators like crossover and mutations.</para></remarks>
            
        </member>
        <member name="P:BestCS.Genetic.Population.FitnessFunction">
            <summary>
            Fitness function to apply to the population.
            </summary>
            
            <remarks><para>The property sets fitness function, which is used to evaluate
            usefulness of population's chromosomes. Setting new fitness function causes recalculation
            of fitness values for all population's members and new best member will be found.</para>
            </remarks>
            
        </member>
        <member name="P:BestCS.Genetic.Population.FitnessMax">
            <summary>
            Maximum fitness of the population.
            </summary>
            
            <remarks><para>The property keeps maximum fitness of chromosomes currently existing
            in the population.</para>
            
            <para><note>The property is recalculate only after <see cref="M:BestCS.Genetic.Population.Selection">selection</see>
            or <see cref="M:BestCS.Genetic.Population.Migrate(BestCS.Genetic.Population,System.Int32,BestCS.Genetic.ISelectionMethod)">migration</see> was done.</note></para>
            </remarks>
            
        </member>
        <member name="P:BestCS.Genetic.Population.FitnessSum">
             <summary>
             Summary fitness of the population.
             </summary>
            
             <remarks><para>The property keeps summary fitness of all chromosome existing in the
             population.</para>
             
             <para><note>The property is recalculate only after <see cref="M:BestCS.Genetic.Population.Selection">selection</see>
             or <see cref="M:BestCS.Genetic.Population.Migrate(BestCS.Genetic.Population,System.Int32,BestCS.Genetic.ISelectionMethod)">migration</see> was done.</note></para>
             </remarks>
            
        </member>
        <member name="P:BestCS.Genetic.Population.FitnessAvg">
             <summary>
             Average fitness of the population.
             </summary>
             
             <remarks><para>The property keeps average fitness of all chromosome existing in the
             population.</para>
             
             <para><note>The property is recalculate only after <see cref="M:BestCS.Genetic.Population.Selection">selection</see>
             or <see cref="M:BestCS.Genetic.Population.Migrate(BestCS.Genetic.Population,System.Int32,BestCS.Genetic.ISelectionMethod)">migration</see> was done.</note></para>
             </remarks>
            
        </member>
        <member name="P:BestCS.Genetic.Population.BestChromosome">
            <summary>
            Best chromosome of the population.
            </summary>
            
            <remarks><para>The property keeps the best chromosome existing in the population
            or <see langword="null"/> if all chromosomes have 0 fitness.</para>
            
            <para><note>The property is recalculate only after <see cref="M:BestCS.Genetic.Population.Selection">selection</see>
            or <see cref="M:BestCS.Genetic.Population.Migrate(BestCS.Genetic.Population,System.Int32,BestCS.Genetic.ISelectionMethod)">migration</see> was done.</note></para>
            </remarks>
            
        </member>
        <member name="P:BestCS.Genetic.Population.Size">
            <summary>
            Size of the population.
            </summary>
            
            <remarks>The property keeps initial (minimal) size of population.
            Population always returns to this size after selection operator was applied,
            which happens after <see cref="M:BestCS.Genetic.Population.Selection"/> or <see cref="M:BestCS.Genetic.Population.RunEpoch"/> methods
            call.</remarks>
            
        </member>
        <member name="P:BestCS.Genetic.Population.Item(System.Int32)">
            <summary>
            Get chromosome with specified index.
            </summary>
            
            <param name="index">Chromosome's index to retrieve.</param>
            
            <remarks>Allows to access individuals of the population.</remarks>
            
        </member>
        <member name="T:BestCS.Genetic.EliteSelection">
            <summary>
            Elite selection method.
            </summary>
            
            <remarks>Elite selection method selects specified amount of
            best chromosomes to the next generation.</remarks> 
            
        </member>
        <member name="T:BestCS.Genetic.ISelectionMethod">
            <summary>
            Genetic selection method interface.
            </summary>
            
            <remarks>The interface should be implemented by all classes, which
            implement genetic selection algorithm. These algorithms select members of
            current generation, which should be kept in the new generation. Basically,
            these algorithms filter provided population keeping only specified amount of
            members.</remarks>
            
        </member>
        <member name="M:BestCS.Genetic.ISelectionMethod.ApplySelection(System.Collections.Generic.List{BestCS.Genetic.IChromosome},System.Int32)">
            <summary>
            Apply selection to the specified population.
            </summary>
            
            <param name="chromosomes">Population, which should be filtered.</param>
            <param name="size">The amount of chromosomes to keep.</param>
            
            <remarks>Filters specified population according to the implemented
            selection algorithm.</remarks>
            
        </member>
        <member name="M:BestCS.Genetic.EliteSelection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Genetic.EliteSelection"/> class.
            </summary>
        </member>
        <member name="M:BestCS.Genetic.EliteSelection.ApplySelection(System.Collections.Generic.List{BestCS.Genetic.IChromosome},System.Int32)">
            <summary>
            Apply selection to the specified population.
            </summary>
            
            <param name="chromosomes">Population, which should be filtered.</param>
            <param name="size">The amount of chromosomes to keep.</param>
            
            <remarks>Filters specified population keeping only specified amount of best
            chromosomes.</remarks>
            
        </member>
        <member name="T:BestCS.Genetic.RankSelection">
            <summary>
            Rank selection method.
            </summary>
            
            <remarks><para>The algorithm selects chromosomes to the new generation depending on
            their fitness values - the better fitness value chromosome has, the more chances
            it has to become member of the new generation. Each chromosome can be selected
            several times to the new generation.</para>
            
            <para>This algorithm is similar to <see cref="T:BestCS.Genetic.RouletteWheelSelection">Roulette Wheel
            Selection</see> algorithm, but the difference is in "wheel" and its sectors' size
            calculation method. The size of the wheel equals to <b>size * ( size + 1 ) / 2</b>,
            where <b>size</b> is the current size of population. The worst chromosome has its sector's
            size equal to 1, the next chromosome has its sector's size equal to 2, etc.</para>
            </remarks>
            
        </member>
        <member name="M:BestCS.Genetic.RankSelection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Genetic.RankSelection"/> class.
            </summary>
        </member>
        <member name="M:BestCS.Genetic.RankSelection.ApplySelection(System.Collections.Generic.List{BestCS.Genetic.IChromosome},System.Int32)">
            <summary>
            Apply selection to the specified population.
            </summary>
            
            <param name="chromosomes">Population, which should be filtered.</param>
            <param name="size">The amount of chromosomes to keep.</param>
            
            <remarks>Filters specified population keeping only those chromosomes, which
            won "roulette" game.</remarks>
            
        </member>
        <member name="T:BestCS.Genetic.RouletteWheelSelection">
            <summary>
            Roulette wheel selection method.
            </summary>
            
            <remarks><para>The algorithm selects chromosomes to the new generation according to
            their fitness values - the more fitness value chromosome has, the more chances
            it has to become member of new generation. Each chromosome can be selected
            several times to the new generation.</para>
            
            <para>The "roulette's wheel" is divided into sectors, which size is proportional to
            the fitness values of chromosomes - the  size of the wheel is the sum of all fitness
            values, size of each sector equals to fitness value of chromosome.</para>
            </remarks>
            
        </member>
        <member name="M:BestCS.Genetic.RouletteWheelSelection.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Genetic.RouletteWheelSelection"/> class.
            </summary>
        </member>
        <member name="M:BestCS.Genetic.RouletteWheelSelection.ApplySelection(System.Collections.Generic.List{BestCS.Genetic.IChromosome},System.Int32)">
            <summary>
            Apply selection to the specified population.
            </summary>
            
            <param name="chromosomes">Population, which should be filtered.</param>
            <param name="size">The amount of chromosomes to keep.</param>
            
            <remarks>Filters specified population keeping only those chromosomes, which
            won "roulette" game.</remarks>
            
        </member>
        <member name="T:BestCS.Robotics.Lego.Internals.GhostAPI">
            <summary>
            GhostAPI wrapper class.
            </summary>
            
            <remarks><para>GhostAPI is a library provided by Lego, to communicate with its
            RCX robotics kit.</para></remarks>
            
        </member>
        <member name="F:BestCS.Robotics.Lego.Internals.GhostAPI.PBKERR_SEVERITYBITS">
            <summary>
            Mask of severity bits.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.Internals.GhostAPI.PBKERR_SEVERITY_SUCCESS">
            <summary>
            Success severity.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.Internals.GhostAPI.PBKERR_SEVERITY_INFORMATIONAL">
            <summary>
            Informational severity.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.Internals.GhostAPI.PBKERR_SEVERITY_WARNING">
            <summary>
            Warning severity.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.Internals.GhostAPI.PBKERR_SEVERITY_ERROR">
            <summary>
            Error severity.
            </summary>
        </member>
        <member name="M:BestCS.Robotics.Lego.Internals.GhostAPI.GhCreateStack(System.String,System.String,System.String,System.IntPtr@)">
            <summary>
            Creates Ghost communication stack.
            </summary>
            
            <param name="port">Port implementation required.</param>
            <param name="protocol">Protocol implementation required.</param>
            <param name="session">Session implementation required.</param>
            <param name="stack">Stack handle created by this function.</param>
            
            <returns>GhostAPI error code.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.Internals.GhostAPI.GhSelectFirstDevice(System.IntPtr,System.Text.StringBuilder,System.Int32)">
            <summary>
            Finds and selects the first available device.
            </summary>
            
            <param name="stack">Stack handle.</param>
            <param name="deviceName">Buffer, which will be filled with the name of the selected port device.</param>
            <param name="bufferSize">Size of the specified buffer.</param>
            
            <returns>GhostAPI error code.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.Internals.GhostAPI.GhOpen(System.IntPtr)">
            <summary>
            Opens the currently selected device.
            </summary>
            
            <param name="stack">Handle of the stack to be opened.</param>
            
            <returns>GhostAPI error code.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.Internals.GhostAPI.GhClose(System.IntPtr)">
            <summary>
            Closes the currently selected device.
            </summary>
            
            <param name="stack">Handle of the stack to be closed.</param>
            
            <returns>GhostAPI error code.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.Internals.GhostAPI.GhSetInterleave(System.IntPtr,System.Int32,System.Int32)">
            <summary>
            Sets the current command interleave between the execute and download queue.
            </summary>
            
            <param name="stack">Stack handle.</param>
            <param name="interleaveExecute">Number of immediate command blocks.</param>
            <param name="interleaveDownload">Number of download slices.</param>
            
            <returns>GhostAPI error code.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.Internals.GhostAPI.GhSetWaitMode(System.IntPtr,System.IntPtr)">
            <summary>
            Set the current notification mode to WAIT.
            </summary>
            
            <param name="stack">Stack handle.</param>
            <param name="notify">Must be <b>IntPtr.Zero</b> - no callback function.</param>
            
            <returns>GhostAPI error code.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.Internals.GhostAPI.GhCreateCommandQueue(System.IntPtr@)">
            <summary>
            Creates a command queue (containing one command to start with) and return handle.
            </summary>
            
            <param name="queue">Queue handle created by this function.</param>
            
            <returns>GhostAPI error code.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.Internals.GhostAPI.GhDestroyCommandQueue(System.IntPtr)">
            <summary>
            Releases a command queue.
            </summary>
            
            <param name="queue">Queue handle.</param>
            
            <returns>GhostAPI error code.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.Internals.GhostAPI.GhAppendCommand(System.IntPtr,System.Byte[],System.Int32,System.Int32)">
            <summary>
            Appends a command to the given command queue.
            </summary>
            
            <param name="queue"> Queue handle.</param>
            <param name="commandData">Command buffer (command + parameters).</param>
            <param name="commandLen">Length of the command buffer.</param>
            <param name="expectedReplyLen">Length of the expected reply to this command.</param>
            
            <returns>GhostAPI error code.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.Internals.GhostAPI.GhExecute(System.IntPtr,System.IntPtr)">
            <summary>
            Submits a command queue on the EXECUTE queue.
            </summary>
            
            <param name="stack">Stack handle.</param>
            <param name="queue">Queue handle.</param>
            
            <returns>GhostAPI error code.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.Internals.GhostAPI.GhGetFirstCommand(System.IntPtr,System.IntPtr@)">
            <summary>
            Gets the first command in the queue.
            </summary>
            <param name="queue">Queue handle.</param>
            <param name="command">Retrieved command handle.</param>
            
            <returns>GhostAPI error code.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.Internals.GhostAPI.GhGetCommandReplyLen(System.IntPtr,System.UInt32@)">
            <summary>
            Gets command reply length.
            </summary>
            
            <param name="command">Command handle.</param>
            <param name="replyLen">Reply length.</param>
            
            <returns>GhostAPI error code.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.Internals.GhostAPI.GhGetCommandReply(System.IntPtr,System.Byte[],System.UInt32)">
            <summary>
            Gets command reply.
            </summary>
            
            <param name="command">Command handle.</param>
            <param name="replyData">Buffer for reply data.</param>
            <param name="bufSize">Buffer size.</param>
            
            <returns>GhostAPI error code.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.Internals.GhostAPI.PBK_IS_SUCCESS(System.UInt32)">
            <summary>
            Checks if return value has success severity.
            </summary>
            
            <param name="e">Error return value.</param>
            
            <returns>True if the return value has success severity.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.Internals.GhostAPI.PBK_IS_INFO(System.UInt32)">
            <summary>
            Checks if return value has info severity.
            </summary>
            
            <param name="e">Error return value.</param>
            
            <returns>True if the return value has info severity.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.Internals.GhostAPI.PBK_IS_WARNING(System.UInt32)">
            <summary>
            Checks if return value has warning severity.
            </summary>
            
            <param name="e">Error return value.</param>
            
            <returns>True if the return value has warning severity.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.Internals.GhostAPI.PBK_IS_ERROR(System.UInt32)">
            <summary>
            Checks if return value has error severity.
            </summary>
            
            <param name="e">Error return value.</param>
            
            <returns>True if the return value has error severity.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.Internals.GhostAPI.PBK_SUCCEEDED(System.UInt32)">
            <summary>
            Checks for successful return code, which has success or info severity.
            </summary>
            
            <param name="e">Error return value.</param>
            
            <returns>True if return value is successful.</returns>
            
        </member>
        <member name="T:BestCS.Robotics.Lego.Internals.INXTCommunicationInterface">
            <summary>
            Interface, which wraps communication functions with Lego Mindstorms NXT brick.
            </summary>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.Internals.INXTCommunicationInterface.Connect">
            <summary>
            Connect to NXT brick.
            </summary>
            
            <returns>Returns <b>true</b> if connection was established successfully or <b>false</b>
            otherwise.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.Internals.INXTCommunicationInterface.Disconnect">
            <summary>
            Disconnect from NXT brick.
            </summary>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.Internals.INXTCommunicationInterface.SendMessage(System.Byte[])">
            <summary>
            Send message to NXT brick over the communication interface.
            </summary>
            
            <param name="message">Buffer containing the message to send.</param>
            
            <returns>Returns <b>true</b> if message was sent successfully or <b>false</b>
            otherwise.</returns>
            
            <remarks>This method assumes that message starts from the start of the
            specified buffer and occupies entire buffer.</remarks>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.Internals.INXTCommunicationInterface.SendMessage(System.Byte[],System.Int32)">
            <summary>
            Send message to NXT brick over the communication interface.
            </summary>
            
            <param name="message">Buffer containing the message to send.</param>
            <param name="length">Length of the message to send.</param>
            
            <returns>Returns <b>true</b> if message was sent successfully or <b>false</b>
            otherwise.</returns>
            
            <remarks>This method assumes that message starts from the start of the
            specified buffer.</remarks>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.Internals.INXTCommunicationInterface.SendMessage(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Send message to NXT brick over the communication interface.
            </summary>
            
            <param name="message">Buffer containing the message to send.</param>
            <param name="offset">Offset of the message in the buffer.</param>
            <param name="length">Length of the message to send.</param>
            
            <returns>Returns <b>true</b> if message was sent successfully or <b>false</b>
            otherwise.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.Internals.INXTCommunicationInterface.ReadMessage(System.Byte[],System.Int32@)">
            <summary>
            Read message from NXT brick over the communication interface.
            </summary>
            
            <param name="buffer">Buffer to use for message reading.</param>
            <param name="length">On successful return the variable keeps message length.</param>
            
            <returns>Returns <b>true</b> if message was read successfully or <b>false</b>
            otherwise.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.Internals.INXTCommunicationInterface.ReadMessage(System.Byte[],System.Int32,System.Int32@)">
            <summary>
            Read message from NXT brick over the communication interface.
            </summary>
            
            <param name="buffer">Buffer to use for message reading.</param>
            <param name="offset">Offset in the buffer for message.</param>
            <param name="length">On successful return the variable keeps message length.</param>
            
            <returns>Returns <b>true</b> if message was read successfully or <b>false</b>
            otherwise.</returns>
            
        </member>
        <member name="P:BestCS.Robotics.Lego.Internals.INXTCommunicationInterface.IsConnected">
            <summary>
            Get connection status.
            </summary>
            
        </member>
        <member name="T:BestCS.Robotics.Lego.Internals.NXTCommandType">
            <summary>
            Enumeration of command types supported by Lego Mindstorms NXT brick.
            </summary>
            
        </member>
        <member name="F:BestCS.Robotics.Lego.Internals.NXTCommandType.DirectCommand">
            <summary>
            Direct command, which requires reply.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.Internals.NXTCommandType.SystemCommand">
            <summary>
            System command, which requires reply.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.Internals.NXTCommandType.ReplyCommand">
            <summary>
            Reply command received from NXT brick.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.Internals.NXTCommandType.DirectCommandWithoutReply">
            <summary>
            Direct command, which does not require reply.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.Internals.NXTCommandType.SystemCommandWithoutReply">
            <summary>
            System command, which does not require reply.
            </summary>
        </member>
        <member name="T:BestCS.Robotics.Lego.Internals.NXTSystemCommand">
            <summary>
            Enumeration of system commands supported by Lego Mindstorms NXT brick.
            </summary>
            
        </member>
        <member name="F:BestCS.Robotics.Lego.Internals.NXTSystemCommand.GetFirmwareVersion">
            <summary>
            Get firmware version of NXT brick.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.Internals.NXTSystemCommand.SetBrickName">
            <summary>
            Set NXT brick name.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.Internals.NXTSystemCommand.GetDeviceInfo">
            <summary>
            Get device information.
            </summary>
        </member>
        <member name="T:BestCS.Robotics.Lego.Internals.NXTDirectCommand">
            <summary>
            Enumeration of direct commands supported by Lego Mindstorms NXT brick.
            </summary>
            
        </member>
        <member name="F:BestCS.Robotics.Lego.Internals.NXTDirectCommand.KeepAlive">
            <summary>
            Keep NXT brick alive.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.Internals.NXTDirectCommand.PlayTone">
            <summary>
            Play tone of specified frequency.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.Internals.NXTDirectCommand.GetBatteryLevel">
            <summary>
            Get battery level.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.Internals.NXTDirectCommand.SetOutputState">
            <summary>
            Set output state.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.Internals.NXTDirectCommand.GetOutputState">
            <summary>
            Get output state.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.Internals.NXTDirectCommand.ResetMotorPosition">
            <summary>
            Reset motor position.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.Internals.NXTDirectCommand.SetInputMode">
            <summary>
            Set input mode.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.Internals.NXTDirectCommand.GetInputValues">
            <summary>
            Get input values.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.Internals.NXTDirectCommand.LsGetStatus">
            <summary>
            Get status of the Low Speed bus.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.Internals.NXTDirectCommand.LsWrite">
            <summary>
            Write to the Low Speed bus.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.Internals.NXTDirectCommand.LsRead">
            <summary>
            Read from the Low Speed bus.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.Internals.NXTDirectCommand.ResetInputScaledValue">
            <summary>
            Reset input scaled value.
            </summary>
        </member>
        <member name="T:BestCS.Robotics.Lego.Internals.RCXCommand">
            <summary>
            Enumeration of commands supported by Lego Mindstorms RXT brick.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.Internals.RCXCommand.IsAlive">
            <summary>
            Check whether or not the RCX is alive.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.Internals.RCXCommand.PlaySound">
            <summary>
            Play one of defined sounds.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.Internals.RCXCommand.PlayTone">
            <summary>
            Play tone of specified frequency.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.Internals.RCXCommand.GetVersions">
            <summary>
            Get ROM and firmware versions.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.Internals.RCXCommand.GetBatteryPower">
            <summary>
            Get battery power.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.Internals.RCXCommand.SetTime">
            <summary>
            Set time displayed on RCX brick.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.Internals.RCXCommand.PowerOff">
            <summary>
            Turm off RCX brick.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.Internals.RCXCommand.GetValue">
            <summary>
            Get value.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.Internals.RCXCommand.SetSensorType">
            <summary>
            Set sensor type.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.Internals.RCXCommand.SetSensorMore">
            <summary>
            Set sensor mode.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.Internals.RCXCommand.ClearSensorValue">
            <summary>
            Clear sensor value.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.Internals.RCXCommand.SetTransmitterRange">
            <summary>
            Set IR transmiter's range.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.Internals.RCXCommand.SetMotorOnOff">
            <summary>
            Turn on/off motor.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.Internals.RCXCommand.SetMotorPower">
            <summary>
            Set motor's power.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.Internals.RCXCommand.SetMotorDirection">
            <summary>
            Set motor's direction
            </summary>
        </member>
        <member name="T:BestCS.Robotics.Lego.Internals.SerialCommunication">
            <summary>
            Implementation of serial communication interface with LEGO Mindstorm NXT brick.
            </summary>
            
        </member>
        <member name="F:BestCS.Robotics.Lego.Internals.SerialCommunication.MaxMessageSize">
            <summary>
            Maximum message size, which can be sent over this communication interface to NXT
            brick.
            </summary>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.Internals.SerialCommunication.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Robotics.Lego.Internals.SerialCommunication"/> class.
            </summary>
            
            <param name="portName">Serial port name to use for communication.</param>
            
            <remarks>This constructor initializes serial port with default write and read
            timeout values, which are 1000 milliseconds.</remarks>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.Internals.SerialCommunication.#ctor(System.String,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Robotics.Lego.Internals.SerialCommunication"/> class.
            </summary>
            
            <param name="portName">Serial port name to use for communication.</param>
            <param name="writeTimeout">Timeout value used for write operations.</param>
            <param name="readTimeout">Timeout value used for read operations.</param>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.Internals.SerialCommunication.Connect">
            <summary>
            Connect to NXT brick.
            </summary>
            
            <returns>Returns <b>true</b> if connection was established successfully or <b>false</b>
            otherwise.</returns>
            
            <remarks>If communication interface was connected before the call, existing connection will be reused.
            If it is required to force reconnection, then <see cref="M:BestCS.Robotics.Lego.Internals.SerialCommunication.Disconnect"/> method should be called before.
            </remarks>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.Internals.SerialCommunication.Disconnect">
            <summary>
            Disconnect from NXT brick.
            </summary>
        </member>
        <member name="M:BestCS.Robotics.Lego.Internals.SerialCommunication.SendMessage(System.Byte[])">
            <summary>
            Send message to NXT brick over the communication interface.
            </summary>
            
            <param name="message">Buffer containing the message to send.</param>
            
            <returns>Returns <b>true</b> if message was sent successfully or <b>false</b>
            otherwise.</returns>
            
            <remarks>This method assumes that message starts from the start of the
            specified buffer and occupies entire buffer.</remarks>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.Internals.SerialCommunication.SendMessage(System.Byte[],System.Int32)">
            <summary>
            Send message to NXT brick over the communication interface.
            </summary>
            
            <param name="message">Buffer containing the message to send.</param>
            <param name="length">Length of the message to send.</param>
            
            <returns>Returns <b>true</b> if message was sent successfully or <b>false</b>
            otherwise.</returns>
            
            <remarks>This method assumes that message starts from the start of the
            specified buffer.</remarks>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.Internals.SerialCommunication.SendMessage(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Send message to NXT brick over the communication interface.
            </summary>
            
            <param name="message">Buffer containing the message to send.</param>
            <param name="offset">Offset of the message in the buffer.</param>
            <param name="length">Length of the message to send.</param>
            
            <returns>Returns <b>true</b> if message was sent successfully or <b>false</b>
            otherwise.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.Internals.SerialCommunication.ReadMessage(System.Byte[],System.Int32@)">
            <summary>
            Read message from NXT brick over the communication interface.
            </summary>
            
            <param name="buffer">Buffer to use for message reading.</param>
            <param name="length">On successful return the variable keeps message length.</param>
            
            <returns>Returns <b>true</b> if message was read successfully or <b>false</b>
            otherwise.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.Internals.SerialCommunication.ReadMessage(System.Byte[],System.Int32,System.Int32@)">
            <summary>
            Read message from NXT brick over the communication interface.
            </summary>
            
            <param name="buffer">Buffer to use for message reading.</param>
            <param name="offset">Offset in the buffer for message.</param>
            <param name="length">On successful return the variable keeps message length.</param>
            
            <returns>Returns <b>true</b> if message was read successfully or <b>false</b>
            otherwise.</returns>
            
        </member>
        <member name="P:BestCS.Robotics.Lego.Internals.SerialCommunication.PortName">
            <summary>
            Serial port name used for communication.
            </summary>
            
        </member>
        <member name="P:BestCS.Robotics.Lego.Internals.SerialCommunication.IsConnected">
            <summary>
            Get connection status.
            </summary>
            
        </member>
        <member name="T:BestCS.Robotics.Lego.NXTBrick">
            <summary>
            Manipulation of Lego Mindstorms NXT device.
            </summary>
            
            <remarks>
            <para>The class allows to manipulate with Lego Mindstorms NXT device,
            setting/getting its motors' state, getting information about sensors'
            values and retrieving generic information about the NXT brick.</para>
            <para><img src="img/robotics/nxt.jpg" width="250" height="201" /></para>
            
            <para><note>Only communication through Bluetooth (virtual serial port) is supported at this point.</note></para>
            
            <para>Sample usage:</para>
            <code>
            // create an instance of NXT brick
            NXTBrick nxt = new NXTBrick( );
            // connect to the device
            if ( nxt.Connect( "COM8" ) )
            {
                // run motor A
                NXTBrick.MotorState motorState = new NXTBrick.MotorState( );
            
                motorState.Power      = 70;
                motorState.TurnRatio  = 50;
                motorState.Mode       = NXTBrick.MotorMode.On;
                motorState.Regulation = NXTBrick.MotorRegulationMode.Idle;
                motorState.RunState   = NXTBrick.MotorRunState.Running;
                motorState.TachoLimit = 1000;
            
                nxt.SetMotorState( NXTBrick.Motor.A, motorState );
            
                // get input value from the first sensor
                NXTBrick.SensorValues sensorValues;
            
                if ( nxt.GetSensorValue( NXTBrick.Sensor.First, out sensorValues ) )
                {
                    // ...
                }
                // ...
            }
            </code>
            </remarks>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.NXTBrick.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Robotics.Lego.NXTBrick"/> class.
            </summary>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.NXTBrick.Finalize">
            <summary>
            Destroys the instance of the <see cref="T:BestCS.Robotics.Lego.NXTBrick"/> class.
            </summary>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.NXTBrick.Connect(System.String)">
            <summary>
            Connect to NXT brick.
            </summary>
            
            <param name="portName">Serial port name to use for communication, for example COM1.</param>
            
            <returns>Returns <b>true</b> on successful connection or <b>false</b>
            otherwise.</returns>
            
            <remarks>If connection to NXT brick was established before the call, existing connection will be reused.
            If it is required to force reconnection, then <see cref="M:BestCS.Robotics.Lego.NXTBrick.Disconnect"/> method should be called before.
            </remarks>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.NXTBrick.Disconnect">
            <summary>
            Disconnect from Lego NXT brick.
            </summary>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.NXTBrick.IsAlive">
            <summary>
            Check if the NXT brick is alive and responds to messages.
            </summary>
            
            <returns>Returns <b>true</b> if device is alive or <b>false</b> otherwise.</returns>
            
            <remarks>The command also keeps NXT brick alive preventing it from sleep.</remarks>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.NXTBrick.PlayTone(System.Int16,System.Int16)">
            <summary>
            Play tone of specified frequency.
            </summary>
            
            <param name="frequency">Tone frequency in Hz.</param>
            <param name="duration">Tone duration in milliseconds.</param>
            
            <returns>Returns <b>true</b> if device is alive or <b>false</b> otherwise.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.NXTBrick.PlayTone(System.Int16,System.Int16,System.Boolean)">
            <summary>
            Play tone of specified frequency.
            </summary>
            
            <param name="frequency">Tone frequency in Hz.</param>
            <param name="duration">Tone duration in milliseconds.</param>
            <param name="waitReply">Wait reply from NXT (safer option) or not (faster option).</param>
            
            <returns>Returns <b>true</b> if device is alive or <b>false</b> otherwise.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.NXTBrick.GetVersion(System.String@,System.String@)">
             <summary>
             Get firmware version of NXT brick.
             </summary>
             
             <param name="protocolVersion">Protocol version number.</param>
             <param name="firmwareVersion">Firmware version number.</param>
             
             <returns>Returns <b>true</b> if command was executed successfully or <b>false</b> otherwise.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.NXTBrick.GetDeviceInformation(System.String@,System.Byte[]@,System.Int32@,System.Int32@)">
             <summary>
             Get information about NXT device.
             </summary>
             
             <param name="deviceName">Device name.</param>
             <param name="btAddress">Bluetooth address.</param>
             <param name="btSignalStrength">Bluetooth signal strength.</param>
             <param name="freeUserFlash">Free user Flash.</param>
             
             <returns>Returns <b>true</b> if command was executed successfully or <b>false</b> otherwise.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.NXTBrick.GetBatteryPower(System.Int32@)">
            <summary>
            Get battery power of NXT brick.
            </summary>
            
            <param name="power">NXT brick's battery power in millivolts.</param>
            
            <returns>Returns <b>true</b> if command was executed successfully or <b>false</b> otherwise.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.NXTBrick.SetBrickName(System.String)">
            <summary>
            Set name of NXT device.
            </summary>
            
            <param name="deviceName">Device name to set for the brick.</param>
            
            <returns>Returns <b>true</b> if command was executed successfully or <b>false</b> otherwise.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.NXTBrick.ResetMotorPosition(BestCS.Robotics.Lego.NXTBrick.Motor,System.Boolean)">
             <summary>
             Reset motor's position.
             </summary>
             
             <param name="motor">Motor to reset.</param>
             <param name="relative">Specifies if relative (to last movement) or absolute motor's
             position should reset.</param>
            
             <returns>Returns <b>true</b> if command was executed successfully or <b>false</b> otherwise.</returns>
             
        </member>
        <member name="M:BestCS.Robotics.Lego.NXTBrick.ResetMotorPosition(BestCS.Robotics.Lego.NXTBrick.Motor,System.Boolean,System.Boolean)">
             <summary>
             Reset motor's position.
             </summary>
             
             <param name="motor">Motor to reset.</param>
             <param name="relative">Specifies if relative (to last movement) or absolute motor's
             position should reset.</param>
             <param name="waitReply">Wait reply from NXT (safer option) or not (faster option).</param>
            
             <returns>Returns <b>true</b> if command was executed successfully or <b>false</b> otherwise.</returns>
             
        </member>
        <member name="M:BestCS.Robotics.Lego.NXTBrick.SetMotorState(BestCS.Robotics.Lego.NXTBrick.Motor,BestCS.Robotics.Lego.NXTBrick.MotorState)">
            <summary>
            Set motor state.
            </summary>
            
            <param name="motor">Motor to set state for.</param>
            <param name="state">Motor's state to set.</param>
            
            <returns>Returns <b>true</b> if command was executed successfully or <b>false</b> otherwise.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.NXTBrick.SetMotorState(BestCS.Robotics.Lego.NXTBrick.Motor,BestCS.Robotics.Lego.NXTBrick.MotorState,System.Boolean)">
            <summary>
            Set motor state.
            </summary>
            
            <param name="motor">Motor to set state for.</param>
            <param name="state">Motor's state to set.</param>
            <param name="waitReply">Wait reply from NXT (safer option) or not (faster option).</param>
            
            <returns>Returns <b>true</b> if command was executed successfully or <b>false</b> otherwise.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.NXTBrick.GetMotorState(BestCS.Robotics.Lego.NXTBrick.Motor,BestCS.Robotics.Lego.NXTBrick.MotorState@)">
            <summary>
            Get motor state.
            </summary>
            
            <param name="motor">Motor to get state for.</param>
            <param name="state">Motor's state.</param>
            
            <returns>Returns <b>true</b> if command was executed successfully or <b>false</b> otherwise.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.NXTBrick.SetSensorMode(BestCS.Robotics.Lego.NXTBrick.Sensor,BestCS.Robotics.Lego.NXTBrick.SensorType,BestCS.Robotics.Lego.NXTBrick.SensorMode)">
            <summary>
            Set sensor's type and mode.
            </summary>
            
            <param name="sensor">Sensor to set type of.</param>
            <param name="type">Sensor's type.</param>
            <param name="mode">Sensor's mode.</param>
            
            <returns>Returns <b>true</b> if command was executed successfully or <b>false</b> otherwise.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.NXTBrick.SetSensorMode(BestCS.Robotics.Lego.NXTBrick.Sensor,BestCS.Robotics.Lego.NXTBrick.SensorType,BestCS.Robotics.Lego.NXTBrick.SensorMode,System.Boolean)">
            <summary>
            Set sensor's type and mode.
            </summary>
            
            <param name="sensor">Sensor to set type of.</param>
            <param name="type">Sensor's type.</param>
            <param name="mode">Sensor's mode.</param>
            <param name="waitReply">Wait reply from NXT (safer option) or not (faster option).</param>
            
            <returns>Returns <b>true</b> if command was executed successfully or <b>false</b> otherwise.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.NXTBrick.GetSensorValue(BestCS.Robotics.Lego.NXTBrick.Sensor,BestCS.Robotics.Lego.NXTBrick.SensorValues@)">
            <summary>
            Get sensor's values.
            </summary>
            
            <param name="sensor">Sensor to get values of.</param>
            <param name="sensorValues">etrieved sensor's values.</param>
            
            <returns>Returns <b>true</b> if command was executed successfully or <b>false</b> otherwise.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.NXTBrick.ClearSensor(BestCS.Robotics.Lego.NXTBrick.Sensor)">
            <summary>
            Clear sensor's scaled value. 
            </summary>
            
            <param name="sensor">Sensor to clear value of.</param>
            
            <returns>Returns <b>true</b> if command was executed successfully or <b>false</b> otherwise.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.NXTBrick.ClearSensor(BestCS.Robotics.Lego.NXTBrick.Sensor,System.Boolean)">
            <summary>
            Clear sensor's scaled value. 
            </summary>
            
            <param name="sensor">Sensor to clear value of.</param>
            <param name="waitReply">Wait reply from NXT (safer option) or not (faster option).</param>
            
            <returns>Returns <b>true</b> if command was executed successfully or <b>false</b> otherwise.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.NXTBrick.LsGetStatus(BestCS.Robotics.Lego.NXTBrick.Sensor,System.Int32@)">
            <summary>
            Get status of Low Speed bus.
            </summary>
            
            <param name="sensor">Sensor to get the status from.</param>
            <param name="readyBytes">Number of bytes that are ready to be read from the bus.</param>
            
            <returns>Returns <b>true</b> if command was executed successfully or <b>false</b> otherwise.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.NXTBrick.LsWrite(BestCS.Robotics.Lego.NXTBrick.Sensor,System.Byte[],System.Int32)">
            <summary>
            Write to Low Speed bus.
            </summary>
            
            <param name="sensor">Sensor to write to.</param>
            <param name="data">Data to send to the I2C device.</param>
            <param name="expectedBytes">Number of bytes expected from device on reply, [0..16].
            Can be set to zero if I2C command does not suppose any reply.</param>
            
            <returns>Returns <b>true</b> if command was executed successfully or <b>false</b> otherwise.</returns>
            
            <exception cref="T:System.ArgumentException">Data length must be in the [1..16] range.</exception>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.NXTBrick.LsWrite(BestCS.Robotics.Lego.NXTBrick.Sensor,System.Byte[],System.Int32,System.Boolean)">
            <summary>
            Write to Low Speed bus.
            </summary>
            
            <param name="sensor">Sensor to write to.</param>
            <param name="data">Data to send to the I2C device.</param>
            <param name="expectedBytes">Number of bytes expected from device on reply, [0..16].
            Can be set to zero if I2C command does not suppose any reply.</param>
            <param name="waitReply">Wait reply from NXT (safer option) or not (faster option).</param>
            
            <returns>Returns <b>true</b> if command was executed successfully or <b>false</b> otherwise.</returns>
            
            <exception cref="T:System.ArgumentException">Data length must be in the [1..16] range.</exception>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.NXTBrick.LsRead(BestCS.Robotics.Lego.NXTBrick.Sensor,System.Byte[],System.Int32@)">
            <summary>
            Read data from Low Speed bus.
            </summary>
            
            <param name="sensor">Sensor to read data from.</param>
            <param name="readValues">Array to read data to.</param>
            <param name="bytesRead">Bytes actually read from I2C device.</param>
            
            <returns>Returns <b>true</b> if command was executed successfully or <b>false</b> otherwise.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.NXTBrick.GetUltrasonicSensorsValue(BestCS.Robotics.Lego.NXTBrick.Sensor,System.Int32@)">
            <summary>
            Read value of ultrasonic distance sensor.
            </summary>
            
            <param name="sensor">Sensor to read value from.</param>
            <param name="value">Distance value obtained from ultrasonic sensor, [0..255] cm.</param>
            
            <returns>Returns <b>true</b> if command was executed successfully or <b>false</b> otherwise.</returns>
            
            <remarks><para>The method retrieves value of ultrasonic distance sensor by
            communicating with I2C device (writing to and reading from low speed bus).
            The method first sends { 0x02, 0x42 } command to the specified device using
            <see cref="M:BestCS.Robotics.Lego.NXTBrick.LsWrite(BestCS.Robotics.Lego.NXTBrick.Sensor,System.Byte[],System.Int32)"/> method. Then it waits until there is something available
            to read using <see cref="M:BestCS.Robotics.Lego.NXTBrick.LsGetStatus(BestCS.Robotics.Lego.NXTBrick.Sensor,System.Int32@)"/> method. Finally it reads sensor's value
            using <see cref="M:BestCS.Robotics.Lego.NXTBrick.LsRead(BestCS.Robotics.Lego.NXTBrick.Sensor,System.Byte[],System.Int32@)"/> device. See
            <a href="http://hsrc.static.net/Research/NXT%20I2C%20Communication/">this page</a>
            for details.</para>
            
            <para><note>Before using this method it is required to use
            <see cref="M:BestCS.Robotics.Lego.NXTBrick.SetSensorMode(BestCS.Robotics.Lego.NXTBrick.Sensor,BestCS.Robotics.Lego.NXTBrick.SensorType,BestCS.Robotics.Lego.NXTBrick.SensorMode,System.Boolean)"/> method to set sensor's type to
            <see cref="F:BestCS.Robotics.Lego.NXTBrick.SensorType.Lowspeed9V"/> mode. It should be done
            once after NXT brick is powered on. If sensor's type is not set properly,
            the method will generate an exception. Also after setting sensor's
            type application may need to wait a bit to give device some time
            to initialize.</note></para>
            </remarks>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.NXTBrick.SendCommand(System.Byte[],System.Byte[])">
            <summary>
            Send command to Lego NXT brick and read reply.
            </summary>
            
            <param name="command">Command to send.</param>
            <param name="reply">Buffer to receive reply into.</param>
            
            <returns>Returns <b>true</b> if the command was sent successfully and reply was
            received, otherwise <b>false</b>.</returns>
            
            <exception cref="T:System.NullReferenceException">Communication can not be performed, because connection with
            NXT brick was not established yet.</exception>
            <exception cref="T:System.ArgumentException">Reply buffer size is smaller than the reply data size.</exception>
            <exception cref="T:System.ApplicationException">Reply does not correspond to command (second byte of reply should
            be equal to second byte of command).</exception>
            <exception cref="T:System.ApplicationException">Error occurred on NXT brick side.</exception>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.NXTBrick.ReadHiTechnicColorSensor(BestCS.Robotics.Lego.NXTBrick.Sensor,System.Int32@,System.Int32@,System.Int32@,System.Int32@)">
            <summary>
            Read data from HiTechnic color sensor (also color sensor v2).
            </summary>
            
            <param name="sensor">Sensor to read from.</param>
            <param name="colorNumber"><a href="http://www.hitechnic.com/contents/media/Color%20Number.jpg">Found color number.</a></param>
            <param name="redValue">Found red value.</param>
            <param name="greenValue">Found green value.</param>
            <param name="blueValue">Found blue value.</param>
            
            <returns>Returns <b>true</b> if the command was sent successfully and reply was
            received, otherwise <b>false</b>.</returns>
            
            <remarks><para>The method retrieves the color valuse of a <a href="http://www.hitechnic.com/products/">HiTechnic color sensor</a>
            by communicating with I2C device (writing to and reading from low speed bus).
            The method first sends { 0x02, 0x42 } command to the specified device using
            <see cref="M:BestCS.Robotics.Lego.NXTBrick.LsWrite(BestCS.Robotics.Lego.NXTBrick.Sensor,System.Byte[],System.Int32)"/> method. Then it waits until there is something available
            to read using <see cref="M:BestCS.Robotics.Lego.NXTBrick.LsGetStatus(BestCS.Robotics.Lego.NXTBrick.Sensor,System.Int32@)"/> method. Finally it reads sensor's value
            using <see cref="M:BestCS.Robotics.Lego.NXTBrick.LsRead(BestCS.Robotics.Lego.NXTBrick.Sensor,System.Byte[],System.Int32@)"/> device. See
            <a href="http://hsrc.static.net/Research/NXT%20I2C%20Communication/">this page</a>
            for details.</para>
            
            <para><note>Before using this method it is required to use
            <see cref="M:BestCS.Robotics.Lego.NXTBrick.SetSensorMode(BestCS.Robotics.Lego.NXTBrick.Sensor,BestCS.Robotics.Lego.NXTBrick.SensorType,BestCS.Robotics.Lego.NXTBrick.SensorMode,System.Boolean)"/> method to set sensor's type to
            <see cref="F:BestCS.Robotics.Lego.NXTBrick.SensorType.Lowspeed"/> mode. It should be done
            once after NXT brick is powered on. If sensor's type is not set properly,
            the method will generate an exception. Also after setting sensor's
            type application may need to wait a bit to give device some time
            to initialize.</note></para>
            
            <para><note>NXT Firmware version 1.24 must be loaded in the NXT for the HiTechnic color sensor to operate correctly.
            You can check the firmware version using the <see cref="M:BestCS.Robotics.Lego.NXTBrick.GetVersion(System.String@,System.String@)"/> method.</note></para>
            
            <para><note>The color sensor V2 must be configured to match the mains electricity frequency for your
            country. Details on how to configure the Color Sensor V2 can be found at
            <a href="http://www.hitechnic.com/colorsensor"></a></note></para>
            </remarks>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.NXTBrick.ReadHiTechnicCompassSensor(BestCS.Robotics.Lego.NXTBrick.Sensor,System.Int32@)">
            <summary>
            Read data from HiTechnic compass sensor.
            </summary>
            
            <param name="sensor">Sensor to read from.</param>
            <param name="angle">The magnetic heading, [0, 359] degrees.</param>
            
            <returns>Returns <b>true</b> if the command was sent successfully and reply was
            received, otherwise <b>false</b>.</returns>
            
            <remarks><para>The method retrieves the angle of a <a href="http://www.hitechnic.com/products/">
            HiTechnic compass sensor</a> by
            communicating with I2C device (writing to and reading from low speed bus).
            The method first sends { 0x02, 0x42 } command to the specified device using
            <see cref="M:BestCS.Robotics.Lego.NXTBrick.LsWrite(BestCS.Robotics.Lego.NXTBrick.Sensor,System.Byte[],System.Int32)"/> method. Then it waits until there is something available
            to read using <see cref="M:BestCS.Robotics.Lego.NXTBrick.LsGetStatus(BestCS.Robotics.Lego.NXTBrick.Sensor,System.Int32@)"/> method. Finally it reads sensor's value
            using <see cref="M:BestCS.Robotics.Lego.NXTBrick.LsRead(BestCS.Robotics.Lego.NXTBrick.Sensor,System.Byte[],System.Int32@)"/> device. See
            <a href="http://hsrc.static.net/Research/NXT%20I2C%20Communication/">this page</a>
            for details.</para>
            
            <para><note>Before using this method it is required to use
            <see cref="M:BestCS.Robotics.Lego.NXTBrick.SetSensorMode(BestCS.Robotics.Lego.NXTBrick.Sensor,BestCS.Robotics.Lego.NXTBrick.SensorType,BestCS.Robotics.Lego.NXTBrick.SensorMode,System.Boolean)"/> method to set sensor's type to
            <see cref="F:BestCS.Robotics.Lego.NXTBrick.SensorType.Lowspeed"/> mode. It should be done
            once after NXT brick is powered on. If sensor's type is not set properly,
            the method will generate an exception. Also after setting sensor's
            type application may need to wait a bit to give device some time
            to initialize.</note></para>
            
            <para><note>The HiTechnic compass sensor will only operate correctly in a horizontal plane so you must keep the compass
            level for it to read correctly. This is very important so remember this when you build it into your robot.
            It is highly desirable to mount the compass at least 6 inches (15cm) away from the motors and 4 inches (10cm) away from the NXT brick
            itself. Try to make sure it is firmly mounted, if it bounces around, the readings may bounce around too.
            </note></para>
            
            <para><note>NXT Firmware version 1.03 must be loaded in the NXT for the compass to operate correctly. You can check the firmware version
            using the <see cref="M:BestCS.Robotics.Lego.NXTBrick.GetVersion(System.String@,System.String@)"/> method.</note></para>
            </remarks>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.NXTBrick.ReadHiTechnicAccelerationTiltSensor(BestCS.Robotics.Lego.NXTBrick.Sensor,System.Int32@,System.Int32@,System.Int32@)">
             <summary>
             Read data from HiTechnic acceleration/tilt sensor. The HiTechnic accelerometer/tilt sensor measures acceleration in 
             three axes. It measures also tilt along each axis. Using the sensor, you can measure the acceleration of your robot in the range
             of -2g to 2g.
             </summary>
             
             <param name="sensor">Sensor to read from.</param>
             <param name="xAceeleration">Acceleration in X direction, with a scaling of approximately 200 counts per g.</param>
             <param name="yAceeleration">Acceleration in Y direction, with a scaling of approximately 200 counts per g.</param>
             <param name="zAceeleration">Acceleration in Z direction, with a scaling of approximately 200 counts per g.</param>
             
             <returns>Returns <b>true</b> if the command was sent successfully and reply was
             received, otherwise <b>false</b>.</returns>
             
             <remarks><para>The method retrieves the acceleration in three directions of a
             <a href="http://www.hitechnic.com/products/"> HiTechnic acceleration/tilt sensor</a> by
             communicating with I2C device (writing to and reading from low speed bus).
             The method first sends { 0x02, 0x42 } command to the specified device using
             <see cref="M:BestCS.Robotics.Lego.NXTBrick.LsWrite(BestCS.Robotics.Lego.NXTBrick.Sensor,System.Byte[],System.Int32)"/> method. Then it waits until there is something available
             to read using <see cref="M:BestCS.Robotics.Lego.NXTBrick.LsGetStatus(BestCS.Robotics.Lego.NXTBrick.Sensor,System.Int32@)"/> method. Finally it reads sensor's value
             using <see cref="M:BestCS.Robotics.Lego.NXTBrick.LsRead(BestCS.Robotics.Lego.NXTBrick.Sensor,System.Byte[],System.Int32@)"/> device. See
             <a href="http://hsrc.static.net/Research/NXT%20I2C%20Communication/">this page</a>
             for details.</para>
             
             <para><note>Before using this method it is required to use
             <see cref="M:BestCS.Robotics.Lego.NXTBrick.SetSensorMode(BestCS.Robotics.Lego.NXTBrick.Sensor,BestCS.Robotics.Lego.NXTBrick.SensorType,BestCS.Robotics.Lego.NXTBrick.SensorMode,System.Boolean)"/> method to set sensor's type to
             <see cref="F:BestCS.Robotics.Lego.NXTBrick.SensorType.Lowspeed"/> mode. It should be done
             once after NXT brick is powered onq If sensor's type is not set properly,
             the method will generate an exception. Also after setting sensor's
             type application may need to wait a bit to give device some time
             to initialize.</note></para>
             
             <para>The acceleration sensor can also be used to measure tilt in three axes This is possible because gravity is perceived
             as acceleration. When the sensor is stationary and in the normal horizontal position, the x and y axis will be near 
             zero, because they are horizontal, while the z axis will be near 200, which represents g. If you tilt the sensor then 
             gravity will also be detected on the other axis and the value for the z axis will go down. Since gravity is distributed
             among the three component vectors, the tilt of the sensor can be determined.</para>
            
             <para><note>NXT Firmware version 1.05 or later must be loaded in the NXT for the acceleration/tilt sensor and other digital I2C
             sensors to operate correctly. You can check the firmware version using the <see cref="M:BestCS.Robotics.Lego.NXTBrick.GetVersion(System.String@,System.String@)"/> method.</note></para>
             </remarks>
             
        </member>
        <member name="P:BestCS.Robotics.Lego.NXTBrick.IsConnected">
            <summary>
            Check if connection to NXT brick is established.
            </summary>
            
        </member>
        <member name="E:BestCS.Robotics.Lego.NXTBrick.MessageSent">
            <summary>
            The event is raised every time a command is sent successfully.
            </summary>
            
        </member>
        <member name="E:BestCS.Robotics.Lego.NXTBrick.MessageRead">
            <summary>
            The event is raised every time a command is read successfully.
            </summary>
            
        </member>
        <member name="T:BestCS.Robotics.Lego.NXTBrick.Sensor">
            <summary>
            Enumeration of NXT brick sensor ports.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.Sensor.First">
            <summary>
            First sensor.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.Sensor.Second">
            <summary>
            Second sensor.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.Sensor.Third">
            <summary>
            Third sensor.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.Sensor.Fourth">
            <summary>
            Fourth sensor.
            </summary>
        </member>
        <member name="T:BestCS.Robotics.Lego.NXTBrick.SensorType">
            <summary>
            Enumeration of NXT brick sensor types.
            </summary>
            
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.SensorType.NoSensor">
            <summary>
            No sensor.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.SensorType.Switch">
            <summary>
            NXT or Legacy touch sensor.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.SensorType.Temperature">
            <summary>
            Legacy temperature sensor.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.SensorType.Reflection">
            <summary>
            Legacy light sensor.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.SensorType.Angle">
            <summary>
            Legacy rotation sensor.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.SensorType.LightActive">
            <summary>
            NXT light sensor with floodlight enabled.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.SensorType.LightInactive">
            <summary>
            NXT light sensor with floodlight disabled.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.SensorType.SoundDB">
            <summary>
            NXT sound sensor (dB scaling).
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.SensorType.SoundDBA">
            <summary>
            NXT sound sensor (dBA scaling).
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.SensorType.Custom">
            <summary>
            Unused
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.SensorType.Lowspeed">
            <summary>
            I2C digital sensor.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.SensorType.Lowspeed9V">
            <summary>
            I2C digital sensor (9V power).
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.SensorType.Highspeed">
            <summary>
            Unused.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.SensorType.ColorFull">
            <summary>
            NXT 2.0 color sensor in color detector mode.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.SensorType.ColorRed">
            <summary>
            NXT 2.0 color sensor in light sensor mode with red light on.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.SensorType.ColorGreen">
            <summary>
            NXT 2.0 color sensor in light sensor mode with green light on.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.SensorType.ColorBlue">
            <summary>
            NXT 2.0 color sensor in light sensor mode with blue light on.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.SensorType.ColorNone">
            <summary>
            NXT 2.0 color sensor in light sensor mode without light.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.SensorType.ColorExit">
            <summary>
            NXT 2.0 color sensor internal state (no functionality known yet).
            </summary>
        </member>
        <member name="T:BestCS.Robotics.Lego.NXTBrick.SensorMode">
            <summary>
            Enumeration of NXT brick sensor modes.
            </summary>
            
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.SensorMode.Raw">
            <summary>
            Raw mode.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.SensorMode.Boolean">
            <summary>
            Boolean mode. Report scaled value as 1 (TRUE) or 0 (FALSE). The firmware uses
            inverse Boolean logic to match the physical characteristics of NXT sensors. Readings
            are FALSE if raw value exceeds 55% of total range; reading are TRUE if raw value
            is less than 45% of total range.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.SensorMode.TransitionCounter">
            <summary>
            Report scaled value as number of transition between TRUE and FALSE.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.SensorMode.PeriodicCounter">
            <summary>
            Report scaled value as number of transitions from FALSE to TRUE, then back to FALSE.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.SensorMode.PCTFullScale">
            <summary>
            Report scaled value as percentage of full scale reading for configured sensor type.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.SensorMode.Celsius">
            <summary>
            Scale terperature reading to degrees Celsius.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.SensorMode.Fahrenheit">
            <summary>
            Scale terperature reading to degrees Fahrenheit.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.SensorMode.AngleSteps">
            <summary>
            Report scaled value as count of ticks on RCX-style rotation sensor.
            </summary>
        </member>
        <member name="T:BestCS.Robotics.Lego.NXTBrick.SensorValues">
            <summary>
            Class describing sensor's values received from NXT brick's sensor port.
            </summary>
            
        </member>
        <member name="P:BestCS.Robotics.Lego.NXTBrick.SensorValues.IsValid">
            <summary>
            Specifies if data value should be treated as valid data.
            </summary>
        </member>
        <member name="P:BestCS.Robotics.Lego.NXTBrick.SensorValues.IsCalibrated">
            <summary>
            Specifies if calibration file was found and used for <see cref="P:BestCS.Robotics.Lego.NXTBrick.SensorValues.Calibrated"/>
            field calculation.
            </summary>
        </member>
        <member name="P:BestCS.Robotics.Lego.NXTBrick.SensorValues.SensorType">
            <summary>
            Sensor type.
            </summary>
        </member>
        <member name="P:BestCS.Robotics.Lego.NXTBrick.SensorValues.SensorMode">
            <summary>
            Sensor mode.
            </summary>
        </member>
        <member name="P:BestCS.Robotics.Lego.NXTBrick.SensorValues.Raw">
            <summary>
            Raw A/D value (device dependent).
            </summary>
        </member>
        <member name="P:BestCS.Robotics.Lego.NXTBrick.SensorValues.Normalized">
            <summary>
            Normalized A/D value (sensor type dependent), [0, 1023].
            </summary>
        </member>
        <member name="P:BestCS.Robotics.Lego.NXTBrick.SensorValues.Scaled">
            <summary>
            Scaled value (sensor mode dependent).
            </summary>
        </member>
        <member name="P:BestCS.Robotics.Lego.NXTBrick.SensorValues.Calibrated">
            <summary>
            Value scaled according to calibration.
            </summary>
            
            <remarks><note>According to Lego notes the value is currently unused.</note></remarks>
            
        </member>
        <member name="T:BestCS.Robotics.Lego.NXTBrick.Motor">
            <summary>
            Enumeration of NXT brick motor ports.
            </summary>
            
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.Motor.A">
            <summary>
            Motor A.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.Motor.B">
            <summary>
            Motor B.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.Motor.C">
            <summary>
            Motor C.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.Motor.All">
            <summary>
            All motors (A, B and C).
            </summary>
        </member>
        <member name="T:BestCS.Robotics.Lego.NXTBrick.MotorMode">
            <summary>
            Enumeration of supported motor modes.
            </summary>
            
            <remarks>Motor mode is a bit field, so several modes can be combined.</remarks>
            
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.MotorMode.None">
            <summary>
            Mode is not set.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.MotorMode.On">
            <summary>
            Turn on the motor.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.MotorMode.Brake">
            <summary>
            Brake.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.MotorMode.Regulated">
            <summary>
            Turn on regulated mode.
            </summary>
        </member>
        <member name="T:BestCS.Robotics.Lego.NXTBrick.MotorRegulationMode">
            <summary>
            Enumeration of motor regulation modes.
            </summary>
            
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.MotorRegulationMode.Idle">
            <summary>
            No regulation will be enabled.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.MotorRegulationMode.Speed">
            <summary>
            Power control will be enabled on specified motor.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.MotorRegulationMode.Sync">
            <summary>
            Synchronization will be enabled.
            </summary>
            
            <remarks><note>Synchronization need to be enabled on two motors.</note></remarks>
            
        </member>
        <member name="T:BestCS.Robotics.Lego.NXTBrick.MotorRunState">
            <summary>
            Enumeration of motor run states.
            </summary>
            
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.MotorRunState.Idle">
            <summary>
            Motor will be idle.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.MotorRunState.RampUp">
            <summary>
            Motor will ramp-up.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.MotorRunState.Running">
            <summary>
            Motor will be running.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.NXTBrick.MotorRunState.RampDown">
            <summary>
            Motor will ramp-down.
            </summary>
        </member>
        <member name="T:BestCS.Robotics.Lego.NXTBrick.MotorState">
            <summary>
            Class describing motor's state.
            </summary>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.NXTBrick.MotorState.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Robotics.Lego.NXTBrick.MotorState"/> class.
            </summary>
        </member>
        <member name="M:BestCS.Robotics.Lego.NXTBrick.MotorState.#ctor(System.Int32,System.Int32,BestCS.Robotics.Lego.NXTBrick.MotorMode,BestCS.Robotics.Lego.NXTBrick.MotorRegulationMode,BestCS.Robotics.Lego.NXTBrick.MotorRunState,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Robotics.Lego.NXTBrick.MotorState"/> class.
            </summary>
            
            <param name="power">Power, [-100, 100].</param>
            <param name="turnRatio">Turn ratio, [-100, 100].</param>
            <param name="mode">Mode (bit field).</param>
            <param name="regulation">Regulation mode.</param>
            <param name="runState">Run state.</param>
            <param name="tachoLimit">The value determines motor's run limit.</param>
            
        </member>
        <member name="P:BestCS.Robotics.Lego.NXTBrick.MotorState.Power">
            <summary>
            Power, [-100, 100].
            </summary>
        </member>
        <member name="P:BestCS.Robotics.Lego.NXTBrick.MotorState.TurnRatio">
            <summary>
            Turn ratio, [-100, 100].
            </summary>
        </member>
        <member name="P:BestCS.Robotics.Lego.NXTBrick.MotorState.Mode">
            <summary>
            Mode (bit field).
            </summary>
        </member>
        <member name="P:BestCS.Robotics.Lego.NXTBrick.MotorState.Regulation">
            <summary>
            Regulation mode.
            </summary>
        </member>
        <member name="P:BestCS.Robotics.Lego.NXTBrick.MotorState.RunState">
            <summary>
            Run state.
            </summary>
        </member>
        <member name="P:BestCS.Robotics.Lego.NXTBrick.MotorState.TachoLimit">
            <summary>
            Tacho limit (0 - run forever).
            </summary>
            
            <remarks>The value determines motor's run limit.</remarks>
        </member>
        <member name="P:BestCS.Robotics.Lego.NXTBrick.MotorState.TachoCount">
            <summary>
            Number of counts since last reset of motor counter.
            </summary>
            
            <remarks><note>The value is ignored when motor's state is set. The value is
            provided when motor's state is retrieved.</note></remarks>
        </member>
        <member name="P:BestCS.Robotics.Lego.NXTBrick.MotorState.BlockTachoCount">
            <summary>
            Current position relative to last programmed movement.
            </summary>
            
            <remarks><note>The value is ignored when motor's state is set. The value is
            provided when motor's state is retrieved.</note></remarks>
        </member>
        <member name="P:BestCS.Robotics.Lego.NXTBrick.MotorState.RotationCount">
            <summary>
            Current position relative to last reset of motor's rotation sensor.
            </summary>
            
            <remarks><note>The value is ignored when motor's state is set. The value is
            provided when motor's state is retrieved.</note></remarks>
        </member>
        <member name="T:BestCS.Robotics.Lego.RCXBrick">
             <summary>
             Manipulation of Lego Mindstorms RCX device.
             </summary>
             
             <remarks>
             <para>The class allows to manipulate with Lego Mindstorms RCX device,
             setting its motors' state, getting information about sensors'
             values and performing some other manipulations.</para>
             <para><img src="img/robotics/rcx.jpg" width="312" height="251"/></para>
             
             <para><note>The class supports both types of IR towers - USB and serial (see
             <see cref="T:BestCS.Robotics.Lego.RCXBrick.IRTowerType"/>).</note></para>
             
             <para><note>The class uses GhostAPI to communicate with Lego RCX device, so its
             libraries (GhostAPI.dll, PbkComm32.dll and PbkUsbPort.dll) should be placed into applications folder.</note></para>
             
             <para><note>The class is deprecated.</note></para>
             
             <para>Sample usage:</para>
             <code>
             // create an instance of RCX brick
             RCXBrick rcx = new RCXBrick( );
             // connect to the device
             if ( rcx.Connect( RCXBrick.IRTowerType.USB ) )
             {
                 // set forward direction of motor A
                 rcx.SetMotorDirection( RCXBrick.Motor.A, true );
                 // set power of motor
                 rcx.SetMotorPower( RCXBrick.Motor.A, 1 );
                 // turm motor on
                 rcx.SetMotorOn( RCXBrick.Motor.A, true );
                 // ...
                 // turn off motors A, B and C
                 rcx.SetMotorOn( RCXBrick.Motor.ABC, false );
             
                 // get first sensor's value
                 short value;
            
                 if ( rcx.GetSensorValue( RCXBrick.Sensor.First, out value ) )
                 {
                     // ...
                 }
                 // ...
             }
             </code>
             
             </remarks>
             
        </member>
        <member name="M:BestCS.Robotics.Lego.RCXBrick.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Robotics.Lego.RCXBrick"/> class.
            </summary>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.RCXBrick.Finalize">
            <summary>
            Destroys the instance of the <see cref="T:BestCS.Robotics.Lego.RCXBrick"/> class.
            </summary>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.RCXBrick.Connect(BestCS.Robotics.Lego.RCXBrick.IRTowerType)">
            <summary>
            Connect to Lego RCX brick.
            </summary>
            
            <param name="towerType">Type of IR tower to use for communication with RCX brick.</param>
            
            <returns>Returns <b>true</b> on successful connection or <b>false</b>
            otherwise.</returns>
            
            <remarks>If connection to RCX brick was established before the call, existing connection will be reused.
            If it is required to force reconnection, then <see cref="M:BestCS.Robotics.Lego.RCXBrick.Disconnect"/> method should be called before.
            </remarks>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.RCXBrick.Disconnect">
            <summary>
            Disconnnect from Lego RCX brick.
            </summary>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.RCXBrick.IsAlive">
            <summary>
            Check if the RCX brick is alive and responds to messages.
            </summary>
            
            <returns>Returns <b>true</b> if device is alive or <b>false</b> otherwise.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.RCXBrick.PlaySound(BestCS.Robotics.Lego.RCXBrick.SoundType)">
            <summary>
            Play one of supported sounds.
            </summary>
            
            <param name="type">Sound type to play.</param>
            
            <returns>Returns <b>true</b> if command was executed successfully or <b>false</b> otherwise.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.RCXBrick.PlayTone(System.Int16,System.Byte)">
            <summary>
            Play tone of specified frequency.
            </summary>
            
            <param name="frequency">Tone frequency in Hz.</param>
            <param name="duration">Tone duration in 1/100ths of a second.</param>
            
            <returns>Returns <b>true</b> if command was executed successfully or <b>false</b> otherwise.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.RCXBrick.GetVersion(System.String@,System.String@)">
            <summary>
            Get version information of RCX brick.
            </summary>
            
            <param name="romVersion">ROM version number.</param>
            <param name="firmwareVersion">Firmware version number.</param>
            
            <returns>Returns <b>true</b> if command was executed successfully or <b>false</b> otherwise.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.RCXBrick.GetBatteryPower(System.Int32@)">
            <summary>
            Get battery power of RCX brick.
            </summary>
            
            <param name="power">RCX brick's battery power in millivolts.</param>
            
            <returns>Returns <b>true</b> if command was executed successfully or <b>false</b> otherwise.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.RCXBrick.SetTime(System.Byte,System.Byte)">
            <summary>
            Set current time for the RCX brick.
            </summary>
            
            <param name="hours">Hours, [0..23].</param>
            <param name="minutes">Minutes, [0..59].</param>
            
            <returns>Returns <b>true</b> if command was executed successfully or <b>false</b> otherwise.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.RCXBrick.PowerOff">
            <summary>
            Turn off the RCX brick.
            </summary>
            
            <returns>Returns <b>true</b> if command was executed successfully or <b>false</b> otherwise.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.RCXBrick.GetSensorValue(BestCS.Robotics.Lego.RCXBrick.Sensor,System.Int16@)">
            <summary>
            Get sensor's value.
            </summary>
            
            <param name="sensor">Sensor to get value of.</param>
            <param name="value">Retrieved sensor's value (units depend on current
            <see cref="T:BestCS.Robotics.Lego.RCXBrick.SensorType">sensor's type</see> and <see cref="T:BestCS.Robotics.Lego.RCXBrick.SensorMode">mode</see>).</param>
            
            <returns>Returns <b>true</b> if command was executed successfully or <b>false</b> otherwise.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.RCXBrick.SetSensorType(BestCS.Robotics.Lego.RCXBrick.Sensor,BestCS.Robotics.Lego.RCXBrick.SensorType)">
            <summary>
            Set sensor's type.
            </summary>
            
            <param name="sensor">Sensor to set type of.</param>
            <param name="type">Sensor type to set.</param>
            
            <returns>Returns <b>true</b> if command was executed successfully or <b>false</b> otherwise.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.RCXBrick.SetSensorMode(BestCS.Robotics.Lego.RCXBrick.Sensor,BestCS.Robotics.Lego.RCXBrick.SensorMode)">
            <summary>
            Set sensor's mode.
            </summary>
            
            <param name="sensor">Sensor to set mode of.</param>
            <param name="mode">Sensor mode to set.</param>
            
            <returns>Returns <b>true</b> if command was executed successfully or <b>false</b> otherwise.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.RCXBrick.ClearSensor(BestCS.Robotics.Lego.RCXBrick.Sensor)">
            <summary>
            Clear the counter associated with the specified sensor by setting it to a value of zero.
            </summary>
            
            <param name="sensor">Sensor to clear value of.</param>
            
            <returns>Returns <b>true</b> if command was executed successfully or <b>false</b> otherwise.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.RCXBrick.SetMotorOn(BestCS.Robotics.Lego.RCXBrick.Motor,System.Boolean)">
            <summary>
            Turn on/off specified motors.
            </summary>
            
            <param name="motors">Motors to turn on/off.</param>
            <param name="on">True to turn motors on, otherwise false.</param>
            
            <returns>Returns <b>true</b> if command was executed successfully or <b>false</b> otherwise.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.RCXBrick.SetMotorPower(BestCS.Robotics.Lego.RCXBrick.Motor,System.Byte)">
            <summary>
            Set power of specified motors.
            </summary>
            
            <param name="motors">Motors to set power of.</param>
            <param name="power">Power level to set, [0..7].</param>
            
            <returns>Returns <b>true</b> if command was executed successfully or <b>false</b> otherwise.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.RCXBrick.SetMotorDirection(BestCS.Robotics.Lego.RCXBrick.Motor,System.Boolean)">
            <summary>
            Set direction of specified motors.
            </summary>
            
            <param name="motors">Motors to set direction of.</param>
            <param name="isForward">True to set forward direction, false to set backward.</param>
            
            <returns>Returns <b>true</b> if command was executed successfully or <b>false</b> otherwise.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.RCXBrick.SetTransmitterRange(System.Boolean)">
            <summary>
            Set IR transmitter's range.
            </summary>
            
            <param name="isLongRange">True if long range should be set, otherwise false.</param>
            
            <returns>Returns <b>true</b> if command was executed successfully or <b>false</b> otherwise.</returns>
            
        </member>
        <member name="M:BestCS.Robotics.Lego.RCXBrick.SendCommand(System.Byte[],System.Byte[],System.Int32)">
            <summary>
            Send command to Lego RCX brick and read reply.
            </summary>
            
            <param name="command">Command to send.</param>
            <param name="reply">Buffer to receive reply into.</param>
            <param name="expectedReplyLen">Expected reply length.</param>
            
            <returns>Returns <b>true</b> if the command was sent successfully and reply was
            received, otherwise <b>false</b>.</returns>
            
            <exception cref="T:System.NullReferenceException">Communication can not be performed, because connection with
            RCX brick was not established yet.</exception>
            <exception cref="T:System.ArgumentException">Reply buffer size is smaller than the reply data size.</exception>
            <exception cref="T:System.ApplicationException">Reply does not correspond to command (first byte of reply
            should be complement (bitwise NOT) to the first byte of command orred with 0x08).</exception>
            
        </member>
        <member name="P:BestCS.Robotics.Lego.RCXBrick.IsConnected">
            <summary>
            Check if connection to RCX brick is established.
            </summary>
            
        </member>
        <member name="T:BestCS.Robotics.Lego.RCXBrick.IRTowerType">
            <summary>
            Type of IR tower used for communication with RCX.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.RCXBrick.IRTowerType.USB">
            <summary>
            USB IR tower.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.RCXBrick.IRTowerType.Serial">
            <summary>
            RS232 IR tower.
            </summary>
        </member>
        <member name="T:BestCS.Robotics.Lego.RCXBrick.SoundType">
            <summary>
            Enumeration of sound type playable by Lego RCX brick.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.RCXBrick.SoundType.Blip">
            <summary>
            Blip sound.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.RCXBrick.SoundType.BeepBeep">
            <summary>
            Double beep spund.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.RCXBrick.SoundType.DownwardTones">
            <summary>
            Downward tones sound.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.RCXBrick.SoundType.UpwardTones">
            <summary>
            Upward tones sound.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.RCXBrick.SoundType.LowBuzz">
            <summary>
            Low buzz sound.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.RCXBrick.SoundType.FastUpwardTones">
            <summary>
            Fast upward tones sound.
            </summary>
        </member>
        <member name="T:BestCS.Robotics.Lego.RCXBrick.Sensor">
            <summary>
            Enumeration of RCX brick sensor ports.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.RCXBrick.Sensor.First">
            <summary>
            First sensor.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.RCXBrick.Sensor.Second">
            <summary>
            Second sensor.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.RCXBrick.Sensor.Third">
            <summary>
            Third sensor.
            </summary>
        </member>
        <member name="T:BestCS.Robotics.Lego.RCXBrick.SensorType">
            <summary>
            Enumeration of RCX brick sensor types.
            </summary>
            
            <remarks><para>Use <see cref="M:BestCS.Robotics.Lego.RCXBrick.SetSensorType(BestCS.Robotics.Lego.RCXBrick.Sensor,BestCS.Robotics.Lego.RCXBrick.SensorType)"/> method to set RCX sensor's type.</para></remarks>
            
        </member>
        <member name="F:BestCS.Robotics.Lego.RCXBrick.SensorType.Raw">
            <summary>
            Raw sensor.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.RCXBrick.SensorType.Touch">
            <summary>
            Touch sensor (default mode is boolean).
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.RCXBrick.SensorType.Temperatur">
            <summary>
            Temperature sensor (default mode is temperature in C).
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.RCXBrick.SensorType.Light">
            <summary>
            Light sensor (default mode is percentage).
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.RCXBrick.SensorType.Rotation">
            <summary>
            Rotation sensor (default mode is angle).
            </summary>
        </member>
        <member name="T:BestCS.Robotics.Lego.RCXBrick.SensorMode">
            <summary>
            Enumeration of RCX brick sensor modes.
            </summary>
            
            <remarks><para>Use <see cref="M:BestCS.Robotics.Lego.RCXBrick.SetSensorMode(BestCS.Robotics.Lego.RCXBrick.Sensor,BestCS.Robotics.Lego.RCXBrick.SensorMode)"/> method to set RCX sensor's mode.</para></remarks>
            
        </member>
        <member name="F:BestCS.Robotics.Lego.RCXBrick.SensorMode.Raw">
            <summary>
            Raw mode - value in [0, 1023].
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.RCXBrick.SensorMode.Boolean">
            <summary>
            Boolean - either 0 or 1.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.RCXBrick.SensorMode.EdgeCount">
            <summary>
            Number of boolean transitions.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.RCXBrick.SensorMode.PulseCount">
            <summary>
            Number of boolean transitions divided by two.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.RCXBrick.SensorMode.Percentage">
            <summary>
            Raw value scaled to [0, 100].
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.RCXBrick.SensorMode.TemperatureC">
            <summary>
            Temperature in C - 1/10ths of a degree, [-19.8, 69.5].  
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.RCXBrick.SensorMode.TemperatureF">
            <summary>
            Temperature in F - 1/10ths of a degree, [-3.6, 157.1].  
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.RCXBrick.SensorMode.Angle">
            <summary>
            Angle - 1/16ths of a rotation, represented as a signed short.
            </summary>
        </member>
        <member name="T:BestCS.Robotics.Lego.RCXBrick.Motor">
            <summary>
            Enumeration of RCX brick motor ports.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.RCXBrick.Motor.A">
            <summary>
            Motor A.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.RCXBrick.Motor.B">
            <summary>
            Motor B.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.RCXBrick.Motor.C">
            <summary>
            Motor C.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.RCXBrick.Motor.AB">
            <summary>
            Motors A and B.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.RCXBrick.Motor.AC">
            <summary>
            Motors A and C.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.RCXBrick.Motor.BC">
            <summary>
            Motors B and C.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.RCXBrick.Motor.ABC">
            <summary>
            Motors A, B and C.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Lego.RCXBrick.Motor.All">
            <summary>
            All motors (A, B and C).
            </summary>
        </member>
        <member name="T:BestCS.Neuro.ActivationFunctions.IStochasticFunction">
            <summary>
              Common interface for stochastic activation functions.
            </summary>
            
            <seealso cref="T:BestCS.Neuro.ActivationFunctions.BernoulliFunction"/>
            <seealso cref="T:BestCS.Neuro.ActivationFunctions.GaussianFunction"/>
            
        </member>
        <member name="T:BestCS.Neuro.IActivationFunction">
            <summary>
            Activation function interface.
            </summary>
            
            <remarks>All activation functions, which are supposed to be used with
            neurons, which calculate their output as a function of weighted sum of
            their inputs, should implement this interfaces.
            </remarks>
            
        </member>
        <member name="M:BestCS.Neuro.IActivationFunction.Function(System.Double)">
             <summary>
             Calculates function value.
             </summary>
            
             <param name="x">Function input value.</param>
             
             <returns>Function output value, <i>f(x)</i>.</returns>
            
             <remarks>The method calculates function value at point <paramref name="x"/>.</remarks>
            
        </member>
        <member name="M:BestCS.Neuro.IActivationFunction.Derivative(System.Double)">
             <summary>
             Calculates function derivative.
             </summary>
             
             <param name="x">Function input value.</param>
             
             <returns>Function derivative, <i>f'(x)</i>.</returns>
             
             <remarks>The method calculates function derivative at point <paramref name="x"/>.</remarks>
            
        </member>
        <member name="M:BestCS.Neuro.IActivationFunction.Derivative2(System.Double)">
            <summary>
            Calculates function derivative.
            </summary>
            
            <param name="y">Function output value - the value, which was obtained
            with the help of <see cref="M:BestCS.Neuro.IActivationFunction.Function(System.Double)"/> method.</param>
            
            <returns>Function derivative, <i>f'(x)</i>.</returns>
            
            <remarks><para>The method calculates the same derivative value as the
            <see cref="M:BestCS.Neuro.IActivationFunction.Derivative(System.Double)"/> method, but it takes not the input <b>x</b> value
            itself, but the function value, which was calculated previously with
            the help of <see cref="M:BestCS.Neuro.IActivationFunction.Function(System.Double)"/> method.</para>
            
            <para><note>Some applications require as function value, as derivative value,
            so they can save the amount of calculations using this method to calculate derivative.</note></para>
            </remarks>
            
        </member>
        <member name="M:BestCS.Neuro.ActivationFunctions.IStochasticFunction.Generate(System.Double)">
            <summary>
              Samples a value from the function given a input value.
            </summary>
            
            <param name="x">Function input value.</param>
            
            <returns>Draws a random value from the function.</returns>
            
        </member>
        <member name="M:BestCS.Neuro.ActivationFunctions.IStochasticFunction.Generate2(System.Double)">
            <summary>
              Samples a value from the function given a function output value.
            </summary>
            
            <param name="y">The function output value. This is the value which was obtained
            with the help of the <see cref="M:BestCS.Neuro.IActivationFunction.Function(System.Double)"/> method.</param>
            
            <remarks><para>The method calculates the same output value as the
            <see cref="M:BestCS.Neuro.ActivationFunctions.IStochasticFunction.Generate(System.Double)"/> method, but it takes not the input <b>x</b> value
            itself, but the function value, which was calculated previously with help
            of the <see cref="M:BestCS.Neuro.IActivationFunction.Function(System.Double)"/> method.</para>
            </remarks>
            
            <returns>Draws a random value from the function.</returns>
            
        </member>
        <member name="T:BestCS.Neuro.ActivationFunctions.BernoulliFunction">
            <summary>
              Bernoulli stochastic activation function.
            </summary>
            
            <remarks>
            <para>
              The Bernoulli activation function can be used to create <see cref="T:BestCS.Neuro.Neurons.StochasticNeuron">
              Stochastic Neurons</see>, which can in turn be used to create <see cref="T:BestCS.Neuro.Networks.DeepBeliefNetwork">
              Deep Belief Networks</see> and <see cref="T:BestCS.Neuro.Networks.RestrictedBoltzmannMachine">Restricted Boltzmann
              Machines</see>. The use of a Bernoulli function is indicated when the inputs of a problem
              are discrete, it is, are either 0 or 1. When the inputs are continuous, the use of a
              <see cref="T:BestCS.Neuro.ActivationFunctions.GaussianFunction"/> might be more indicated.</para>
            <para>
              As a <see cref="T:BestCS.Neuro.ActivationFunctions.IStochasticFunction">stochastic activation function</see>, the Bernoulli
              function is able to generate values following a statistic probability distribution. In
              this case, the Bernoulli function follows a <see cref="T:BestCS.Statistics.Distributions.Univariate.BernoulliDistribution">Bernoulli
              distribution</see> with its <see cref="P:BestCS.Statistics.Distributions.Univariate.BernoulliDistribution.Mean">mean</see> given by
              the output of this class' <see cref="M:BestCS.Neuro.ActivationFunctions.BernoulliFunction.Function(System.Double)">sigmoidal function</see>.</para>
            </remarks>
            
            <example>
              <code>
              // Create a Bernoulli function with sigmoid's alpha = 1
              BernoulliFunction function = new BernoulliFunction();
              
              // Computes the function output (sigmoid function)
              double y = function.Function(x: 0.4); // 0.5986876
              
              // Draws a sample from a Bernoulli distribution with
              // mean given by the function output y (given as before)
              double z = function.Generate(x: 0.4); // (random, 0 or 1)
              
              // Here, z can be either 0 or 1. Since it follows a Bernoulli
              // distribution with mean 0.59, it is expected to be 1 about 
              // 0.59 of the time.
              
              // Now, please note that the above is completely equivalent 
              // to computing the line below (remember, 0.5986876 == y)
              double w = function.Generate2(y: 0.5986876); // (random, 0 or 1)
              
              
              // We can also compute the derivative of the sigmoid function
              double d = function.Derivative(x: 0.4); // 0.240260
              
              // Or compute the derivative given the functions' output y
              double e = function.Derivative2(y: 0.5986876); // 0.240260
              </code>
            </example>
            
            <seealso cref="T:BestCS.Statistics.Distributions.Univariate.BernoulliDistribution"/>
            <seealso cref="T:BestCS.Neuro.ActivationFunctions.GaussianFunction"/>
            <seealso cref="T:BestCS.Neuro.Networks.DeepBeliefNetwork"/>
            
        </member>
        <member name="M:BestCS.Neuro.ActivationFunctions.BernoulliFunction.#ctor(System.Double)">
            <summary>
              Initializes a new instance of the <see cref="T:BestCS.Neuro.ActivationFunctions.BernoulliFunction"/> class.
            </summary>
            
            <param name="alpha">Sigmoid's alpha value. Default is 1.</param>
            
        </member>
        <member name="M:BestCS.Neuro.ActivationFunctions.BernoulliFunction.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:BestCS.Neuro.ActivationFunctions.BernoulliFunction"/> class.
            </summary>
            
        </member>
        <member name="M:BestCS.Neuro.ActivationFunctions.BernoulliFunction.Function(System.Double)">
             <summary>
             Calculates function value.
             </summary>
            
             <param name="x">Function input value.</param>
             
             <returns>Function output value, <i>f(x)</i>.</returns>
            
             <remarks>The method calculates function value at point <paramref name="x"/>.</remarks>
            
        </member>
        <member name="M:BestCS.Neuro.ActivationFunctions.BernoulliFunction.Generate(System.Double)">
            <summary>
              Samples a value from the function given a input value.
            </summary>
            
            <param name="x">Function input value.</param>
            
            <returns>Draws a random value from the function.</returns>
            
        </member>
        <member name="M:BestCS.Neuro.ActivationFunctions.BernoulliFunction.Generate2(System.Double)">
            <summary>
              Samples a value from the function given a function output value.
            </summary>
            
            <param name="y">The function output value. This is the value which was obtained
            with the help of the <see cref="M:BestCS.Neuro.IActivationFunction.Function(System.Double)"/> method.</param>
            
            <remarks><para>The method calculates the same output value as the
            <see cref="M:BestCS.Neuro.ActivationFunctions.BernoulliFunction.Generate(System.Double)"/> method, but it takes not the input <b>x</b> value
            itself, but the function value, which was calculated previously with help
            of the <see cref="M:BestCS.Neuro.IActivationFunction.Function(System.Double)"/> method.</para>
            </remarks>
            
            <returns>Draws a random value from the function.</returns>
            
        </member>
        <member name="M:BestCS.Neuro.ActivationFunctions.BernoulliFunction.Derivative(System.Double)">
             <summary>
             Calculates function derivative.
             </summary>
             
             <param name="x">Function input value.</param>
             
             <returns>Function derivative, <i>f'(x)</i>.</returns>
             
             <remarks>The method calculates function derivative at point <paramref name="x"/>.</remarks>
            
        </member>
        <member name="M:BestCS.Neuro.ActivationFunctions.BernoulliFunction.Derivative2(System.Double)">
            <summary>
            Calculates function derivative.
            </summary>
            
            <param name="y">Function output value - the value, which was obtained
            with the help of <see cref="M:BestCS.Neuro.ActivationFunctions.BernoulliFunction.Function(System.Double)"/> method.</param>
            
            <returns>Function derivative, <i>f'(x)</i>.</returns>
            
            <remarks><para>The method calculates the same derivative value as the
            <see cref="M:BestCS.Neuro.ActivationFunctions.BernoulliFunction.Derivative(System.Double)"/> method, but it takes not the input <b>x</b> value
            itself, but the function value, which was calculated previously with
            the help of <see cref="M:BestCS.Neuro.ActivationFunctions.BernoulliFunction.Function(System.Double)"/> method.</para>
            
            <para><note>Some applications require as function value, as derivative value,
            so they can save the amount of calculations using this method to calculate derivative.</note></para>
            </remarks>
            
        </member>
        <member name="P:BestCS.Neuro.ActivationFunctions.BernoulliFunction.Random">
            <summary>
              Gets or sets the random sample generator
              used to activate neurons of this class.
            </summary>
            
        </member>
        <member name="P:BestCS.Neuro.ActivationFunctions.BernoulliFunction.Alpha">
             <summary>
               Sigmoid's alpha value.
             </summary>
             
             <remarks><para>The value determines steepness of the function. Increasing value of
             this property changes sigmoid to look more like a threshold function. Decreasing
             value of this property makes sigmoid to be very smooth (slowly growing from its
             minimum value to its maximum value).</para>
            
             <para>Default value is set to <b>1</b>.</para>
             </remarks>
             
        </member>
        <member name="T:BestCS.Neuro.BipolarSigmoidFunction">
             <summary>
             Bipolar sigmoid activation function.
             </summary>
            
             <remarks><para>The class represents bipolar sigmoid activation function with
             the next expression:
             <code lang="none">
                            2
             f(x) = ------------------ - 1
                    1 + exp(-alpha * x)
            
                       2 * alpha * exp(-alpha * x )
             f'(x) = -------------------------------- = alpha * (1 - f(x)^2) / 2
                       (1 + exp(-alpha * x))^2
             </code>
             </para>
             
             <para>Output range of the function: <b>[-1, 1]</b>.</para>
             
             <para>Functions graph:</para>
             <img src="img/neuro/sigmoid_bipolar.bmp" width="242" height="172" />
             </remarks>
             
        </member>
        <member name="M:BestCS.Neuro.BipolarSigmoidFunction.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Neuro.SigmoidFunction"/> class.
            </summary>
        </member>
        <member name="M:BestCS.Neuro.BipolarSigmoidFunction.#ctor(System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Neuro.BipolarSigmoidFunction"/> class.
            </summary>
            
            <param name="alpha">Sigmoid's alpha value.</param>
            
        </member>
        <member name="M:BestCS.Neuro.BipolarSigmoidFunction.Function(System.Double)">
             <summary>
             Calculates function value.
             </summary>
            
             <param name="x">Function input value.</param>
             
             <returns>Function output value, <i>f(x)</i>.</returns>
            
             <remarks>The method calculates function value at point <paramref name="x"/>.</remarks>
            
        </member>
        <member name="M:BestCS.Neuro.BipolarSigmoidFunction.Derivative(System.Double)">
             <summary>
             Calculates function derivative.
             </summary>
             
             <param name="x">Function input value.</param>
             
             <returns>Function derivative, <i>f'(x)</i>.</returns>
             
             <remarks>The method calculates function derivative at point <paramref name="x"/>.</remarks>
            
        </member>
        <member name="M:BestCS.Neuro.BipolarSigmoidFunction.Derivative2(System.Double)">
             <summary>
             Calculates function derivative.
             </summary>
             
             <param name="y">Function output value - the value, which was obtained
             with the help of <see cref="M:BestCS.Neuro.BipolarSigmoidFunction.Function(System.Double)"/> method.</param>
             
             <returns>Function derivative, <i>f'(x)</i>.</returns>
            
             <remarks><para>The method calculates the same derivative value as the
             <see cref="M:BestCS.Neuro.BipolarSigmoidFunction.Derivative(System.Double)"/> method, but it takes not the input <b>x</b> value
             itself, but the function value, which was calculated previously with
             the help of <see cref="M:BestCS.Neuro.BipolarSigmoidFunction.Function(System.Double)"/> method.</para>
             
             <para><note>Some applications require as function value, as derivative value,
             so they can save the amount of calculations using this method to calculate derivative.</note></para>
             </remarks>
             
        </member>
        <member name="M:BestCS.Neuro.BipolarSigmoidFunction.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            
            <returns>
            A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:BestCS.Neuro.BipolarSigmoidFunction.Alpha">
             <summary>
             Sigmoid's alpha value.
             </summary>
            
             <remarks><para>The value determines steepness of the function. Increasing value of
             this property changes sigmoid to look more like a threshold function. Decreasing
             value of this property makes sigmoid to be very smooth (slowly growing from its
             minimum value to its maximum value).</para>
            
             <para>Default value is set to <b>2</b>.</para>
             </remarks>
             
        </member>
        <member name="T:BestCS.Neuro.ActivationFunctions.GaussianFunction">
             <summary>
               Gaussian stochastic activation function.
             </summary>
             
             <remarks>
             <para>
               The Gaussian activation function can be used to create <see cref="T:BestCS.Neuro.Neurons.StochasticNeuron">
               Stochastic Neurons</see>, which can in turn be used to create <see cref="T:BestCS.Neuro.Networks.DeepBeliefNetwork">
               Deep Belief Networks</see> and <see cref="T:BestCS.Neuro.Networks.RestrictedBoltzmannMachine">Restricted Boltzmann
               Machines</see>. In contrast to the <see cref="T:BestCS.Neuro.ActivationFunctions.BernoulliFunction"/>, the Gaussian can be used
               to model continuous inputs in Deep Belief Networks. If, however, the inputs of the problem
               being learned are discrete in nature, the use of a Bernoulli function would be more indicated.</para>
               
             <para>
               The Gaussian activation function is modeled after a <see cref="T:BestCS.Statistics.Distributions.Univariate.NormalDistribution">
               Gaussian (Normal) probability distribution</see>.
             </para>
             
             <para>
               This function assumes output variables have been 
               normalized to have zero mean and unit variance.</para>
             </remarks>
             
             <example>
               <code>
               // Create a Gaussian function with slope alpha = 4.2
               GaussianFunction function = new GaussianFunction(4.2);
               
               // Computes the function output (linear, y = alpha * x)
               double y = function.Function(x: 0.2); // 4.2 * 2 = 0.48
               
               // Draws a sample from a Gaussian distribution with
               // mean given by the function output y (previously 0.48)
               double z = function.Generate(x: 0.4); // (random, between 0 and 1)
               
               // Please note that the above is completely equivalent 
               // to computing the line below (remember, 0.48 == y)
               double w = function.Generate2(y: 0.48); // (random, between 0 and 1)
               
               
               // We can also compute the derivative of the sigmoid function
               double d = function.Derivative(x: 0.2); // 4.2 (the slope)
               
               // Or compute the derivative given the functions' output y
               double e = function.Derivative2(y: 0.2); // 4.2 (the slope)
             </code>
             </example>
             
             <seealso cref="T:BestCS.Neuro.ActivationFunctions.BernoulliFunction"/>
             <seealso cref="T:BestCS.Statistics.Distributions.Univariate.NormalDistribution"/>
             <seealso cref="T:BestCS.Neuro.Networks.DeepBeliefNetwork"/>
            
        </member>
        <member name="M:BestCS.Neuro.ActivationFunctions.GaussianFunction.#ctor(System.Double)">
            <summary>
              Creates a new <see cref="T:BestCS.Neuro.ActivationFunctions.GaussianFunction"/>.
            </summary>
            
            <param name="alpha">The linear slope value. Default is 1.</param>
            
        </member>
        <member name="M:BestCS.Neuro.ActivationFunctions.GaussianFunction.#ctor">
            <summary>
              Creates a new <see cref="T:BestCS.Neuro.ActivationFunctions.GaussianFunction"/>.
            </summary>
            
        </member>
        <member name="M:BestCS.Neuro.ActivationFunctions.GaussianFunction.#ctor(System.Double,BestCS.DoubleRange)">
            <summary>
              Initializes a new instance of the <see cref="T:BestCS.Neuro.ActivationFunctions.GaussianFunction"/> class.
            </summary>
            
        </member>
        <member name="M:BestCS.Neuro.ActivationFunctions.GaussianFunction.Function(System.Double)">
             <summary>
             Calculates function value.
             </summary>
            
             <param name="x">Function input value.</param>
             
             <returns>Function output value, <i>f(x)</i>.</returns>
            
             <remarks>The method calculates function value at point <paramref name="x"/>.</remarks>
            
        </member>
        <member name="M:BestCS.Neuro.ActivationFunctions.GaussianFunction.Generate(System.Double)">
            <summary>
              Samples a value from the function given a input value.
            </summary>
            
            <param name="x">Function input value.</param>
            
            <returns>
              Draws a random value from the function.
            </returns>
            
        </member>
        <member name="M:BestCS.Neuro.ActivationFunctions.GaussianFunction.Generate2(System.Double)">
            <summary>
              Samples a value from the function given a function output value.
            </summary>
            
            <param name="y">Function output value - the value, which was obtained
            with the help of <see cref="M:BestCS.Neuro.ActivationFunctions.GaussianFunction.Function(System.Double)"/> method.</param>
            
            <returns>
              Draws a random value from the function.
            </returns>
            
        </member>
        <member name="M:BestCS.Neuro.ActivationFunctions.GaussianFunction.Derivative(System.Double)">
             <summary>
             Calculates function derivative.
             </summary>
             
             <param name="x">Function input value.</param>
             
             <returns>Function derivative, <i>f'(x)</i>.</returns>
             
             <remarks>The method calculates function derivative at point <paramref name="x"/>.</remarks>
            
        </member>
        <member name="M:BestCS.Neuro.ActivationFunctions.GaussianFunction.Derivative2(System.Double)">
            <summary>
            Calculates function derivative.
            </summary>
            
            <param name="y">Function output value - the value, which was obtained
            with the help of <see cref="M:BestCS.Neuro.ActivationFunctions.GaussianFunction.Function(System.Double)"/> method.</param>
            
            <returns>Function derivative, <i>f'(x)</i>.</returns>
            
            <remarks><para>The method calculates the same derivative value as the
            <see cref="M:BestCS.Neuro.ActivationFunctions.GaussianFunction.Derivative(System.Double)"/> method, but it takes not the input <b>x</b> value
            itself, but the function value, which was calculated previously with
            the help of <see cref="M:BestCS.Neuro.ActivationFunctions.GaussianFunction.Function(System.Double)"/> method.</para>
            
            <para><note>Some applications require as function value, as derivative value,
            so they can save the amount of calculations using this method to calculate derivative.</note></para>
            </remarks>
            
        </member>
        <member name="P:BestCS.Neuro.ActivationFunctions.GaussianFunction.Random">
            <summary>
              Gets or sets the class-wide  
              Gaussian random generator.
            </summary>
            
        </member>
        <member name="P:BestCS.Neuro.ActivationFunctions.GaussianFunction.Alpha">
            <summary>
            Linear slope value.
            </summary>
            
            <remarks>
              <para>Default value is set to <b>1</b>.</para>
            </remarks>
            
        </member>
        <member name="P:BestCS.Neuro.ActivationFunctions.GaussianFunction.Range">
             <summary>
               Function output range.
             </summary>
            
             <remarks>
               <para>Default value is set to [-1;+1]</para>
             </remarks>
            
        </member>
        <member name="T:BestCS.Neuro.IdentityFunction">
            <summary>
              Identity activation function.
            </summary>
            
            <remarks>
              The identity activation function is given by <c>f(x) = x</c>,
              meaning it simply repasses the neuronal summation output to
              further neurons untouched. 
            </remarks>
            
        </member>
        <member name="M:BestCS.Neuro.IdentityFunction.#ctor">
            <summary>
              Creates a new identity activation function.
            </summary>
            
        </member>
        <member name="M:BestCS.Neuro.IdentityFunction.Function(System.Double)">
             <summary>
               Calculates function value.
             </summary>
            
             <param name="x">Function input value.</param>
             
             <returns>Function output value, <i>f(x)</i>.</returns>
            
             <remarks>The method calculates function value at point <paramref name="x"/>.</remarks>
            
        </member>
        <member name="M:BestCS.Neuro.IdentityFunction.Derivative(System.Double)">
             <summary>
               Calculates function derivative.
             </summary>
             
             <param name="x">Function input value.</param>
             
             <returns>Function derivative, <i>f'(x)</i>.</returns>
             
             <remarks>The method calculates function derivative at point <paramref name="x"/>.</remarks>
            
        </member>
        <member name="M:BestCS.Neuro.IdentityFunction.Derivative2(System.Double)">
            <summary>
            Calculates function derivative.
            </summary>
            
            <param name="y">Function output value - the value, which was obtained
            with the help of <see cref="M:BestCS.Neuro.IdentityFunction.Function(System.Double)"/> method.</param>
            
            <returns>Function derivative, <i>f'(x)</i>.</returns>
            
            <remarks><para>The method calculates the same derivative value as the
            <see cref="M:BestCS.Neuro.IdentityFunction.Derivative(System.Double)"/> method, but it takes not the input <b>x</b> value
            itself, but the function value, which was calculated previously with
            the help of <see cref="M:BestCS.Neuro.IdentityFunction.Function(System.Double)"/> method.</para>
            
            <para><note>Some applications require as function value, as derivative value,
            so they can save the amount of calculations using this method to calculate derivative.</note></para>
            </remarks>
            
        </member>
        <member name="T:BestCS.Neuro.LinearFunction">
             <summary>
               Linear activation function.
             </summary>
            
             <remarks>
               <para>This class implements a linear activation function bounded
               in the interval (a,b), as given by the piecewise formula:</para>
             
               <code lang="none">
               f(x) = alpha*x, if a > x*alpha > b
               f(x) = a,       if a > x*alpha;
               f(x) = b,       if     x*alpha > b;
               </code>
               
             <para>
               In which, by default, a = -1 and b = +1.</para>
             
             <para>
               This function is continuous only in the interval (a/alpha, b/alpha). This is similar
               to the threshold function but with a linear growth component. If alpha is set to a 
               very high value (such as infinity), the function behaves as a threshold function.
             </para>
             
             <para>The output range of the function can be set to an arbitrary
             value. The default output range is <b>[-1, +1]</b>.</para>
             
             </remarks>
            
        </member>
        <member name="M:BestCS.Neuro.LinearFunction.#ctor(System.Double)">
            <summary>
              Initializes a new instance of the <see cref="T:BestCS.Neuro.LinearFunction"/> class.
            </summary>
            
        </member>
        <member name="M:BestCS.Neuro.LinearFunction.#ctor(BestCS.DoubleRange)">
            <summary>
              Initializes a new instance of the <see cref="T:BestCS.Neuro.LinearFunction"/> class.
            </summary>
            
        </member>
        <member name="M:BestCS.Neuro.LinearFunction.#ctor(System.Double,BestCS.DoubleRange)">
            <summary>
              Initializes a new instance of the <see cref="T:BestCS.Neuro.LinearFunction"/> class.
            </summary>
            
        </member>
        <member name="M:BestCS.Neuro.LinearFunction.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:BestCS.Neuro.LinearFunction"/> class.
            </summary>
            
        </member>
        <member name="M:BestCS.Neuro.LinearFunction.Function(System.Double)">
             <summary>
               Calculates function value.
             </summary>
            
             <param name="x">Function input value.</param>
             
             <returns>Function output value, <i>f(x)</i>.</returns>
            
             <remarks>The method calculates function value at point <paramref name="x"/>.</remarks>
            
        </member>
        <member name="M:BestCS.Neuro.LinearFunction.Derivative(System.Double)">
             <summary>
               Calculates function derivative.
             </summary>
             
             <param name="x">Function input value.</param>
             
             <returns>Function derivative, <i>f'(x)</i>.</returns>
             
             <remarks>The method calculates function derivative at point <paramref name="x"/>.</remarks>
            
        </member>
        <member name="M:BestCS.Neuro.LinearFunction.Derivative2(System.Double)">
            <summary>
            Calculates function derivative.
            </summary>
            
            <param name="y">Function output value - the value, which was obtained
            with the help of <see cref="M:BestCS.Neuro.LinearFunction.Function(System.Double)"/> method.</param>
            
            <returns>Function derivative, <i>f'(x)</i>.</returns>
            
            <remarks><para>The method calculates the same derivative value as the
            <see cref="M:BestCS.Neuro.LinearFunction.Derivative(System.Double)"/> method, but it takes not the input <b>x</b> value
            itself, but the function value, which was calculated previously with
            the help of <see cref="M:BestCS.Neuro.LinearFunction.Function(System.Double)"/> method.</para>
            
            <para><note>Some applications require as function value, as derivative value,
            so they can save the amount of calculations using this method to calculate derivative.</note></para>
            </remarks>
            
        </member>
        <member name="P:BestCS.Neuro.LinearFunction.Alpha">
            <summary>
            Linear slope value.
            </summary>
            
            <remarks>
              <para>Default value is set to <b>1</b>.</para>
            </remarks>
            
        </member>
        <member name="P:BestCS.Neuro.LinearFunction.Range">
             <summary>
               Function output range.
             </summary>
            
             <remarks>
               <para>Default value is set to [-1;+1]</para>
             </remarks>
            
        </member>
        <member name="T:BestCS.Neuro.RectifiedLinearFunction">
             <summary>
               Rectified linear activation function.
             </summary>
            
             <remarks>
               <para>This class implements a rectified linear activation 
               function as given by the piecewise formula:</para>
             
               <code lang="none">
               f(x) = 0, if x > 0
               f(x) = x, otherwise
               </code>
               
             <para>
               This function is non-differentiable at zero.
             </para>
             </remarks>
            
        </member>
        <member name="M:BestCS.Neuro.RectifiedLinearFunction.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:BestCS.Neuro.RectifiedLinearFunction"/> class.
            </summary>
            
        </member>
        <member name="M:BestCS.Neuro.RectifiedLinearFunction.Function(System.Double)">
             <summary>
               Calculates function value.
             </summary>
            
             <param name="x">Function input value.</param>
             
             <returns>Function output value, <i>f(x)</i>.</returns>
            
             <remarks>The method calculates function value at point <paramref name="x"/>.</remarks>
            
        </member>
        <member name="M:BestCS.Neuro.RectifiedLinearFunction.Derivative(System.Double)">
             <summary>
               Calculates function derivative.
             </summary>
             
             <param name="x">Function input value.</param>
             
             <returns>Function derivative, <i>f'(x)</i>.</returns>
             
             <remarks>The method calculates function derivative at point <paramref name="x"/>.</remarks>
            
        </member>
        <member name="M:BestCS.Neuro.RectifiedLinearFunction.Derivative2(System.Double)">
            <summary>
            Calculates function derivative.
            </summary>
            
            <param name="y">Function output value - the value, which was obtained
            with the help of <see cref="M:BestCS.Neuro.RectifiedLinearFunction.Function(System.Double)"/> method.</param>
            
            <returns>Function derivative, <i>f'(x)</i>.</returns>
            
            <remarks><para>The method calculates the same derivative value as the
            <see cref="M:BestCS.Neuro.RectifiedLinearFunction.Derivative(System.Double)"/> method, but it takes not the input <b>x</b> value
            itself, but the function value, which was calculated previously with
            the help of <see cref="M:BestCS.Neuro.RectifiedLinearFunction.Function(System.Double)"/> method.</para>
            
            <para><note>Some applications require as function value, as derivative value,
            so they can save the amount of calculations using this method to calculate derivative.</note></para>
            </remarks>
            
        </member>
        <member name="T:BestCS.Neuro.SigmoidFunction">
             <summary>
             Sigmoid activation function.
             </summary>
            
             <remarks><para>The class represents sigmoid activation function with
             the next expression:
             <code lang="none">
                            1
             f(x) = ------------------
                    1 + exp(-alpha * x)
            
                       alpha * exp(-alpha * x )
             f'(x) = ---------------------------- = alpha * f(x) * (1 - f(x))
                       (1 + exp(-alpha * x))^2
             </code>
             </para>
            
             <para>Output range of the function: <b>[0, 1]</b>.</para>
             
             <para>Functions graph:</para>
             <img src="img/neuro/sigmoid.bmp" width="242" height="172" />
             </remarks>
             
        </member>
        <member name="M:BestCS.Neuro.SigmoidFunction.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Neuro.SigmoidFunction"/> class.
            </summary>
        </member>
        <member name="M:BestCS.Neuro.SigmoidFunction.#ctor(System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Neuro.SigmoidFunction"/> class.
            </summary>
            
            <param name="alpha">Sigmoid's alpha value.</param>
            
        </member>
        <member name="M:BestCS.Neuro.SigmoidFunction.Function(System.Double)">
             <summary>
             Calculates function value.
             </summary>
            
             <param name="x">Function input value.</param>
             
             <returns>Function output value, <i>f(x)</i>.</returns>
            
             <remarks>The method calculates function value at point <paramref name="x"/>.</remarks>
            
        </member>
        <member name="M:BestCS.Neuro.SigmoidFunction.Derivative(System.Double)">
             <summary>
             Calculates function derivative.
             </summary>
             
             <param name="x">Function input value.</param>
             
             <returns>Function derivative, <i>f'(x)</i>.</returns>
             
             <remarks>The method calculates function derivative at point <paramref name="x"/>.</remarks>
            
        </member>
        <member name="M:BestCS.Neuro.SigmoidFunction.Derivative2(System.Double)">
            <summary>
            Calculates function derivative.
            </summary>
            
            <param name="y">Function output value - the value, which was obtained
            with the help of <see cref="M:BestCS.Neuro.SigmoidFunction.Function(System.Double)"/> method.</param>
            
            <returns>Function derivative, <i>f'(x)</i>.</returns>
            
            <remarks><para>The method calculates the same derivative value as the
            <see cref="M:BestCS.Neuro.SigmoidFunction.Derivative(System.Double)"/> method, but it takes not the input <b>x</b> value
            itself, but the function value, which was calculated previously with
            the help of <see cref="M:BestCS.Neuro.SigmoidFunction.Function(System.Double)"/> method.</para>
            
            <para><note>Some applications require as function value, as derivative value,
            so they can save the amount of calculations using this method to calculate derivative.</note></para>
            </remarks>
            
        </member>
        <member name="M:BestCS.Neuro.SigmoidFunction.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            
            <returns>
            A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:BestCS.Neuro.SigmoidFunction.Alpha">
             <summary>
             Sigmoid's alpha value.
             </summary>
             
             <remarks><para>The value determines steepness of the function. Increasing value of
             this property changes sigmoid to look more like a threshold function. Decreasing
             value of this property makes sigmoid to be very smooth (slowly growing from its
             minimum value to its maximum value).</para>
            
             <para>Default value is set to <b>2</b>.</para>
             </remarks>
             
        </member>
        <member name="T:BestCS.Neuro.ThresholdFunction">
             <summary>
             Threshold activation function.
             </summary>
            
             <remarks><para>The class represents threshold activation function with
             the next expression:
             <code lang="none">
             f(x) = 1, if x >= 0, otherwise 0
             </code>
             </para>
             
             <para>Output range of the function: <b>[0, 1]</b>.</para>
             
             <para>Functions graph:</para>
             <img src="img/neuro/threshold.bmp" width="242" height="172" />
             </remarks>
            
        </member>
        <member name="M:BestCS.Neuro.ThresholdFunction.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Neuro.ThresholdFunction"/> class.
            </summary>
        </member>
        <member name="M:BestCS.Neuro.ThresholdFunction.Function(System.Double)">
             <summary>
             Calculates function value.
             </summary>
            
             <param name="x">Function input value.</param>
             
             <returns>Function output value, <i>f(x)</i>.</returns>
            
             <remarks>The method calculates function value at point <paramref name="x"/>.</remarks>
            
        </member>
        <member name="M:BestCS.Neuro.ThresholdFunction.Derivative(System.Double)">
             <summary>
             Calculates function derivative (not supported).
             </summary>
             
             <param name="x">Input value.</param>
             
             <returns>Always returns 0.</returns>
             
             <remarks><para><note>The method is not supported, because it is not possible to
             calculate derivative of the function.</note></para></remarks>
            
        </member>
        <member name="M:BestCS.Neuro.ThresholdFunction.Derivative2(System.Double)">
            <summary>
            Calculates function derivative (not supported).
            </summary>
            
            <param name="y">Input value.</param>
            
            <returns>Always returns 0.</returns>
            
            <remarks><para><note>The method is not supported, because it is not possible to
            calculate derivative of the function.</note></para></remarks>
            
        </member>
        <member name="M:BestCS.Neuro.ThresholdFunction.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            
            <returns>
            A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="T:BestCS.Neuro.GaussianWeights">
            <summary>
              Gaussian weight initialization.
            </summary>
            
        </member>
        <member name="M:BestCS.Neuro.GaussianWeights.#ctor(BestCS.Neuro.ActivationNetwork,System.Double)">
            <summary>
              Constructs a new Gaussian Weight initialization.
            </summary>
            
            <param name="network">The activation network whose weights will be initialized.</param>
            <param name="stdDev">The standard deviation to be used. Common values lie in the 0.001-
            0.1 range. Default is 0.1.</param>
            
        </member>
        <member name="M:BestCS.Neuro.GaussianWeights.Randomize">
            <summary>
              Randomizes (initializes) the weights of
              the network using a Gaussian distribution.
            </summary>
            
        </member>
        <member name="M:BestCS.Neuro.GaussianWeights.Randomize(System.Int32)">
            <summary>
              Randomizes (initializes) the weights of
              the network using a Gaussian distribution.
            </summary>
            
        </member>
        <member name="P:BestCS.Neuro.GaussianWeights.UpdateThresholds">
            <summary>
              Gets ors sets whether the initialization
              should update neurons thresholds (biases)
            </summary>
            
        </member>
        <member name="T:BestCS.Neuro.NguyenWidrow">
            <summary>
             Nguyen-Widrow weight initialization.
            </summary>
            
            <remarks>
            <para>The Nguyen-Widrow initialization algorithm chooses values in
            order to distribute the active region of each neuron in the layer
            approximately evenly across the layers' input space.</para>
            
            <para>The values contain a degree of randomness, so they are not the
            same each time this function is called.</para> 
            </remarks>
            
        </member>
        <member name="M:BestCS.Neuro.NguyenWidrow.#ctor(BestCS.Neuro.ActivationNetwork)">
            <summary>
              Constructs a new Nguyen-Widrow Weight initialization.
            </summary>
            
            <param name="network">The activation network whose weights will be initialized.</param>
            
        </member>
        <member name="M:BestCS.Neuro.NguyenWidrow.Randomize(System.Int32)">
            <summary>
              Randomizes (initializes) the weights of
              the network using Nguyen-Widrow method's.
            </summary>
            
        </member>
        <member name="M:BestCS.Neuro.NguyenWidrow.Randomize">
            <summary>
              Randomizes (initializes) the weights of
              the network using a Gaussian distribution.
            </summary>
            
        </member>
        <member name="T:BestCS.Neuro.ActivationLayer">
             <summary>
             Activation layer.
             </summary>
             
             <remarks>Activation layer is a layer of <see cref="T:BestCS.Neuro.ActivationNeuron">activation neurons</see>.
             The layer is usually used in multi-layer neural networks.</remarks>
            
        </member>
        <member name="T:BestCS.Neuro.Layer">
            <summary>
            Base neural layer class.
            </summary>
            
            <remarks>This is a base neural layer class, which represents
            collection of neurons.</remarks>
            
        </member>
        <member name="F:BestCS.Neuro.Layer.inputsCount">
            <summary>
            Layer's inputs count.
            </summary>
        </member>
        <member name="F:BestCS.Neuro.Layer.neuronsCount">
            <summary>
            Layer's neurons count.
            </summary>
        </member>
        <member name="F:BestCS.Neuro.Layer.neurons">
            <summary>
            Layer's neurons.
            </summary>
        </member>
        <member name="F:BestCS.Neuro.Layer.output">
            <summary>
            Layer's output vector.
            </summary>
        </member>
        <member name="M:BestCS.Neuro.Layer.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Neuro.Layer"/> class.
            </summary>
            
            <param name="neuronsCount">Layer's neurons count.</param>
            <param name="inputsCount">Layer's inputs count.</param>
            
            <remarks>Protected contructor, which initializes <see cref="F:BestCS.Neuro.Layer.inputsCount"/>,
            <see cref="F:BestCS.Neuro.Layer.neuronsCount"/> and <see cref="F:BestCS.Neuro.Layer.neurons"/> members.</remarks>
            
        </member>
        <member name="M:BestCS.Neuro.Layer.Compute(System.Double[])">
            <summary>
            Compute output vector of the layer.
            </summary>
            
            <param name="input">Input vector.</param>
            
            <returns>Returns layer's output vector.</returns>
            
            <remarks><para>The actual layer's output vector is determined by neurons,
            which comprise the layer - consists of output values of layer's neurons.
            The output vector is also stored in <see cref="P:BestCS.Neuro.Layer.Output"/> property.</para>
            
            <para><note>The method may be called safely from multiple threads to compute layer's
            output value for the specified input values. However, the value of
            <see cref="P:BestCS.Neuro.Layer.Output"/> property in multi-threaded environment is not predictable,
            since it may hold layer's output computed from any of the caller threads. Multi-threaded
            access to the method is useful in those cases when it is required to improve performance
            by utilizing several threads and the computation is based on the immediate return value
            of the method, but not on layer's output property.</note></para>
            </remarks>
            
        </member>
        <member name="M:BestCS.Neuro.Layer.Randomize">
            <summary>
            Randomize neurons of the layer.
            </summary>
            
            <remarks>Randomizes layer's neurons by calling <see cref="M:BestCS.Neuro.Neuron.Randomize"/> method
            of each neuron.</remarks>
            
        </member>
        <member name="P:BestCS.Neuro.Layer.InputsCount">
            <summary>
            Layer's inputs count.
            </summary>
        </member>
        <member name="P:BestCS.Neuro.Layer.Neurons">
            <summary>
            Layer's neurons.
            </summary>
            
        </member>
        <member name="P:BestCS.Neuro.Layer.Output">
            <summary>
            Layer's output vector.
            </summary>
            
            <remarks><para>The calculation way of layer's output vector is determined by neurons,
            which comprise the layer.</para>
            
            <para><note>The property is not initialized (equals to <see langword="null"/>) until
            <see cref="M:BestCS.Neuro.Layer.Compute(System.Double[])"/> method is called.</note></para>
            </remarks>
            
        </member>
        <member name="M:BestCS.Neuro.ActivationLayer.#ctor(System.Int32,System.Int32,BestCS.Neuro.IActivationFunction)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Neuro.ActivationLayer"/> class.
            </summary>
            
            <param name="neuronsCount">Layer's neurons count.</param>
            <param name="inputsCount">Layer's inputs count.</param>
            <param name="function">Activation function of neurons of the layer.</param>
            
            <remarks>The new layer is randomized (see <see cref="M:BestCS.Neuro.ActivationNeuron.Randomize"/>
            method) after it is created.</remarks>
            
        </member>
        <member name="M:BestCS.Neuro.ActivationLayer.SetActivationFunction(BestCS.Neuro.IActivationFunction)">
            <summary>
            Set new activation function for all neurons of the layer.
            </summary>
            
            <param name="function">Activation function to set.</param>
            
            <remarks><para>The methods sets new activation function for each neuron by setting
            their <see cref="P:BestCS.Neuro.ActivationNeuron.ActivationFunction"/> property.</para></remarks>
            
        </member>
        <member name="T:BestCS.Neuro.DistanceLayer">
            <summary>
            Distance layer.
            </summary>
            
            <remarks>Distance layer is a layer of <see cref="T:BestCS.Neuro.DistanceNeuron">distance neurons</see>.
            The layer is usually a single layer of such networks as Kohonen Self
            Organizing Map, Elastic Net, Hamming Memory Net.</remarks>
            
        </member>
        <member name="M:BestCS.Neuro.DistanceLayer.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Neuro.DistanceLayer"/> class.
            </summary>
            
            <param name="neuronsCount">Layer's neurons count.</param>
            <param name="inputsCount">Layer's inputs count.</param>
            
            <remarks>The new layet is randomized (see <see cref="M:BestCS.Neuro.Neuron.Randomize"/>
            method) after it is created.</remarks>
            
        </member>
        <member name="T:BestCS.Neuro.Layers.StochasticLayer">
            <summary>
              Stochastic Activation Layer.
            </summary>
            
            <remarks>
              This class represents a layer of <see cref="T:BestCS.Neuro.Neurons.StochasticNeuron">stochastic neurons</see>.
            </remarks>
            
        </member>
        <member name="M:BestCS.Neuro.Layers.StochasticLayer.#ctor(System.Int32,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:BestCS.Neuro.Layers.StochasticLayer"/> class.
            </summary>
            
            <param name="neuronsCount">Layer's neurons count.</param>
            <param name="inputsCount">Layer's inputs count.</param>
            
        </member>
        <member name="M:BestCS.Neuro.Layers.StochasticLayer.#ctor(BestCS.Neuro.ActivationFunctions.IStochasticFunction,System.Int32,System.Int32)">
            <summary>
              Initializes a new instance of the <see cref="T:BestCS.Neuro.Layers.StochasticLayer"/> class.
            </summary>
            
            <param name="function">The activation function for the neurons in the layer.</param>
            <param name="neuronsCount">The neurons count.</param>
            <param name="inputsCount">The inputs count.</param>
            
        </member>
        <member name="M:BestCS.Neuro.Layers.StochasticLayer.Compute(System.Double[])">
            <summary>
              Compute output vector of the layer.
            </summary>
            
            <param name="input">Input vector.</param>
            
            <returns>
              Returns layer's output vector.
            </returns>
            
        </member>
        <member name="M:BestCS.Neuro.Layers.StochasticLayer.Generate(System.Double[])">
            <summary>
              Compute probability vector of the layer.
            </summary>
            
            <param name="input">Input vector.</param>
            
            <returns>
              Returns layer's probability vector.
            </returns>
            
        </member>
        <member name="M:BestCS.Neuro.Layers.StochasticLayer.CopyReversedWeightsFrom(BestCS.Neuro.Layers.StochasticLayer)">
            <summary>
              Copy the weights of another layer in reversed order. This
              can be used to update visible layers from hidden layers and
              vice-versa.
            </summary>
            
            <param name="layer">The layer to copy the weights from.</param>
            
        </member>
        <member name="P:BestCS.Neuro.Layers.StochasticLayer.Neurons">
            <summary>
              Gets the layer's neurons.
            </summary>
            
        </member>
        <member name="P:BestCS.Neuro.Layers.StochasticLayer.Sample">
            <summary>
              Gets the layer's sample values generated in the last
              call of any of the <see cref="M:BestCS.Neuro.Layers.StochasticLayer.Generate(System.Double[])"/> methods.
            </summary>
            
        </member>
        <member name="T:BestCS.Neuro.Learning.BackPropagationLearning">
            <summary>
            Back propagation learning algorithm.
            </summary>
            
            <remarks><para>The class implements back propagation learning algorithm,
            which is widely used for training multi-layer neural networks with
            continuous activation functions.</para>
            
            <para>Sample usage (training network to calculate XOR function):</para>
            <code>
            // initialize input and output values
            double[][] input = new double[4][] {
                new double[] {0, 0}, new double[] {0, 1},
                new double[] {1, 0}, new double[] {1, 1}
            };
            double[][] output = new double[4][] {
                new double[] {0}, new double[] {1},
                new double[] {1}, new double[] {0}
            };
            // create neural network
            ActivationNetwork   network = new ActivationNetwork(
                SigmoidFunction( 2 ),
                2, // two inputs in the network
                2, // two neurons in the first layer
                1 ); // one neuron in the second layer
            // create teacher
            BackPropagationLearning teacher = new BackPropagationLearning( network );
            // loop
            while ( !needToStop )
            {
                // run epoch of learning procedure
                double error = teacher.RunEpoch( input, output );
                // check error value to see if we need to stop
                // ...
            }
            </code>
            </remarks>
            
            <seealso cref="T:BestCS.Neuro.Learning.EvolutionaryLearning"/>
            
        </member>
        <member name="T:BestCS.Neuro.Learning.ISupervisedLearning">
            <summary>
            Supervised learning interface.
            </summary>
            
            <remarks><para>The interface describes methods, which should be implemented
            by all supervised learning algorithms. Supervised learning is such
            type of learning algorithms, where system's desired output is known on
            the learning stage. So, given sample input values and desired outputs,
            system should adopt its internals to produce correct (or close to correct)
            result after the learning step is complete.</para></remarks>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.ISupervisedLearning.Run(System.Double[],System.Double[])">
            <summary>
            Runs learning iteration.
            </summary>
            
            <param name="input">Input vector.</param>
            <param name="output">Desired output vector.</param>
            
            <returns>Returns learning error.</returns>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.ISupervisedLearning.RunEpoch(System.Double[][],System.Double[][])">
            <summary>
            Runs learning epoch.
            </summary>
            
            <param name="input">Array of input vectors.</param>
            <param name="output">Array of output vectors.</param>
            
            <returns>Returns sum of learning errors.</returns>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.BackPropagationLearning.#ctor(BestCS.Neuro.ActivationNetwork)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Neuro.Learning.BackPropagationLearning"/> class.
            </summary>
            
            <param name="network">Network to teach.</param>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.BackPropagationLearning.Run(System.Double[],System.Double[])">
             <summary>
             Runs learning iteration.
             </summary>
             
             <param name="input">Input vector.</param>
             <param name="output">Desired output vector.</param>
             
             <returns>Returns squared error (difference between current network's output and
             desired output) divided by 2.</returns>
             
             <remarks><para>Runs one learning iteration and updates neuron's
             weights.</para></remarks>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.BackPropagationLearning.RunEpoch(System.Double[][],System.Double[][])">
            <summary>
            Runs learning epoch.
            </summary>
            
            <param name="input">Array of input vectors.</param>
            <param name="output">Array of output vectors.</param>
            
            <returns>Returns summary learning error for the epoch. See <see cref="M:BestCS.Neuro.Learning.BackPropagationLearning.Run(System.Double[],System.Double[])"/>
            method for details about learning error calculation.</returns>
            
            <remarks><para>The method runs one learning epoch, by calling <see cref="M:BestCS.Neuro.Learning.BackPropagationLearning.Run(System.Double[],System.Double[])"/> method
            for each vector provided in the <paramref name="input"/> array.</para></remarks>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.BackPropagationLearning.CalculateError(System.Double[])">
            <summary>
            Calculates error values for all neurons of the network.
            </summary>
            
            <param name="desiredOutput">Desired output vector.</param>
            
            <returns>Returns summary squared error of the last layer divided by 2.</returns>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.BackPropagationLearning.CalculateUpdates(System.Double[])">
            <summary>
            Calculate weights updates.
            </summary>
            
            <param name="input">Network's input vector.</param>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.BackPropagationLearning.UpdateNetwork">
            <summary>
            Update network'sweights.
            </summary>
            
        </member>
        <member name="P:BestCS.Neuro.Learning.BackPropagationLearning.LearningRate">
             <summary>
             Learning rate, [0, 1].
             </summary>
             
             <remarks><para>The value determines speed of learning.</para>
             
             <para>Default value equals to <b>0.1</b>.</para>
             </remarks>
            
        </member>
        <member name="P:BestCS.Neuro.Learning.BackPropagationLearning.Momentum">
            <summary>
            Momentum, [0, 1].
            </summary>
            
            <remarks><para>The value determines the portion of previous weight's update
            to use on current iteration. Weight's update values are calculated on
            each iteration depending on neuron's error. The momentum specifies the amount
            of update to use from previous iteration and the amount of update
            to use from current iteration. If the value is equal to 0.1, for example,
            then 0.1 portion of previous update and 0.9 portion of current update are used
            to update weight's value.</para>
            
            <para>Default value equals to <b>0.0</b>.</para>
            </remarks>
            
        </member>
        <member name="T:BestCS.Neuro.Learning.ContrastiveDivergenceLearning">
            <summary>
              Contrastive Divergence learning algorithm for Restricted Boltzmann Machines.
            </summary>
            
        </member>
        <member name="T:BestCS.Neuro.Learning.IUnsupervisedLearning">
            <summary>
            Unsupervised learning interface.
            </summary>
            
            <remarks><para>The interface describes methods, which should be implemented
            by all unsupervised learning algorithms. Unsupervised learning is such
            type of learning algorithms, where system's desired output is not known on
            the learning stage. Given sample input values, it is expected, that
            system will organize itself in the way to find similarities betweed provided
            samples.</para></remarks>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.IUnsupervisedLearning.Run(System.Double[])">
            <summary>
            Runs learning iteration.
            </summary>
            
            <param name="input">Input vector.</param>
            
            <returns>Returns learning error.</returns>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.IUnsupervisedLearning.RunEpoch(System.Double[][])">
             <summary>
             Runs learning epoch.
             </summary>
             
             <param name="input">Array of input vectors.</param>
            
             <returns>Returns sum of learning errors.</returns>
             
        </member>
        <member name="M:BestCS.Neuro.Learning.ContrastiveDivergenceLearning.#ctor(BestCS.Neuro.Networks.RestrictedBoltzmannMachine)">
            <summary>
              Creates a new <see cref="T:BestCS.Neuro.Learning.ContrastiveDivergenceLearning"/> algorithm.
            </summary>
            
            <param name="network">The network to be trained.</param>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.ContrastiveDivergenceLearning.#ctor(BestCS.Neuro.Layers.StochasticLayer,BestCS.Neuro.Layers.StochasticLayer)">
            <summary>
              Creates a new <see cref="T:BestCS.Neuro.Learning.ContrastiveDivergenceLearning"/> algorithm.
            </summary>
            
            <param name="hidden">The hidden layer of the hidden-visible layer pair to be trained.</param>
            <param name="visible">The visible layer of the hidden-visible layer pair to be trained.</param>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.ContrastiveDivergenceLearning.Run(System.Double[])">
            <summary>
              Not supported.
            </summary>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.ContrastiveDivergenceLearning.RunEpoch(System.Double[][])">
            <summary>
              Runs learning epoch.
            </summary>
            
            <param name="input">Array of input vectors.</param>
            
            <returns>
              Returns sum of learning errors.
            </returns>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.ContrastiveDivergenceLearning.ComputeError(System.Double[][])">
            <summary>
              Computes the reconstruction error of the current layer.
            </summary>
            
            <param name="input">Array of input vectors.</param>
            
            <returns>
              Returns sum of learning errors.
            </returns>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.ContrastiveDivergenceLearning.Dispose">
            <summary>
              Performs application-defined tasks associated with 
              freeing, releasing, or resetting unmanaged resources.
            </summary>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.ContrastiveDivergenceLearning.Dispose(System.Boolean)">
            <summary>
              Releases unmanaged and - optionally - managed resources
            </summary>
            
            <param name="disposing"><c>true</c> to release both managed and unmanaged
            resources; <c>false</c> to release only unmanaged resources.</param>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.ContrastiveDivergenceLearning.Finalize">
            <summary>
              Releases unmanaged resources and performs other cleanup operations before the
              <see cref="T:BestCS.Neuro.Learning.ContrastiveDivergenceLearning"/> is reclaimed by garbage collection.
            </summary>
            
        </member>
        <member name="P:BestCS.Neuro.Learning.ContrastiveDivergenceLearning.LearningRate">
            <summary>
              Gets or sets the learning rate of the
              learning algorithm. Default is 0.1.
            </summary>
            
        </member>
        <member name="P:BestCS.Neuro.Learning.ContrastiveDivergenceLearning.Momentum">
            <summary>
              Gets or sets the momentum term of the
              learning algorithm. Default is 0.9.
            </summary>
            
        </member>
        <member name="P:BestCS.Neuro.Learning.ContrastiveDivergenceLearning.Decay">
            <summary>
              Gets or sets the Weight Decay constant
              of the learning algorithm. Default is 0.01.
            </summary>
            
        </member>
        <member name="T:BestCS.Neuro.Learning.RestrictedBoltzmannNetworkLearningConfigurationFunction">
            <summary>
              Delegate used to configure and create layer-specific learning algorithms.
            </summary>
            
            <param name="hiddenLayer">The hidden layer being trained.</param>
            <param name="visibleLayer">The visible layer being trained.</param>
            <param name="index">The layer-pair index in the deep network.</param>
            
            <returns>
              The function should return an instance of the algorithm 
              which should be used to train the pair of layers.
            </returns>
            
        </member>
        <member name="T:BestCS.Neuro.Learning.DeepBeliefNetworkLearning">
            <summary>
              Deep Belief Network learning algorithm.
            </summary>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.DeepBeliefNetworkLearning.#ctor(BestCS.Neuro.Networks.DeepBeliefNetwork)">
            <summary>
              Creates a new <see cref="T:BestCS.Neuro.Learning.DeepBeliefNetworkLearning"/> algorithm.
            </summary>
            
            <param name="network">The network to be trained.</param>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.DeepBeliefNetworkLearning.GetLayerInput(System.Double[][])">
            <summary>
              Gets the learning data needed to train the <see cref="P:BestCS.Neuro.Learning.DeepBeliefNetworkLearning.LayerIndex">currently
              selected layer</see>. The return of this function should then be passed to
              <see cref="M:BestCS.Neuro.Learning.DeepBeliefNetworkLearning.RunEpoch(System.Double[][])"/> to actually run a learning epoch.
            </summary>
            
            <param name="input">The batch of input data.</param>
            
            <returns>The learning data for the current layer.</returns>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.DeepBeliefNetworkLearning.GetLayerInput(System.Double[][][])">
            <summary>
              Gets the learning data needed to train the <see cref="P:BestCS.Neuro.Learning.DeepBeliefNetworkLearning.LayerIndex">currently
              selected layer</see>. The return of this function should then be passed to
              <see cref="M:BestCS.Neuro.Learning.DeepBeliefNetworkLearning.RunEpoch(System.Double[][])"/> to actually run a learning epoch.
            </summary>
            
            <param name="batches">The mini-batches of input data.</param>
            
            <returns>The learning data for the current layer.</returns>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.DeepBeliefNetworkLearning.GetLayerAlgorithm(System.Int32)">
            <summary>
              Gets the <see cref="T:BestCS.Neuro.Learning.IUnsupervisedLearning">unsupervised 
              learning algorithm</see> allocated for the given layer.
            </summary>
            
            <param name="layerIndex">The index of the layer to get the algorithm for.</param>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.DeepBeliefNetworkLearning.Run(System.Double[])">
            <summary>
              Runs a single learning iteration.
            </summary>
            
            <param name="input">A single input vector.</param>
            
            <returns>
              Returns the learning error after the iteration.
            </returns>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.DeepBeliefNetworkLearning.RunEpoch(System.Double[][])">
            <summary>
              Runs a single batch epoch
              of the learning algorithm.
            </summary>
            
            <param name="input">Array of input vectors.</param>
            
            <returns>
              Returns sum of learning errors.
            </returns>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.DeepBeliefNetworkLearning.RunEpoch(System.Double[][][])">
            <summary>
              Runs a single learning epoch using
              multiple mini-batches to improve speed.
            </summary>
            
            <param name="batches">Array of input batches.</param>
            
            <returns>
              Returns sum of learning errors.
            </returns>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.DeepBeliefNetworkLearning.ComputeError(System.Double[][])">
            <summary>
              Computes the reconstruction error for 
              a given set of input values.
            </summary>
            
            <param name="inputs">The input values.</param>
            
            <returns>The squared reconstruction error.</returns>
            
        </member>
        <member name="P:BestCS.Neuro.Learning.DeepBeliefNetworkLearning.Algorithm">
            <summary>
              Gets or sets the configuration function used
              to specify and create the learning algorithms
              for each of the layers of the deep network.
            </summary>
            
        </member>
        <member name="P:BestCS.Neuro.Learning.DeepBeliefNetworkLearning.LayerIndex">
            <summary>
              Gets or sets the current layer index being
              trained by the deep learning algorithm.
            </summary>
            
        </member>
        <member name="T:BestCS.Neuro.Learning.ActivationNetworkLearningConfigurationFunction">
            <summary>
              Delegate used to configure and create layer-specific learning algorithms.
            </summary>
            
            <param name="network">The network layer being trained.</param>
            <param name="index">The index of the layer in the deep network.</param>
            
            <returns>
              The function should return an instance of the algorithm 
              which should be used to train the network.
            </returns>
            
        </member>
        <member name="T:BestCS.Neuro.Learning.DeepNeuralNetworkLearning">
            <summary>
              Deep Neural Network learning algorithm.
            </summary>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.DeepNeuralNetworkLearning.#ctor(BestCS.Neuro.Networks.DeepBeliefNetwork)">
            <summary>
              Creates a new <see cref="T:BestCS.Neuro.Learning.DeepBeliefNetworkLearning"/> algorithm.
            </summary>
            
            <param name="network">The network to be trained.</param>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.DeepNeuralNetworkLearning.GetLayerInput(System.Double[][])">
            <summary>
              Gets the learning data needed to train the <see cref="P:BestCS.Neuro.Learning.DeepNeuralNetworkLearning.LayerIndex">currently
              selected layer</see>. The return of this function should then be passed to
              <see cref="M:BestCS.Neuro.Learning.DeepNeuralNetworkLearning.RunEpoch(System.Double[][],System.Double[][])"/> to actually run a learning epoch.
            </summary>
            
            <param name="input">The batch of input data.</param>
            
            <returns>The learning data for the current layer.</returns>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.DeepNeuralNetworkLearning.GetLayerInput(System.Double[][][])">
            <summary>
              Gets the learning data needed to train the <see cref="P:BestCS.Neuro.Learning.DeepNeuralNetworkLearning.LayerIndex">currently
              selected layer</see>. The return of this function should then be passed to
              <see cref="M:BestCS.Neuro.Learning.DeepNeuralNetworkLearning.RunEpoch(System.Double[][],System.Double[][])"/> to actually run a learning epoch.
            </summary>
            
            <param name="batches">The mini-batches of input data.</param>
            
            <returns>The learning data for the current layer.</returns>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.DeepNeuralNetworkLearning.Run(System.Double[],System.Double[])">
            <summary>
              Runs a single learning iteration.
            </summary>
            
            <param name="input">A single input vector.</param>
            <param name="output">The corresponding output vector.</param>
            
            <returns>
              Returns the learning error after the iteration.
            </returns>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.DeepNeuralNetworkLearning.RunEpoch(System.Double[][],System.Double[][])">
            <summary>
              Runs a single batch epoch
              of the learning algorithm.
            </summary>
            
            <param name="input">Array of input vectors.</param>
            <param name="output">Array of corresponding output vectors.</param>
            
            <returns>
              Returns sum of learning errors.
            </returns>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.DeepNeuralNetworkLearning.RunEpoch(System.Double[][][],System.Double[][][])">
            <summary>
              Runs a single learning epoch using
              multiple mini-batches to improve speed.
            </summary>
            
            <param name="inputBatches">Array of input batches.</param>
            <param name="outputBatches">Array of corresponding output batches.</param>
            
            <returns>
              Returns sum of learning errors.
            </returns>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.DeepNeuralNetworkLearning.ComputeError(System.Double[][],System.Double[][])">
            <summary>
              Computes the reconstruction error for 
              a given set of input values.
            </summary>
            
            <param name="inputs">The input values.</param>
            <param name="outputs">The corresponding output values.</param>
            
            <returns>The squared reconstruction error.</returns>
            
        </member>
        <member name="P:BestCS.Neuro.Learning.DeepNeuralNetworkLearning.Algorithm">
            <summary>
              Gets or sets the configuration function used
              to specify and create the learning algorithms
              for each of the layers of the deep network.
            </summary>
            
        </member>
        <member name="P:BestCS.Neuro.Learning.DeepNeuralNetworkLearning.LayerIndex">
            <summary>
              Gets or sets the current layer index being
              trained by the deep learning algorithm.
            </summary>
            
        </member>
        <member name="P:BestCS.Neuro.Learning.DeepNeuralNetworkLearning.LayerCount">
            <summary>
              Gets or sets the number of layers, starting at <see cref="P:BestCS.Neuro.Learning.DeepNeuralNetworkLearning.LayerIndex"/>
              to be trained by the deep learning algorithm.
            </summary>
            
        </member>
        <member name="T:BestCS.Neuro.Learning.DeltaRuleLearning">
            <summary>
            Delta rule learning algorithm.
            </summary>
            
            <remarks><para>This learning algorithm is used to train one layer neural
            network of <see cref="T:BestCS.Neuro.ActivationNeuron">Activation Neurons</see>
            with continuous activation function, see <see cref="T:BestCS.Neuro.SigmoidFunction"/>
            for example.</para>
            
            <para>See information about <a href="http://en.wikipedia.org/wiki/Delta_rule">delta rule</a>
            learning algorithm.</para>
            </remarks>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.DeltaRuleLearning.#ctor(BestCS.Neuro.ActivationNetwork)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Neuro.Learning.DeltaRuleLearning"/> class.
            </summary>
            
            <param name="network">Network to teach.</param>
            
            <exception cref="T:System.ArgumentException">Invalid nuaral network. It should have one layer only.</exception>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.DeltaRuleLearning.Run(System.Double[],System.Double[])">
             <summary>
             Runs learning iteration.
             </summary>
             
             <param name="input">Input vector.</param>
             <param name="output">Desired output vector.</param>
             
             <returns>Returns squared error (difference between current network's output and
             desired output) divided by 2.</returns>
             
             <remarks><para>Runs one learning iteration and updates neuron's
             weights.</para></remarks>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.DeltaRuleLearning.RunEpoch(System.Double[][],System.Double[][])">
             <summary>
             Runs learning epoch.
             </summary>
             
             <param name="input">Array of input vectors.</param>
             <param name="output">Array of output vectors.</param>
             
             <returns>Returns summary learning error for the epoch. See <see cref="M:BestCS.Neuro.Learning.DeltaRuleLearning.Run(System.Double[],System.Double[])"/>
             method for details about learning error calculation.</returns>
             
             <remarks><para>The method runs one learning epoch, by calling <see cref="M:BestCS.Neuro.Learning.DeltaRuleLearning.Run(System.Double[],System.Double[])"/> method
             for each vector provided in the <paramref name="input"/> array.</para></remarks>
            
        </member>
        <member name="P:BestCS.Neuro.Learning.DeltaRuleLearning.LearningRate">
            <summary>
            Learning rate, [0, 1].
            </summary>
            
            <remarks><para>The value determines speed of learning.</para>
            
            <para>Default value equals to <b>0.1</b>.</para>
            </remarks>
            
        </member>
        <member name="T:BestCS.Neuro.Learning.ElasticNetworkLearning">
             <summary>
             Elastic network learning algorithm.
             </summary>
            
             <remarks><para>This class implements elastic network's learning algorithm and
             allows to train <see cref="T:BestCS.Neuro.DistanceNetwork">Distance Networks</see>.</para>
             </remarks> 
            
        </member>
        <member name="M:BestCS.Neuro.Learning.ElasticNetworkLearning.#ctor(BestCS.Neuro.DistanceNetwork)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Neuro.Learning.ElasticNetworkLearning"/> class.
            </summary>
            
            <param name="network">Neural network to train.</param>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.ElasticNetworkLearning.Run(System.Double[])">
            <summary>
            Runs learning iteration.
            </summary>
            
            <param name="input">Input vector.</param>
            
            <returns>Returns learning error - summary absolute difference between neurons'
            weights and appropriate inputs. The difference is measured according to the neurons
            distance to the winner neuron.</returns>
            
            <remarks><para>The method runs one learning iterations - finds winner neuron (the neuron
            which has weights with values closest to the specified input vector) and updates its weight
            (as well as weights of neighbor neurons) in the way to decrease difference with the specified
            input vector.</para></remarks>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.ElasticNetworkLearning.RunEpoch(System.Double[][])">
            <summary>
            Runs learning epoch.
            </summary>
            
            <param name="input">Array of input vectors.</param>
            
            <returns>Returns summary learning error for the epoch. See <see cref="M:BestCS.Neuro.Learning.ElasticNetworkLearning.Run(System.Double[])"/>
            method for details about learning error calculation.</returns>
            
            <remarks><para>The method runs one learning epoch, by calling <see cref="M:BestCS.Neuro.Learning.ElasticNetworkLearning.Run(System.Double[])"/> method
            for each vector provided in the <paramref name="input"/> array.</para></remarks>
            
        </member>
        <member name="P:BestCS.Neuro.Learning.ElasticNetworkLearning.LearningRate">
            <summary>
            Learning rate, [0, 1].
            </summary>
            
            <remarks><para>Determines speed of learning.</para>
            
            <para>Default value equals to <b>0.1</b>.</para>
            </remarks>
            
        </member>
        <member name="P:BestCS.Neuro.Learning.ElasticNetworkLearning.LearningRadius">
            <summary>
            Learning radius, [0, 1].
            </summary>
            
            <remarks><para>Determines the amount of neurons to be updated around
            winner neuron. Neurons, which are in the circle of specified radius,
            are updated during the learning procedure. Neurons, which are closer
            to the winner neuron, get more update.</para>
            
            <para>Default value equals to <b>0.5</b>.</para>
            </remarks>
            
        </member>
        <member name="T:BestCS.Neuro.Learning.EvolutionaryFitness">
            <summary>
            Fitness function used for chromosomes representing collection of neural network's weights.
            </summary>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.EvolutionaryFitness.#ctor(BestCS.Neuro.ActivationNetwork,System.Double[][],System.Double[][])">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Neuro.Learning.EvolutionaryFitness"/> class.
            </summary>
            
            <param name="network">Neural network for which fitness will be calculated.</param>
            <param name="input">Input data samples for neural network.</param>
            <param name="output">Output data sampels for neural network (desired output).</param>
            
            <exception cref="T:System.ArgumentException">Length of inputs and outputs arrays must be equal and greater than 0.</exception>
            <exception cref="T:System.ArgumentException">Length of each input vector must be equal to neural network's inputs count.</exception>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.EvolutionaryFitness.Evaluate(BestCS.Genetic.IChromosome)">
             <summary>
             Evaluates chromosome.
             </summary>
             
             <param name="chromosome">Chromosome to evaluate.</param>
             
             <returns>Returns chromosome's fitness value.</returns>
            
             <remarks>The method calculates fitness value of the specified
             chromosome.</remarks>
            
        </member>
        <member name="T:BestCS.Neuro.Learning.EvolutionaryLearning">
            <summary>
            Neural networks' evolutionary learning algorithm, which is based on Genetic Algorithms.
            </summary>
            
            <remarks><para>The class implements supervised neural network's learning algorithm,
            which is based on Genetic Algorithms. For the given neural network, it create a population
            of <see cref="T:BestCS.Genetic.DoubleArrayChromosome"/> chromosomes, which represent neural network's
            weights. Then, during the learning process, the genetic population evolves and weights, which
            are represented by the best chromosome, are set to the source neural network.</para>
            
            <para>See <see cref="T:BestCS.Genetic.Population"/> class for additional information about genetic population
            and evolutionary based search.</para>
            
            <para>Sample usage (training network to calculate XOR function):</para>
            <code>
            // initialize input and output values
            double[][] input = new double[4][] {
                new double[] {-1,  1}, new double[] {-1, 1},
                new double[] { 1, -1}, new double[] { 1, 1}
            };
            double[][] output = new double[4][] {
                new double[] {-1}, new double[] { 1},
                new double[] { 1}, new double[] {-1}
            };
            // create neural network
            ActivationNetwork   network = new ActivationNetwork(
                BipolarSigmoidFunction( 2 ),
                2, // two inputs in the network
                2, // two neurons in the first layer
                1 ); // one neuron in the second layer
            // create teacher
            EvolutionaryLearning teacher = new EvolutionaryLearning( network,
                100 ); // number of chromosomes in genetic population
            // loop
            while ( !needToStop )
            {
                // run epoch of learning procedure
                double error = teacher.RunEpoch( input, output );
                // check error value to see if we need to stop
                // ...
            }
            
            </code>
            </remarks>
            
            <seealso cref="T:BestCS.Neuro.Learning.BackPropagationLearning"/>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.EvolutionaryLearning.#ctor(BestCS.Neuro.ActivationNetwork,System.Int32,BestCS.Math.Random.IRandomNumberGenerator,BestCS.Math.Random.IRandomNumberGenerator,BestCS.Math.Random.IRandomNumberGenerator,BestCS.Genetic.ISelectionMethod,System.Double,System.Double,System.Double)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Neuro.Learning.EvolutionaryLearning"/> class.
            </summary>
            
            <param name="activationNetwork">Activation network to be trained.</param>
            <param name="populationSize">Size of genetic population.</param>
            <param name="chromosomeGenerator">Random numbers generator used for initialization of genetic
            population representing neural network's weights and thresholds (see <see cref="F:BestCS.Genetic.DoubleArrayChromosome.chromosomeGenerator"/>).</param>
            <param name="mutationMultiplierGenerator">Random numbers generator used to generate random
            factors for multiplication of network's weights and thresholds during genetic mutation
            (ses <see cref="F:BestCS.Genetic.DoubleArrayChromosome.mutationMultiplierGenerator"/>.)</param>
            <param name="mutationAdditionGenerator">Random numbers generator used to generate random
            values added to neural network's weights and thresholds during genetic mutation
            (see <see cref="F:BestCS.Genetic.DoubleArrayChromosome.mutationAdditionGenerator"/>).</param>
            <param name="selectionMethod">Method of selection best chromosomes in genetic population.</param>
            <param name="crossOverRate">Crossover rate in genetic population (see
            <see cref="P:BestCS.Genetic.Population.CrossoverRate"/>).</param>
            <param name="mutationRate">Mutation rate in genetic population (see
            <see cref="P:BestCS.Genetic.Population.MutationRate"/>).</param>
            <param name="randomSelectionRate">Rate of injection of random chromosomes during selection
            in genetic population (see <see cref="P:BestCS.Genetic.Population.RandomSelectionPortion"/>).</param>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.EvolutionaryLearning.#ctor(BestCS.Neuro.ActivationNetwork,System.Int32)">
             <summary>
             Initializes a new instance of the <see cref="T:BestCS.Neuro.Learning.EvolutionaryLearning"/> class.
             </summary>
             
             <param name="activationNetwork">Activation network to be trained.</param>
             <param name="populationSize">Size of genetic population.</param>
             
             <remarks><para>This version of constructor is used to create genetic population
             for searching optimal neural network's weight using default set of parameters, which are:
             <list type="bullet">
             <item>Selection method - elite;</item>
             <item>Crossover rate - 0.75;</item>
             <item>Mutation rate - 0.25;</item>
             <item>Rate of injection of random chromosomes during selection - 0.20;</item>
             <item>Random numbers generator for initializing new chromosome -
             <c>UniformGenerator( new Range( -1, 1 ) )</c>;</item>
             <item>Random numbers generator used during mutation for genes' multiplication -
             <c>ExponentialGenerator( 1 )</c>;</item>
             <item>Random numbers generator used during mutation for adding random value to genes -
             <c>UniformGenerator( new Range( -0.5f, 0.5f ) )</c>.</item>
             </list></para>
             
             <para>In order to have full control over the above default parameters, it is possible to
             used extended version of constructor, which allows to specify all of the parameters.</para>
             </remarks>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.EvolutionaryLearning.Run(System.Double[],System.Double[])">
            <summary>
            Runs learning iteration.
            </summary>
            
            <param name="input">Input vector.</param>
            <param name="output">Desired output vector.</param>
            
            <returns>Returns learning error.</returns>
            
            <remarks><note>The method is not implemented, since evolutionary learning algorithm is global
            and requires all inputs/outputs in order to run its one epoch. Use <see cref="M:BestCS.Neuro.Learning.EvolutionaryLearning.RunEpoch(System.Double[][],System.Double[][])"/>
            method instead.</note></remarks>
            
            <exception cref="T:System.NotImplementedException">The method is not implemented by design.</exception>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.EvolutionaryLearning.RunEpoch(System.Double[][],System.Double[][])">
             <summary>
             Runs learning epoch.
             </summary>
             
             <param name="input">Array of input vectors.</param>
             <param name="output">Array of output vectors.</param>
             
             <returns>Returns summary squared learning error for the entire epoch.</returns>
             
             <remarks><para><note>While running the neural network's learning process, it is required to
             pass the same <paramref name="input"/> and <paramref name="output"/> values for each
             epoch. On the very first run of the method it will initialize evolutionary fitness
             function with the given input/output. So, changing input/output in middle of the learning
             process, will break it.</note></para></remarks>
            
        </member>
        <member name="T:BestCS.Neuro.Learning.JacobianMethod">
            <summary>
              The Jacobian computation method used by the Levenberg-Marquardt.
            </summary>
        </member>
        <member name="F:BestCS.Neuro.Learning.JacobianMethod.ByFiniteDifferences">
            <summary>
              Computes the Jacobian using approximation by finite differences. This
              method is slow in comparison with back-propagation and should be used
              only for debugging or comparison purposes.
            </summary>
            
        </member>
        <member name="F:BestCS.Neuro.Learning.JacobianMethod.ByBackpropagation">
            <summary>
              Computes the Jacobian using back-propagation for the chain rule of
              calculus. This is the preferred way of computing the Jacobian.
            </summary>
            
        </member>
        <member name="T:BestCS.Neuro.Learning.LevenbergMarquardtLearning">
             <summary>
               Levenberg-Marquardt Learning Algorithm with optional Bayesian Regularization.
             </summary>
             
             <remarks>
             <para>This class implements the Levenberg-Marquardt learning algorithm,
             which treats the neural network learning as a function optimization
             problem. The Levenberg-Marquardt is one of the fastest and accurate
             learning algorithms for small to medium sized networks.</para>
             
             <para>However, in general, the standard LM algorithm does not perform as well
             on pattern recognition problems as it does on function approximation problems.
             The LM algorithm is designed for least squares problems that are approximately
             linear. Because the output neurons in pattern recognition problems are generally
             saturated, it will not be operating in the linear region.</para>
             
             <para>The advantages of the LM algorithm decreases as the number of network
             parameters increases. </para>
             
             <example>
             <para>Sample usage (training network to calculate XOR function):</para>
               <code>
               // initialize input and output values
               double[][] input =
               {
                   new double[] {0, 0}, new double[] {0, 1},
                   new double[] {1, 0}, new double[] {1, 1}
               };
             
               double[][] output = 
               {
                   new double[] {0}, new double[] {1},
                   new double[] {1}, new double[] {0}
               };
               
               // create neural network
               ActivationNetwork   network = new ActivationNetwork(
                   SigmoidFunction( 2 ),
                   2, // two inputs in the network
                   2, // two neurons in the first layer
                   1 ); // one neuron in the second layer
                 
               // create teacher
               LevenbergMarquardtLearning teacher = new LevenbergMarquardtLearning( network );
               
               // loop
               while ( !needToStop )
               {
                   // run epoch of learning procedure
                   double error = teacher.RunEpoch( input, output );
                   
                   // check error value to see if we need to stop
                   // ...
               }
             </code>
             
             <para>
               The following example shows how to create a neural network to learn a classification
               problem with multiple classes.</para>
               
             <code>
             // Here we will be creating a neural network to process 3-valued input
             // vectors and classify them into 4-possible classes. We will be using
             // a single hidden layer with 5 hidden neurons to accomplish this task.
             //
             int numberOfInputs = 3;
             int numberOfClasses = 4;
             int hiddenNeurons = 5;
             
             // Those are the input vectors and their expected class labels
             // that we expect our network to learn.
             //
             double[][] input = 
             {
                 new double[] { -1, -1, -1 }, // 0
                 new double[] { -1,  1, -1 }, // 1
                 new double[] {  1, -1, -1 }, // 1
                 new double[] {  1,  1, -1 }, // 0
                 new double[] { -1, -1,  1 }, // 2
                 new double[] { -1,  1,  1 }, // 3
                 new double[] {  1, -1,  1 }, // 3
                 new double[] {  1,  1,  1 }  // 2
              };
            
              int[] labels =
              {
                 0,
                 1,
                 1,
                 0,
                 2,
                 3,
                 3,
                 2,
             };
             
             // In order to perform multi-class classification, we have to select a 
             // decision strategy in order to be able to interpret neural network 
             // outputs as labels. For this, we will be expanding our 4 possible class
             // labels into 4-dimensional output vectors where one single dimension 
             // corresponding to a label will contain the value +1 and -1 otherwise.
             
             double[][] outputs = BestCS.Statistics.Tools
               .Expand(labels, numberOfClasses, -1, 1);
             
             // Next we can proceed to create our network
             var function = new BipolarSigmoidFunction(2);
             var network = new ActivationNetwork(function,
               numberOfInputs, hiddenNeurons, numberOfClasses);
             
             // Heuristically randomize the network
             new NguyenWidrow(network).Randomize();
             
             // Create the learning algorithm
             var teacher = new LevenbergMarquardtLearning(network);
             
             // Teach the network for 10 iterations:
             double error = Double.PositiveInfinity;
             for (int i = 0; i &lt; 10; i++)
                error = teacher.RunEpoch(input, outputs);
             
             // At this point, the network should be able to 
             // perfectly classify the training input points.
             
             for (int i = 0; i &lt; input.Length; i++)
             {
                int answer;
                double[] output = network.Compute(input[i]);
                double response = output.Max(out answer);
             
                int expected = labels[i];
               
                // at this point, the variables 'answer' and
                // 'expected' should contain the same value.
             }
             </code>
             </example>
             
             <para>
               References:
               <list type="bullet">
                 <item><description><a href="http://www.cs.nyu.edu/~roweis/notes/lm.pdf">
                   Sam Roweis. Levenberg-Marquardt Optimization.</a></description></item>
                 <item><description><a href="http://www-alg.ist.hokudai.ac.jp/~jan/alpha.pdf">
                   Jan Poland. (2001). On the Robustness of Update Strategies for the Bayesian
                   Hyperparameter alpha. Available on: http://www-alg.ist.hokudai.ac.jp/~jan/alpha.pdf </a></description></item>
                 <item><description><a href="http://cs.olemiss.edu/~ychen/publications/conference/chen_ijcnn99.pdf">
                   B. Wilamowski, Y. Chen. (1999). Efficient Algorithm for Training Neural Networks 
                   with one Hidden Layer. Available on: http://cs.olemiss.edu/~ychen/publications/conference/chen_ijcnn99.pdf </a></description></item>
                 <item><description><a href="http://www.inference.phy.cam.ac.uk/mackay/Bayes_FAQ.html">
                   David MacKay. (2004). Bayesian methods for neural networks - FAQ. Available on:
                   http://www.inference.phy.cam.ac.uk/mackay/Bayes_FAQ.html </a></description></item>
               </list>
             </para>   
             </remarks>
             
        </member>
        <member name="M:BestCS.Neuro.Learning.LevenbergMarquardtLearning.#ctor(BestCS.Neuro.ActivationNetwork)">
            <summary>
              Initializes a new instance of the <see cref="T:BestCS.Neuro.Learning.LevenbergMarquardtLearning"/> class.
            </summary>
            
            <param name="network">Network to teach.</param>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.LevenbergMarquardtLearning.#ctor(BestCS.Neuro.ActivationNetwork,System.Boolean)">
            <summary>
              Initializes a new instance of the <see cref="T:BestCS.Neuro.Learning.LevenbergMarquardtLearning"/> class.
            </summary>
            
            <param name="network">Network to teach.</param>
            <param name="useRegularization">True to use Bayesian regularization, false otherwise.</param>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.LevenbergMarquardtLearning.#ctor(BestCS.Neuro.ActivationNetwork,BestCS.Neuro.Learning.JacobianMethod)">
            <summary>
              Initializes a new instance of the <see cref="T:BestCS.Neuro.Learning.LevenbergMarquardtLearning"/> class.
            </summary>
            
            <param name="network">Network to teach.</param>
            <param name="method">The method by which the Jacobian matrix will be calculated.</param>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.LevenbergMarquardtLearning.#ctor(BestCS.Neuro.ActivationNetwork,System.Boolean,BestCS.Neuro.Learning.JacobianMethod)">
            <summary>
              Initializes a new instance of the <see cref="T:BestCS.Neuro.Learning.LevenbergMarquardtLearning"/> class.
            </summary>
            
            <param name="network">Network to teach.</param>
            <param name="useRegularization">True to use Bayesian regularization, false otherwise.</param>
            <param name="method">The method by which the Jacobian matrix will be calculated.</param>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.LevenbergMarquardtLearning.Run(System.Double[],System.Double[])">
             <summary>
              This method should not be called. Use <see cref="M:BestCS.Neuro.Learning.LevenbergMarquardtLearning.RunEpoch(System.Double[][],System.Double[][])"/> instead.
             </summary>
             
             <param name="input">Array of input vectors.</param>
             <param name="output">Array of output vectors.</param>
             
             <returns>Nothing.</returns>
             
             <remarks><para>Online learning mode is not supported by the
             Levenberg Marquardt. Use batch learning mode instead.</para></remarks>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.LevenbergMarquardtLearning.RunEpoch(System.Double[][],System.Double[][])">
             <summary>
               Runs a single learning epoch.
             </summary>
             
             <param name="input">Array of input vectors.</param>
             <param name="output">Array of output vectors.</param>
             
             <returns>Returns summary learning error for the epoch.</returns>
             
             <remarks><para>The method runs one learning epoch, by calling running necessary
             iterations of the Levenberg Marquardt to achieve an error decrease.</para></remarks>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.LevenbergMarquardtLearning.ComputeError(System.Double[][],System.Double[][])">
            <summary>
              Compute network error for a given data set.
            </summary>
            
            <param name="input">The input points.</param>
            <param name="output">The output points.</param>
            
            <returns>The sum of squared errors for the data.</returns>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.LevenbergMarquardtLearning.loadArrayIntoNetwork">
            <summary>
             Update network's weights.
            </summary>
            
            <returns>The sum of squared weights divided by 2.</returns>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.LevenbergMarquardtLearning.saveNetworkToArray">
            <summary>
              Creates the initial weight vector w
            </summary>
            
            <returns>The sum of squared weights divided by 2.</returns>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.LevenbergMarquardtLearning.getNumberOfParameters(BestCS.Neuro.ActivationNetwork)">
            <summary>
              Gets the number of parameters in a network.
            </summary>
        </member>
        <member name="M:BestCS.Neuro.Learning.LevenbergMarquardtLearning.JacobianByChainRule(System.Double[][],System.Double[][])">
            <summary>
              Calculates the Jacobian matrix by using the chain rule.
            </summary>
            <param name="input">The input vectors.</param>
            <param name="output">The desired output vectors.</param>
            <returns>The sum of squared errors for the last error divided by 2.</returns>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.LevenbergMarquardtLearning.CalculateDerivatives(System.Double[],System.Double[],System.Int32)">
            <summary>
              Calculates partial derivatives for all weights of the network.
            </summary>
            
            <param name="input">The input vector.</param>
            <param name="desiredOutput">Desired output vector.</param>
            <param name="outputIndex">The current output location (index) in the desired output vector.</param>
            
            <returns>Returns summary squared error of the last layer.</returns>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.LevenbergMarquardtLearning.JacobianByFiniteDifference(System.Double[][],System.Double[][])">
            <summary>
              Calculates the Jacobian Matrix using Finite Differences
            </summary>
            
            <returns>Returns the sum of squared errors of the network divided by 2.</returns>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.LevenbergMarquardtLearning.createCoefficients(System.Int32)">
            <summary>
              Creates the coefficients to be used when calculating
              the approximate Jacobian by using finite differences.
            </summary>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.LevenbergMarquardtLearning.ComputeDerivative(System.Double[],System.Int32,System.Int32,System.Int32,System.Double@,System.Double,System.Int32)">
            <summary>
              Computes the derivative of the network in 
              respect to the weight passed as parameter.
            </summary>
            
        </member>
        <member name="P:BestCS.Neuro.Learning.LevenbergMarquardtLearning.LearningRate">
             <summary>
               Levenberg's damping factor (lambda). This 
               value  must be positive. Default is 0.1.
             </summary>
             
             <remarks>
               The value determines speed of learning. Default value is <b>0.1</b>.
             </remarks>
            
        </member>
        <member name="P:BestCS.Neuro.Learning.LevenbergMarquardtLearning.Adjustment">
             <summary>
               Learning rate adjustment. Default value is 10.
             </summary>
             
             <remarks>
               The value by which the learning rate is adjusted when searching 
               for the minimum cost surface. Default value is 10.
             </remarks>
            
        </member>
        <member name="P:BestCS.Neuro.Learning.LevenbergMarquardtLearning.NumberOfParameters">
            <summary>
              Gets the total number of parameters
              in the network being trained.
            </summary>
            
        </member>
        <member name="P:BestCS.Neuro.Learning.LevenbergMarquardtLearning.EffectiveParameters">
            <summary>
              Gets the number of effective parameters being used
              by the network as determined by the Bayesian regularization.
            </summary>
            <remarks>
              If no regularization is being used, the value will be 0.
            </remarks>
            
        </member>
        <member name="P:BestCS.Neuro.Learning.LevenbergMarquardtLearning.Alpha">
            <summary>
              Gets or sets the importance of the squared sum of network
              weights in the cost function. Used by the regularization.
            </summary>
            
            <remarks>
              This is the first Bayesian hyperparameter. The default
              value is 0.
            </remarks>
            
        </member>
        <member name="P:BestCS.Neuro.Learning.LevenbergMarquardtLearning.Beta">
            <summary>
              Gets or sets the importance of the squared sum of network
              errors in the cost function. Used by the regularization.
            </summary>
            
            <remarks>
              This is the second Bayesian hyperparameter. The default
              value is 1.
            </remarks>
            
        </member>
        <member name="P:BestCS.Neuro.Learning.LevenbergMarquardtLearning.UseRegularization">
            <summary>
              Gets or sets whether to use Bayesian Regularization.
            </summary>
            
        </member>
        <member name="P:BestCS.Neuro.Learning.LevenbergMarquardtLearning.Blocks">
            <summary>
              Gets or sets the number of blocks to divide the 
              Jacobian matrix in the Hessian calculation to
              preserve memory. Default is 1.
            </summary>
            
        </member>
        <member name="P:BestCS.Neuro.Learning.LevenbergMarquardtLearning.Hessian">
            <summary>
              Gets the approximate Hessian matrix of second derivatives 
              generated in the last algorithm iteration. The Hessian is 
              stored in the upper triangular part of this matrix. See 
              remarks for details.
              </summary>
              
            <remarks>
            <para>
              The Hessian needs only be upper-triangular, since
              it is symmetric. The Cholesky decomposition will
              make use of this fact and use the lower-triangular
              portion to hold the decomposition, conserving memory</para>
            <para>
              Thus said, this property will hold the Hessian matrix
              in the upper-triangular part of this matrix, and store
              its Cholesky decomposition on its lower triangular part.</para>
            </remarks>
             
        </member>
        <member name="P:BestCS.Neuro.Learning.LevenbergMarquardtLearning.Jacobian">
            <summary>
              Gets the Jacobian matrix created in the last iteration.
            </summary>
            
        </member>
        <member name="P:BestCS.Neuro.Learning.LevenbergMarquardtLearning.Gradient">
            <summary>
              Gets the gradient vector computed in the last iteration.
            </summary>
            
        </member>
        <member name="T:BestCS.Neuro.Learning.ParallelResilientBackpropagationLearning">
            <summary>
              Resilient Backpropagation learning algorithm.
            </summary>
            
            <remarks>
            <para>
              This class implements the resilient backpropagation (RProp)
              learning algorithm. The RProp learning algorithm is one of the fastest learning
              algorithms for feed-forward learning networks which use only first-order
              information.</para>
            </remarks>
            
            <example>
            <para>
              Sample usage (training network to calculate XOR function):</para>
            
            <code>
            // initialize input and output values
            double[][] input = 
            {
                new double[] {0, 0}, new double[] {0, 1},
                new double[] {1, 0}, new double[] {1, 1}
            };
            
            double[][] output = 
            {
                new double[] {0}, new double[] {1},
                new double[] {1}, new double[] {0}
            };
            
            // create neural network
            ActivationNetwork   network = new ActivationNetwork(
                SigmoidFunction(2),
                2, // two inputs in the network
                2, // two neurons in the first layer
                1 ); // one neuron in the second layer
                
            // create teacher
            var teacher = new ResilientBackpropagationLearning(network);
            
            // loop
            while (!needToStop)
            {
                // run epoch of learning procedure
                double error = teacher.RunEpoch( input, output );
                // check error value to see if we need to stop
                // ...
            }
            </code>
            
            <para>
              The following example shows how to use Rprop to solve a multi-class
              classification problem.</para>
              
            <code>
            // Suppose we would like to teach a network to recognize 
            // the following input vectors into 3 possible classes:
            //
            double[][] inputs =
            {
                new double[] { 0, 1, 1, 0 }, // 0
                new double[] { 0, 1, 0, 0 }, // 0
                new double[] { 0, 0, 1, 0 }, // 0
                new double[] { 0, 1, 1, 0 }, // 0
                new double[] { 0, 1, 0, 0 }, // 0
                new double[] { 1, 0, 0, 0 }, // 1
                new double[] { 1, 0, 0, 0 }, // 1
                new double[] { 1, 0, 0, 1 }, // 1
                new double[] { 0, 0, 0, 1 }, // 1
                new double[] { 0, 0, 0, 1 }, // 1
                new double[] { 1, 1, 1, 1 }, // 2
                new double[] { 1, 0, 1, 1 }, // 2
                new double[] { 1, 1, 0, 1 }, // 2
                new double[] { 0, 1, 1, 1 }, // 2
                new double[] { 1, 1, 1, 1 }, // 2
            };
            
            int[] classes =
            {
                0, 0, 0, 0, 0,
                1, 1, 1, 1, 1,
                2, 2, 2, 2, 2,
            };
            
            // First we have to convert this problem into a way that  the neural
            // network can handle. The first step is to expand the classes into 
            // indicator vectors, where a 1 into a position signifies that this
            // position indicates the class the sample belongs to.
            //
            double[][] outputs = BestCS.Statistics.Tools.Expand(classes, -1, +1);
            
            // Create an activation function for the net
            var function = new BipolarSigmoidFunction();
            
            // Create an activation network with the function and
            //  4 inputs, 5 hidden neurons and 3 possible outputs:
            var network = new ActivationNetwork(function, 4, 5, 3);
            
            // Randomly initialize the network
            new NguyenWidrow(network).Randomize();
            
            // Teach the network using parallel Rprop:
            var teacher = new ParallelResilientBackpropagationLearning(network);
            
            double error = 1.0;
            while (error &gt; 1e-5)
                error = teacher.RunEpoch(inputs, outputs);
            
            
            // Checks if the network has learned
            for (int i = 0; i &lt; inputs.Length; i++)
            {
                double[] answer = network.Compute(inputs[i]);
            
                int expected = classes[i];
                int actual; answer.Max(out actual);
            
                // actual should be equal to expected
            }
            </code>
            </example>
            
            <seealso cref="T:BestCS.Neuro.Learning.LevenbergMarquardtLearning"/>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.ParallelResilientBackpropagationLearning.#ctor(BestCS.Neuro.ActivationNetwork)">
            <summary>
              Initializes a new instance of the <see cref="T:BestCS.Neuro.Learning.ParallelResilientBackpropagationLearning"/> class.
            </summary>
            
            <param name="network">Network to teach.</param>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.ParallelResilientBackpropagationLearning.Run(System.Double[],System.Double[])">
             <summary>
               Runs learning iteration.
             </summary>
             
             <param name="input">Input vector.</param>
             <param name="output">Desired output vector.</param>
             
             <returns>Returns squared error (difference between current network's output and
             desired output) divided by 2.</returns>
             
             <remarks><para>Runs one learning iteration and updates neuron's
             weights.</para></remarks>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.ParallelResilientBackpropagationLearning.RunEpoch(System.Double[][],System.Double[][])">
            <summary>
              Runs learning epoch.
            </summary>
            
            <param name="input">Array of input vectors.</param>
            <param name="output">Array of output vectors.</param>
            
            <returns>Returns summary learning error for the epoch. See <see cref="M:BestCS.Neuro.Learning.ParallelResilientBackpropagationLearning.Run(System.Double[],System.Double[])"/>
            method for details about learning error calculation.</returns>
            
            <remarks><para>The method runs one learning epoch, by calling <see cref="M:BestCS.Neuro.Learning.ParallelResilientBackpropagationLearning.Run(System.Double[],System.Double[])"/> method
            for each vector provided in the <paramref name="input"/> array.</para></remarks>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.ParallelResilientBackpropagationLearning.UpdateNetwork">
            <summary>
              Update network weights.
            </summary>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.ParallelResilientBackpropagationLearning.ComputeError(System.Double[][],System.Double[][])">
            <summary>
              Compute network error for a given data set.
            </summary>
            
            <param name="input">The input points.</param>
            <param name="output">The output points.</param>
            
            <returns>The sum of squared errors for the data.</returns>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.ParallelResilientBackpropagationLearning.Reset(System.Double)">
            <summary>
              Resets the current update steps using the given learning rate.
            </summary>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.ParallelResilientBackpropagationLearning.ResetGradient">
            <summary>
              Resets the gradient vector back to zero.
            </summary>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.ParallelResilientBackpropagationLearning.CalculateError(System.Double[])">
            <summary>
              Calculates error values for all neurons of the network.
            </summary>
            
            <param name="desiredOutput">Desired output vector.</param>
            
            <returns>Returns summary squared error of the last layer divided by 2.</returns>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.ParallelResilientBackpropagationLearning.CalculateGradient(System.Double[])">
             <summary>
               Computes the gradient for a given input.
             </summary>
            
             <param name="input">Network's input vector.</param>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.ParallelResilientBackpropagationLearning.Dispose">
            <summary>
              Performs application-defined tasks associated with freeing,
              releasing, or resetting unmanaged resources.
            </summary>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.ParallelResilientBackpropagationLearning.Finalize">
            <summary>
              Releases unmanaged resources and performs other cleanup operations before
              the <see cref="T:BestCS.Neuro.Learning.ParallelResilientBackpropagationLearning"/> is reclaimed by garbage
              collection.
            </summary>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.ParallelResilientBackpropagationLearning.Dispose(System.Boolean)">
            <summary>
              Releases unmanaged and - optionally - managed resources
            </summary>
            
            <param name="disposing"><c>true</c> to release both managed 
            and unmanaged resources; <c>false</c> to release only unmanaged
            resources.</param>
            
        </member>
        <member name="P:BestCS.Neuro.Learning.ParallelResilientBackpropagationLearning.UpdateUpperBound">
            <summary>
              Gets or sets the maximum possible update step,
              also referred as delta min. Default is 50.
            </summary>
            
        </member>
        <member name="P:BestCS.Neuro.Learning.ParallelResilientBackpropagationLearning.UpdateLowerBound">
            <summary>
              Gets or sets the minimum possible update step,
              also referred as delta max. Default is 1e-6.
            </summary>
            
        </member>
        <member name="P:BestCS.Neuro.Learning.ParallelResilientBackpropagationLearning.DecreaseFactor">
            <summary>
              Gets the decrease parameter, also 
              referred as eta minus. Default is 0.5.
            </summary>
            
        </member>
        <member name="P:BestCS.Neuro.Learning.ParallelResilientBackpropagationLearning.IncreaseFactor">
            <summary>
              Gets the increase parameter, also
              referred as eta plus. Default is 1.2.
            </summary>
            
        </member>
        <member name="T:BestCS.Neuro.Learning.PerceptronLearning">
            <summary>
            Perceptron learning algorithm.
            </summary>
            
            <remarks><para>This learning algorithm is used to train one layer neural
            network of <see cref="T:BestCS.Neuro.ActivationNeuron">Activation Neurons</see>
            with the <see cref="T:BestCS.Neuro.ThresholdFunction">Threshold</see>
            activation function.</para>
            
            <para>See information about <a href="http://en.wikipedia.org/wiki/Perceptron">Perceptron</a>
            and its learning algorithm.</para>
            </remarks>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.PerceptronLearning.#ctor(BestCS.Neuro.ActivationNetwork)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Neuro.Learning.PerceptronLearning"/> class.
            </summary>
            
            <param name="network">Network to teach.</param>
            
            <exception cref="T:System.ArgumentException">Invalid nuaral network. It should have one layer only.</exception>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.PerceptronLearning.Run(System.Double[],System.Double[])">
            <summary>
            Runs learning iteration.
            </summary>
            
            <param name="input">Input vector.</param>
            <param name="output">Desired output vector.</param>
            
            <returns>Returns absolute error - difference between current network's output and
            desired output.</returns>
            
            <remarks><para>Runs one learning iteration and updates neuron's
            weights in the case if neuron's output is not equal to the
            desired output.</para></remarks>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.PerceptronLearning.RunEpoch(System.Double[][],System.Double[][])">
            <summary>
            Runs learning epoch.
            </summary>
            
            <param name="input">Array of input vectors.</param>
            <param name="output">Array of output vectors.</param>
            
            <returns>Returns summary learning error for the epoch. See <see cref="M:BestCS.Neuro.Learning.PerceptronLearning.Run(System.Double[],System.Double[])"/>
            method for details about learning error calculation.</returns>
            
            <remarks><para>The method runs one learning epoch, by calling <see cref="M:BestCS.Neuro.Learning.PerceptronLearning.Run(System.Double[],System.Double[])"/> method
            for each vector provided in the <paramref name="input"/> array.</para></remarks>
            
        </member>
        <member name="P:BestCS.Neuro.Learning.PerceptronLearning.LearningRate">
            <summary>
            Learning rate, [0, 1].
            </summary>
            
            <remarks><para>The value determines speed of learning.</para>
            
            <para>Default value equals to <b>0.1</b>.</para>
            </remarks>
            
        </member>
        <member name="T:BestCS.Neuro.Learning.ResilientBackpropagationLearning">
            <summary>
            Resilient Backpropagation learning algorithm.
            </summary>
            
            <remarks><para>This class implements the resilient backpropagation (RProp)
            learning algorithm. The RProp learning algorithm is one of the fastest learning
            algorithms for feed-forward learning networks which use only first-order
            information.</para>
            
            <para>Sample usage (training network to calculate XOR function):</para>
            <code>
            // initialize input and output values
            double[][] input = new double[4][] {
                new double[] {0, 0}, new double[] {0, 1},
                new double[] {1, 0}, new double[] {1, 1}
            };
            double[][] output = new double[4][] {
                new double[] {0}, new double[] {1},
                new double[] {1}, new double[] {0}
            };
            // create neural network
            ActivationNetwork   network = new ActivationNetwork(
                SigmoidFunction( 2 ),
                2, // two inputs in the network
                2, // two neurons in the first layer
                1 ); // one neuron in the second layer
            // create teacher
            ResilientBackpropagationLearning teacher = new ResilientBackpropagationLearning( network );
            // loop
            while ( !needToStop )
            {
                // run epoch of learning procedure
                double error = teacher.RunEpoch( input, output );
                // check error value to see if we need to stop
                // ...
            }
            </code>
            </remarks>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.ResilientBackpropagationLearning.#ctor(BestCS.Neuro.ActivationNetwork)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Neuro.Learning.ResilientBackpropagationLearning"/> class.
            </summary>
            
            <param name="network">Network to teach.</param>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.ResilientBackpropagationLearning.Run(System.Double[],System.Double[])">
             <summary>
             Runs learning iteration.
             </summary>
             
             <param name="input">Input vector.</param>
             <param name="output">Desired output vector.</param>
             
             <returns>Returns squared error (difference between current network's output and
             desired output) divided by 2.</returns>
             
             <remarks><para>Runs one learning iteration and updates neuron's
             weights.</para></remarks>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.ResilientBackpropagationLearning.RunEpoch(System.Double[][],System.Double[][])">
            <summary>
            Runs learning epoch.
            </summary>
            
            <param name="input">Array of input vectors.</param>
            <param name="output">Array of output vectors.</param>
            
            <returns>Returns summary learning error for the epoch. See <see cref="M:BestCS.Neuro.Learning.ResilientBackpropagationLearning.Run(System.Double[],System.Double[])"/>
            method for details about learning error calculation.</returns>
            
            <remarks><para>The method runs one learning epoch, by calling <see cref="M:BestCS.Neuro.Learning.ResilientBackpropagationLearning.Run(System.Double[],System.Double[])"/> method
            for each vector provided in the <paramref name="input"/> array.</para></remarks>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.ResilientBackpropagationLearning.ResetGradient">
            <summary>
            Resets current weight and threshold derivatives.
            </summary>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.ResilientBackpropagationLearning.ResetUpdates(System.Double)">
            <summary>
            Resets the current update steps using the given learning rate.
            </summary>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.ResilientBackpropagationLearning.UpdateNetwork">
            <summary>
            Update network's weights.
            </summary>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.ResilientBackpropagationLearning.CalculateError(System.Double[])">
            <summary>
            Calculates error values for all neurons of the network.
            </summary>
            
            <param name="desiredOutput">Desired output vector.</param>
            
            <returns>Returns summary squared error of the last layer divided by 2.</returns>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.ResilientBackpropagationLearning.CalculateGradient(System.Double[])">
            <summary>
            Calculate weights updates
            </summary>
            
            <param name="input">Network's input vector.</param>
            
        </member>
        <member name="P:BestCS.Neuro.Learning.ResilientBackpropagationLearning.LearningRate">
             <summary>
             Learning rate.
             </summary>
             
             <remarks><para>The value determines speed of learning.</para>
             
             <para>Default value equals to <b>0.0125</b>.</para>
             </remarks>
            
        </member>
        <member name="T:BestCS.Neuro.Learning.SOMLearning">
            <summary>
            Kohonen Self Organizing Map (SOM) learning algorithm.
            </summary>
            
            <remarks><para>This class implements Kohonen's SOM learning algorithm and
            is widely used in clusterization tasks. The class allows to train
            <see cref="T:BestCS.Neuro.DistanceNetwork">Distance Networks</see>.</para>
            
            <para>Sample usage (clustering RGB colors):</para>
            <code>
            // set range for randomization neurons' weights
            Neuron.RandRange = new Range( 0, 255 );
            // create network
            DistanceNetwork	network = new DistanceNetwork(
                    3, // thress inputs in the network
                    100 * 100 ); // 10000 neurons
            // create learning algorithm
            SOMLearning	trainer = new SOMLearning( network );
            // network's input
            double[] input = new double[3];
            // loop
            while ( !needToStop )
            {
                input[0] = rand.Next( 256 );
                input[1] = rand.Next( 256 );
                input[2] = rand.Next( 256 );
            
                trainer.Run( input );
            
                // ...
                // update learning rate and radius continuously,
                // so networks may come steady state
            }
            </code>
            </remarks>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.SOMLearning.#ctor(BestCS.Neuro.DistanceNetwork)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Neuro.Learning.SOMLearning"/> class.
            </summary>
            
            <param name="network">Neural network to train.</param>
            
            <remarks><para>This constructor supposes that a square network will be passed for training -
            it should be possible to get square root of network's neurons amount.</para></remarks>
            
            <exception cref="T:System.ArgumentException">Invalid network size - square network is expected.</exception>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.SOMLearning.#ctor(BestCS.Neuro.DistanceNetwork,System.Int32,System.Int32)">
             <summary>
             Initializes a new instance of the <see cref="T:BestCS.Neuro.Learning.SOMLearning"/> class.
             </summary>
             
             <param name="network">Neural network to train.</param>
             <param name="width">Neural network's width.</param>
             <param name="height">Neural network's height.</param>
            
             <remarks>The constructor allows to pass network of arbitrary rectangular shape.
             The amount of neurons in the network should be equal to <b>width</b> * <b>height</b>.
             </remarks>
            
             <exception cref="T:System.ArgumentException">Invalid network size - network size does not correspond
             to specified width and height.</exception>
             
        </member>
        <member name="M:BestCS.Neuro.Learning.SOMLearning.Run(System.Double[])">
            <summary>
            Runs learning iteration.
            </summary>
            
            <param name="input">Input vector.</param>
            
            <returns>Returns learning error - summary absolute difference between neurons' weights
            and appropriate inputs. The difference is measured according to the neurons
            distance to the winner neuron.</returns>
            
            <remarks><para>The method runs one learning iterations - finds winner neuron (the neuron
            which has weights with values closest to the specified input vector) and updates its weight
            (as well as weights of neighbor neurons) in the way to decrease difference with the specified
            input vector.</para></remarks>
            
        </member>
        <member name="M:BestCS.Neuro.Learning.SOMLearning.RunEpoch(System.Double[][])">
            <summary>
            Runs learning epoch.
            </summary>
            
            <param name="input">Array of input vectors.</param>
            
            <returns>Returns summary learning error for the epoch. See <see cref="M:BestCS.Neuro.Learning.SOMLearning.Run(System.Double[])"/>
            method for details about learning error calculation.</returns>
            
            <remarks><para>The method runs one learning epoch, by calling <see cref="M:BestCS.Neuro.Learning.SOMLearning.Run(System.Double[])"/> method
            for each vector provided in the <paramref name="input"/> array.</para></remarks>
            
        </member>
        <member name="P:BestCS.Neuro.Learning.SOMLearning.LearningRate">
            <summary>
            Learning rate, [0, 1].
            </summary>
            
            <remarks><para>Determines speed of learning.</para>
            
            <para>Default value equals to <b>0.1</b>.</para>
            </remarks>
            
        </member>
        <member name="P:BestCS.Neuro.Learning.SOMLearning.LearningRadius">
            <summary>
            Learning radius.
            </summary>
            
            <remarks><para>Determines the amount of neurons to be updated around
            winner neuron. Neurons, which are in the circle of specified radius,
            are updated during the learning procedure. Neurons, which are closer
            to the winner neuron, get more update.</para>
            
            <para><note>In the case if learning rate is set to 0, then only winner
            neuron's weights are updated.</note></para>
            
            <para>Default value equals to <b>7</b>.</para>
            </remarks>
            
        </member>
        <member name="T:BestCS.Neuro.ActivationNetwork">
             <summary>
             Activation network.
             </summary>
             
             <remarks><para>Activation network is a base for multi-layer neural network
             with activation functions. It consists of <see cref="T:BestCS.Neuro.ActivationLayer">activation
             layers</see>.</para>
            
             <para>Sample usage:</para>
             <code>
             // create activation network
            	ActivationNetwork network = new ActivationNetwork(
            		new SigmoidFunction( ), // sigmoid activation function
            		3,                      // 3 inputs
            		4, 1 );                 // 2 layers:
                                         // 4 neurons in the firs layer
                                         // 1 neuron in the second layer
            	</code>
             </remarks>
             
        </member>
        <member name="T:BestCS.Neuro.Network">
            <summary>
            Base neural network class.
            </summary>
            
            <remarks>This is a base neural netwok class, which represents
            collection of neuron's layers.</remarks>
            
        </member>
        <member name="F:BestCS.Neuro.Network.inputsCount">
            <summary>
            Network's inputs count.
            </summary>
        </member>
        <member name="F:BestCS.Neuro.Network.layersCount">
            <summary>
            Network's layers count.
            </summary>
        </member>
        <member name="F:BestCS.Neuro.Network.layers">
            <summary>
            Network's layers.
            </summary>
        </member>
        <member name="F:BestCS.Neuro.Network.output">
            <summary>
            Network's output vector.
            </summary>
        </member>
        <member name="M:BestCS.Neuro.Network.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Neuro.Network"/> class.
            </summary>
            
            <param name="inputsCount">Network's inputs count.</param>
            <param name="layersCount">Network's layers count.</param>
            
            <remarks>Protected constructor, which initializes <see cref="F:BestCS.Neuro.Network.inputsCount"/>,
            <see cref="F:BestCS.Neuro.Network.layersCount"/> and <see cref="F:BestCS.Neuro.Network.layers"/> members.</remarks>
            
        </member>
        <member name="M:BestCS.Neuro.Network.Compute(System.Double[])">
            <summary>
            Compute output vector of the network.
            </summary>
            
            <param name="input">Input vector.</param>
            
            <returns>Returns network's output vector.</returns>
            
            <remarks><para>The actual network's output vecor is determined by layers,
            which comprise the layer - represents an output vector of the last layer
            of the network. The output vector is also stored in <see cref="P:BestCS.Neuro.Network.Output"/> property.</para>
            
            <para><note>The method may be called safely from multiple threads to compute network's
            output value for the specified input values. However, the value of
            <see cref="P:BestCS.Neuro.Network.Output"/> property in multi-threaded environment is not predictable,
            since it may hold network's output computed from any of the caller threads. Multi-threaded
            access to the method is useful in those cases when it is required to improve performance
            by utilizing several threads and the computation is based on the immediate return value
            of the method, but not on network's output property.</note></para>
            </remarks>
            
        </member>
        <member name="M:BestCS.Neuro.Network.Randomize">
            <summary>
            Randomize layers of the network.
            </summary>
            
            <remarks>Randomizes network's layers by calling <see cref="M:BestCS.Neuro.Layer.Randomize"/> method
            of each layer.</remarks>
            
        </member>
        <member name="M:BestCS.Neuro.Network.Save(System.String)">
            <summary>
            Save network to specified file.
            </summary>
            
            <param name="fileName">File name to save network into.</param>
            
            <remarks><para>The neural network is saved using .NET serialization (binary formatter is used).</para></remarks>
            
        </member>
        <member name="M:BestCS.Neuro.Network.Save(System.IO.Stream)">
            <summary>
            Save network to specified file.
            </summary>
            
            <param name="stream">Stream to save network into.</param>
            
            <remarks><para>The neural network is saved using .NET serialization (binary formatter is used).</para></remarks>
            
        </member>
        <member name="M:BestCS.Neuro.Network.Load(System.String)">
            <summary>
            Load network from specified file.
            </summary>
            
            <param name="fileName">File name to load network from.</param>
            
            <returns>Returns instance of <see cref="T:BestCS.Neuro.Network"/> class with all properties initialized from file.</returns>
            
            <remarks><para>Neural network is loaded from file using .NET serialization (binary formater is used).</para></remarks>
            
        </member>
        <member name="M:BestCS.Neuro.Network.Load(System.IO.Stream)">
            <summary>
            Load network from specified file.
            </summary>
            
            <param name="stream">Stream to load network from.</param>
            
            <returns>Returns instance of <see cref="T:BestCS.Neuro.Network"/> class with all properties initialized from file.</returns>
            
            <remarks><para>Neural network is loaded from file using .NET serialization (binary formater is used).</para></remarks>
            
        </member>
        <member name="P:BestCS.Neuro.Network.InputsCount">
            <summary>
            Network's inputs count.
            </summary>
        </member>
        <member name="P:BestCS.Neuro.Network.Layers">
            <summary>
            Network's layers.
            </summary>
        </member>
        <member name="P:BestCS.Neuro.Network.Output">
            <summary>
            Network's output vector.
            </summary>
            
            <remarks><para>The calculation way of network's output vector is determined by
            layers, which comprise the network.</para>
            
            <para><note>The property is not initialized (equals to <see langword="null"/>) until
            <see cref="M:BestCS.Neuro.Network.Compute(System.Double[])"/> method is called.</note></para>
            </remarks>
            
        </member>
        <member name="M:BestCS.Neuro.ActivationNetwork.#ctor(BestCS.Neuro.IActivationFunction,System.Int32,System.Int32[])">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Neuro.ActivationNetwork"/> class.
            </summary>
            
            <param name="function">Activation function of neurons of the network.</param>
            <param name="inputsCount">Network's inputs count.</param>
            <param name="neuronsCount">Array, which specifies the amount of neurons in
            each layer of the neural network.</param>
            
            <remarks>The new network is randomized (see <see cref="M:BestCS.Neuro.ActivationNeuron.Randomize"/>
            method) after it is created.</remarks>
            
        </member>
        <member name="M:BestCS.Neuro.ActivationNetwork.SetActivationFunction(BestCS.Neuro.IActivationFunction)">
            <summary>
            Set new activation function for all neurons of the network.
            </summary>
            
            <param name="function">Activation function to set.</param>
            
            <remarks><para>The method sets new activation function for all neurons by calling
            <see cref="M:BestCS.Neuro.ActivationLayer.SetActivationFunction(BestCS.Neuro.IActivationFunction)"/> method for each layer of the network.</para></remarks>
            
        </member>
        <member name="T:BestCS.Neuro.Networks.DeepBeliefNetwork">
            <summary>
              Deep Belief Network.
            </summary>
            
            <remarks>
              The Deep Belief Network can be seen as a collection of stacked
              <see cref="T:BestCS.Neuro.Networks.RestrictedBoltzmannMachine">Restricted Boltzmann
              Machines</see> disposed as layers of a network. In turn, the
              whole network can be seen as an stochastic activation network
              in which the neurons activate within some given probability.
            </remarks>
            
        </member>
        <member name="M:BestCS.Neuro.Networks.DeepBeliefNetwork.#ctor(System.Int32,System.Int32[])">
            <summary>
              Creates a new <see cref="T:BestCS.Neuro.Networks.DeepBeliefNetwork"/>.
            </summary>
            
            <param name="inputsCount">The number of inputs for the network.</param>
            <param name="hiddenNeurons">The number of hidden neurons in each layer.</param>
            
        </member>
        <member name="M:BestCS.Neuro.Networks.DeepBeliefNetwork.#ctor(BestCS.Neuro.ActivationFunctions.IStochasticFunction,System.Int32,System.Int32[])">
            <summary>
              Creates a new <see cref="T:BestCS.Neuro.Networks.DeepBeliefNetwork"/>.
            </summary>
            
            <param name="function">The activation function to be used in the network neurons.</param>
            <param name="inputsCount">The number of inputs for the network.</param>
            <param name="hiddenNeurons">The number of hidden neurons in each layer.</param>
            
        </member>
        <member name="M:BestCS.Neuro.Networks.DeepBeliefNetwork.#ctor(System.Int32,BestCS.Neuro.Networks.RestrictedBoltzmannMachine[])">
            <summary>
              Creates a new <see cref="T:BestCS.Neuro.Networks.DeepBeliefNetwork"/>.
            </summary>
            
            <param name="inputsCount">The number of inputs for the network.</param>
            <param name="layers">The layers to add to the deep network.</param>
            
        </member>
        <member name="M:BestCS.Neuro.Networks.DeepBeliefNetwork.Compute(System.Double[])">
            <summary>
              Computes the network's outputs for a given input.
            </summary>
            
            <param name="input">The input vector.</param>
            
            <returns>
              Returns the network's output for the given input.
            </returns>
            
        </member>
        <member name="M:BestCS.Neuro.Networks.DeepBeliefNetwork.Compute(System.Double[],System.Int32)">
            <summary>
              Computes the network's outputs for a given input.
            </summary>
            
            <param name="input">The input vector.</param>
            <param name="layerIndex">The index of the layer.</param>
            
            <returns>
              Returns the network's output for the given input.
            </returns>
            
        </member>
        <member name="M:BestCS.Neuro.Networks.DeepBeliefNetwork.Reconstruct(System.Double[])">
            <summary>
              Reconstructs a input vector for a given output.
            </summary>
            
            <param name="output">The output vector.</param>
            
            <returns>
              Returns a probable input vector which may 
              have originated the given output.
            </returns>
            
        </member>
        <member name="M:BestCS.Neuro.Networks.DeepBeliefNetwork.Reconstruct(System.Double[],System.Int32)">
            <summary>
              Reconstructs a input vector using the output
              vector of a given layer.
            </summary>
            
            <param name="output">The output vector.</param>
            <param name="layerIndex">The index of the layer.</param>
            
            <returns>
              Returns a probable input vector which may 
              have originated the given output in the 
              indicated layer.
            </returns>
            
        </member>
        <member name="M:BestCS.Neuro.Networks.DeepBeliefNetwork.GenerateOutput(System.Double[])">
            <summary>
              Samples an output vector from the network
              given an input vector.
            </summary>
            
            <param name="input">An input vector.</param>
            
            <returns>
              A possible output considering the
              stochastic activations of the network.
            </returns>
            
        </member>
        <member name="M:BestCS.Neuro.Networks.DeepBeliefNetwork.GenerateOutput(System.Double[],System.Int32)">
            <summary>
              Samples an output vector from the network
              given an input vector.
            </summary>
            
            <param name="input">An input vector.</param>
            <param name="layerIndex">The index of the layer.</param>
            
            <returns>
              A possible output considering the
              stochastic activations of the network.
            </returns>
            
        </member>
        <member name="M:BestCS.Neuro.Networks.DeepBeliefNetwork.GenerateInput(System.Double[])">
            <summary>
              Samples an input vector from the network
              given an output vector.
            </summary>
            
            <param name="output">An output vector.</param>
            
            <returns>
              A possible reconstruction considering the
              stochastic activations of the network.
            </returns>
            
        </member>
        <member name="M:BestCS.Neuro.Networks.DeepBeliefNetwork.Push(System.Int32)">
            <summary>
              Inserts a new layer at the end of this network.
            </summary>
            
            <param name="neurons">The number of neurons in the new layer.</param>
            
        </member>
        <member name="M:BestCS.Neuro.Networks.DeepBeliefNetwork.Push(System.Int32,BestCS.Neuro.ActivationFunctions.IStochasticFunction)">
            <summary>
              Inserts a new layer at the end of this network.
            </summary>
            
            <param name="neurons">The number of neurons in the new layer.</param>
            <param name="function">The activation function which should be used by the neurons.</param>
            
        </member>
        <member name="M:BestCS.Neuro.Networks.DeepBeliefNetwork.Push(System.Int32,BestCS.Neuro.ActivationFunctions.IStochasticFunction,BestCS.Neuro.ActivationFunctions.IStochasticFunction)">
            <summary>
              Inserts a new layer at the end of this network.
            </summary>
            
            <param name="neurons">The number of neurons in the layer.</param>
            <param name="visibleFunction">The activation function which should be used by the visible neurons.</param>
            <param name="hiddenFunction">The activation function which should be used by the hidden neurons.</param>
            
        </member>
        <member name="M:BestCS.Neuro.Networks.DeepBeliefNetwork.Push(BestCS.Neuro.Networks.RestrictedBoltzmannMachine)">
            <summary>
              Stacks a new Boltzmann Machine at the end of this network.
            </summary>
            
            <param name="network">The machine to be added to the network.</param>
            
        </member>
        <member name="M:BestCS.Neuro.Networks.DeepBeliefNetwork.Pop">
            <summary>
              Removes the last layer from the network.
            </summary>
            
        </member>
        <member name="M:BestCS.Neuro.Networks.DeepBeliefNetwork.UpdateVisibleWeights">
            <summary>
              Updates the weights of the visible layers by copying
              the reverse of the weights in the hidden layers.
            </summary>
            
        </member>
        <member name="M:BestCS.Neuro.Networks.DeepBeliefNetwork.CreateGaussianBernoulli(System.Int32,System.Int32[])">
            <summary>
              Creates a Gaussian-Bernoulli network.
            </summary>
            
            <param name="inputsCount">The number of inputs for the network.</param>
            <param name="hiddenNeurons">The number of hidden neurons in each layer.</param>
            
        </member>
        <member name="M:BestCS.Neuro.Networks.DeepBeliefNetwork.CreateMixedNetwork(BestCS.Neuro.ActivationFunctions.IStochasticFunction,BestCS.Neuro.ActivationFunctions.IStochasticFunction,System.Int32,System.Int32[])">
            <summary>
              Creates a Mixed-Bernoulli network.
            </summary>
            
            <param name="visible">The <see cref="T:BestCS.Neuro.ActivationFunctions.IStochasticFunction"/> to be used in the first visible layer.</param>
            <param name="hidden">The <see cref="T:BestCS.Neuro.ActivationFunctions.IStochasticFunction"/> to be used in all other layers.</param>
            
            <param name="inputsCount">The number of inputs for the network.</param>
            <param name="hiddenNeurons">The number of hidden neurons in each layer.</param>
            
        </member>
        <member name="M:BestCS.Neuro.Networks.DeepBeliefNetwork.Save(System.IO.Stream)">
            <summary>
              Saves the network to a stream.
            </summary>
            
            <param name="stream">The stream to which the network is to be serialized.</param>
            
        </member>
        <member name="M:BestCS.Neuro.Networks.DeepBeliefNetwork.Save(System.String)">
            <summary>
              Saves the network to a stream.
            </summary>
            
            <param name="path">The file path to which the network is to be serialized.</param>
            
        </member>
        <member name="M:BestCS.Neuro.Networks.DeepBeliefNetwork.Load(System.IO.Stream)">
            <summary>
              Loads a network from a stream.
            </summary>
            
            <param name="stream">The network from which the machine is to be deserialized.</param>
            
            <returns>The deserialized network.</returns>
            
        </member>
        <member name="M:BestCS.Neuro.Networks.DeepBeliefNetwork.Load(System.String)">
            <summary>
              Loads a network from a file.
            </summary>
            
            <param name="path">The path to the file from which the network is to be deserialized.</param>
            
            <returns>The deserialized network.</returns>
            
        </member>
        <member name="P:BestCS.Neuro.Networks.DeepBeliefNetwork.OutputCount">
            <summary>
              Gets the number of output neurons in the network
              (the size of the computed output vectors).
            </summary>
            
        </member>
        <member name="P:BestCS.Neuro.Networks.DeepBeliefNetwork.Machines">
            <summary>
              Gets the Restricted Boltzmann Machines
              on each layer of this deep network.
            </summary>
            
        </member>
        <member name="T:BestCS.Neuro.DistanceNetwork">
             <summary>
             Distance network.
             </summary>
            
             <remarks>Distance network is a neural network of only one <see cref="T:BestCS.Neuro.DistanceLayer">distance
             layer</see>. The network is a base for such neural networks as SOM, Elastic net, etc.
             </remarks>
            
        </member>
        <member name="M:BestCS.Neuro.DistanceNetwork.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Neuro.DistanceNetwork"/> class.
            </summary>
            
            <param name="inputsCount">Network's inputs count.</param>
            <param name="neuronsCount">Network's neurons count.</param>
            
            <remarks>The new network is randomized (see <see cref="M:BestCS.Neuro.Neuron.Randomize"/>
            method) after it is created.</remarks>
            
        </member>
        <member name="M:BestCS.Neuro.DistanceNetwork.GetWinner">
            <summary>
            Get winner neuron.
            </summary>
            
            <returns>Index of the winner neuron.</returns>
            
            <remarks>The method returns index of the neuron, which weights have
            the minimum distance from network's input.</remarks>
            
        </member>
        <member name="T:BestCS.Neuro.Networks.RestrictedBoltzmannMachine">
            <summary>
              Restricted Boltzmann Machine.
            </summary>
            
            <example>
              <code>
              // Create some sample inputs and outputs. Note that the
              // first four vectors belong to one class, and the other
              // four belong to another (you should see that the 1s
              // accumulate on the beginning for the first four vectors
              // and on the end for the second four).
              
              double[][] inputs =
              {
                  new double[] { 1,1,1, 0,0,0 }, // class a
                  new double[] { 1,0,1, 0,0,0 }, // class a
                  new double[] { 1,1,1, 0,0,0 }, // class a
                  new double[] { 0,0,1, 1,1,0 }, // class b
                  new double[] { 0,0,1, 1,0,0 }, // class b
                  new double[] { 0,0,1, 1,1,0 }, // class b
              };
              
              double[][] outputs =
              {
                  new double[] { 1, 0 }, // indicates the inputs at this
                  new double[] { 1, 0 }, // position belongs to class a
                  new double[] { 1, 0 },
                  new double[] { 0, 1 }, // indicates the inputs at this
                  new double[] { 0, 1 }, // position belongs to class b
                  new double[] { 0, 1 },
              };
              
              // Create a Bernoulli activation function
              var function = new BernoulliFunction(alpha: 0.5);
              
              // Create a Restricted Boltzmann Machine for 6 inputs and with 1 hidden neuron
              var rbm = new RestrictedBoltzmannMachine(function, inputsCount: 6, hiddenNeurons: 2);
              
              // Create the learning algorithm for RBMs
              var teacher = new ContrastiveDivergenceLearning(rbm)
              {
                  Momentum = 0,
                  LearningRate = 0.1,
                  Decay = 0
              };
              
              // learn 5000 iterations
              for (int i = 0; i &lt; 5000; i++)
                  teacher.RunEpoch(inputs);
              
              // Compute the machine answers for the given inputs:
              double[] a = rbm.Compute(new double[] { 1, 1, 1, 0, 0, 0 }); // { 0.99, 0.00 }
              double[] b = rbm.Compute(new double[] { 0, 0, 0, 1, 1, 1 }); // { 0.00, 0.99 }
              
              // As we can see, the first neuron responds to vectors belonging
              // to the first class, firing 0.99 when we feed vectors which 
              // have 1s at the beginning. Likewise, the second neuron fires 
              // when the vector belongs to the second class.
              
              // We can also generate input vectors given the classes:
              double[] xa = rbm.GenerateInput(new double[] { 1, 0 }); // { 1, 1, 1, 0, 0, 0 }
              double[] xb = rbm.GenerateInput(new double[] { 0, 1 }); // { 0, 0, 1, 1, 1, 0 }
              
              // As we can see, if we feed an output pattern where the first neuron
              // is firing and the second isn't, the network generates an example of
              // a vector belonging to the first class. The same goes for the second
              // neuron and the second class.
            </code>
            </example>
            
            <seealso cref="T:BestCS.Neuro.Learning.ContrastiveDivergenceLearning"/>
            <seealso cref="T:BestCS.Neuro.ActivationFunctions.BernoulliFunction"/>
            
        </member>
        <member name="M:BestCS.Neuro.Networks.RestrictedBoltzmannMachine.#ctor(System.Int32,System.Int32)">
            <summary>
              Creates a new <see cref="T:BestCS.Neuro.Networks.RestrictedBoltzmannMachine"/>.
            </summary>
            
            <param name="inputsCount">The number of inputs for the machine.</param>
            <param name="hiddenNeurons">The number of hidden neurons in the machine.</param>
            
        </member>
        <member name="M:BestCS.Neuro.Networks.RestrictedBoltzmannMachine.#ctor(BestCS.Neuro.Layers.StochasticLayer,BestCS.Neuro.Layers.StochasticLayer)">
            <summary>
              Creates a new <see cref="T:BestCS.Neuro.Networks.RestrictedBoltzmannMachine"/>.
            </summary>
            
            <param name="hidden">The hidden layer to be added in the machine.</param>
            <param name="visible">The visible layer to be added in the machine.</param>
            
        </member>
        <member name="M:BestCS.Neuro.Networks.RestrictedBoltzmannMachine.#ctor(BestCS.Neuro.ActivationFunctions.IStochasticFunction,System.Int32,System.Int32)">
            <summary>
              Creates a new <see cref="T:BestCS.Neuro.Networks.RestrictedBoltzmannMachine"/>.
            </summary>
            
            <param name="function">The activation function to use in the network neurons.</param>
            <param name="inputsCount">The number of inputs for the machine.</param>
            <param name="hiddenNeurons">The number of hidden neurons in the machine.</param>
            
        </member>
        <member name="M:BestCS.Neuro.Networks.RestrictedBoltzmannMachine.Compute(System.Double[])">
            <summary>
              Compute output vector of the network.
            </summary>
            
            <param name="input">Input vector.</param>
            
            <returns>
              Returns network's output vector.
            </returns>
            
        </member>
        <member name="M:BestCS.Neuro.Networks.RestrictedBoltzmannMachine.Reconstruct(System.Double[])">
            <summary>
              Reconstructs a input vector for a given output.
            </summary>
            
            <param name="output">The output vector.</param>
            
            <returns>
              Returns a probable input vector which may 
              have originated the given output.
            </returns>
            
        </member>
        <member name="M:BestCS.Neuro.Networks.RestrictedBoltzmannMachine.GenerateOutput(System.Double[])">
            <summary>
              Samples an output vector from the network
              given an input vector.
            </summary>
            
            <param name="input">An input vector.</param>
            
            <returns>
              A possible output considering the
              stochastic activations of the network.
            </returns>
            
        </member>
        <member name="M:BestCS.Neuro.Networks.RestrictedBoltzmannMachine.GenerateInput(System.Double[])">
            <summary>
              Samples an input vector from the network
              given an output vector.
            </summary>
            
            <param name="output">An output vector.</param>
            
            <returns>
              A possible reconstruction considering the
              stochastic activations of the network.
            </returns>
            
        </member>
        <member name="M:BestCS.Neuro.Networks.RestrictedBoltzmannMachine.CreateGaussianBernoulli(System.Int32,System.Int32)">
            <summary>
              Constructs a Gaussian-Bernoulli network with 
              visible Gaussian units and hidden Bernoulli units.
            </summary>
            
            <param name="inputsCount">The number of inputs for the machine.</param>
            <param name="hiddenNeurons">The number of hidden neurons in the machine.</param>
            
            <returns>A Gaussian-Bernoulli Restricted Boltzmann Machine</returns>
            
        </member>
        <member name="M:BestCS.Neuro.Networks.RestrictedBoltzmannMachine.ToActivationNetwork(System.Int32)">
            <summary>
              Creates a new <see cref="T:BestCS.Neuro.ActivationNetwork"/> from this instance.
            </summary>
            
            <param name="outputs">The number of output neurons in the last layer.</param>
            
            <returns>An <see cref="T:BestCS.Neuro.ActivationNetwork"/> containing this network.</returns>
            
        </member>
        <member name="M:BestCS.Neuro.Networks.RestrictedBoltzmannMachine.ToActivationNetwork(BestCS.Neuro.IActivationFunction,System.Int32)">
            <summary>
              Creates a new <see cref="T:BestCS.Neuro.ActivationNetwork"/> from this instance.
            </summary>
            
            <param name="outputs">The number of output neurons in the last layer.</param>
            <param name="function">The activation function to use in the last layer.</param>
            
            <returns>An <see cref="T:BestCS.Neuro.ActivationNetwork"/> containing this network.</returns>
            
        </member>
        <member name="M:BestCS.Neuro.Networks.RestrictedBoltzmannMachine.UpdateVisibleWeights">
            <summary>
              Updates the weights of the visible layer by copying
              the reverse of the weights in the hidden layer.
            </summary>
            
        </member>
        <member name="P:BestCS.Neuro.Networks.RestrictedBoltzmannMachine.Visible">
            <summary>
              Gets the visible layer of the machine.
            </summary>
            
        </member>
        <member name="P:BestCS.Neuro.Networks.RestrictedBoltzmannMachine.Hidden">
            <summary>
              Gets the hidden layer of the machine.
            </summary>
            
        </member>
        <member name="T:BestCS.Neuro.ActivationNeuron">
            <summary>
            Activation neuron.
            </summary>
            
            <remarks><para>Activation neuron computes weighted sum of its inputs, adds
            threshold value and then applies <see cref="P:BestCS.Neuro.ActivationNeuron.ActivationFunction">activation function</see>.
            The neuron isusually used in multi-layer neural networks.</para></remarks>
            
            <seealso cref="T:BestCS.Neuro.IActivationFunction"/>
            
        </member>
        <member name="T:BestCS.Neuro.Neuron">
            <summary>
            Base neuron class.
            </summary>
            
            <remarks>This is a base neuron class, which encapsulates such
            common properties, like neuron's input, output and weights.</remarks>
            
        </member>
        <member name="F:BestCS.Neuro.Neuron.inputsCount">
            <summary>
            Neuron's inputs count.
            </summary>
        </member>
        <member name="F:BestCS.Neuro.Neuron.weights">
            <summary>
            Nouron's wieghts.
            </summary>
        </member>
        <member name="F:BestCS.Neuro.Neuron.output">
            <summary>
            Neuron's output value.
            </summary>
        </member>
        <member name="F:BestCS.Neuro.Neuron.rand">
            <summary>
            Random number generator.
            </summary>
            
            <remarks>The generator is used for neuron's weights randomization.</remarks>
            
        </member>
        <member name="F:BestCS.Neuro.Neuron.randRange">
            <summary>
            Random generator range.
            </summary>
            
            <remarks>Sets the range of random generator. Affects initial values of neuron's weight.
            Default value is [0, 1].</remarks>
            
        </member>
        <member name="M:BestCS.Neuro.Neuron.#ctor(System.Int32)">
             <summary>
             Initializes a new instance of the <see cref="T:BestCS.Neuro.Neuron"/> class.
             </summary>
            
             <param name="inputs">Neuron's inputs count.</param>
             
             <remarks>The new neuron will be randomized (see <see cref="M:BestCS.Neuro.Neuron.Randomize"/> method)
             after it is created.</remarks>
            
        </member>
        <member name="M:BestCS.Neuro.Neuron.Randomize">
            <summary>
            Randomize neuron.
            </summary>
            
            <remarks>Initialize neuron's weights with random values within the range specified
            by <see cref="P:BestCS.Neuro.Neuron.RandRange"/>.</remarks>
            
        </member>
        <member name="M:BestCS.Neuro.Neuron.Compute(System.Double[])">
            <summary>
            Computes output value of neuron.
            </summary>
            
            <param name="input">Input vector.</param>
            
            <returns>Returns neuron's output value.</returns>
            
            <remarks>The actual neuron's output value is determined by inherited class.
            The output value is also stored in <see cref="P:BestCS.Neuro.Neuron.Output"/> property.</remarks>
            
        </member>
        <member name="P:BestCS.Neuro.Neuron.RandGenerator">
            <summary>
            Random number generator.
            </summary>
            
            <remarks>The property allows to initialize random generator with a custom seed. The generator is
            used for neuron's weights randomization.</remarks>
            
        </member>
        <member name="P:BestCS.Neuro.Neuron.RandRange">
            <summary>
            Random generator range.
            </summary>
            
            <remarks>Sets the range of random generator. Affects initial values of neuron's weight.
            Default value is [0, 1].</remarks>
            
        </member>
        <member name="P:BestCS.Neuro.Neuron.InputsCount">
            <summary>
            Neuron's inputs count.
            </summary>
        </member>
        <member name="P:BestCS.Neuro.Neuron.Output">
            <summary>
            Neuron's output value.
            </summary>
            
            <remarks>The calculation way of neuron's output value is determined by inherited class.</remarks>
            
        </member>
        <member name="P:BestCS.Neuro.Neuron.Weights">
            <summary>
            Neuron's weights.
            </summary>
        </member>
        <member name="F:BestCS.Neuro.ActivationNeuron.threshold">
            <summary>
            Threshold value.
            </summary>
            
            <remarks>The value is added to inputs weighted sum before it is passed to activation
            function.</remarks>
            
        </member>
        <member name="F:BestCS.Neuro.ActivationNeuron.function">
            <summary>
            Activation function.
            </summary>
            
            <remarks>The function is applied to inputs weighted sum plus
            threshold value.</remarks>
            
        </member>
        <member name="M:BestCS.Neuro.ActivationNeuron.#ctor(System.Int32,BestCS.Neuro.IActivationFunction)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Neuro.ActivationNeuron"/> class.
            </summary>
            
            <param name="inputs">Neuron's inputs count.</param>
            <param name="function">Neuron's activation function.</param>
            
        </member>
        <member name="M:BestCS.Neuro.ActivationNeuron.Randomize">
            <summary>
            Randomize neuron.
            </summary>
            
            <remarks>Calls base class <see cref="M:BestCS.Neuro.Neuron.Randomize">Randomize</see> method
            to randomize neuron's weights and then randomizes threshold's value.</remarks>
            
        </member>
        <member name="M:BestCS.Neuro.ActivationNeuron.Compute(System.Double[])">
            <summary>
            Computes output value of neuron.
            </summary>
            
            <param name="input">Input vector.</param>
            
            <returns>Returns neuron's output value.</returns>
            
            <remarks><para>The output value of activation neuron is equal to value
            of nueron's activation function, which parameter is weighted sum
            of its inputs plus threshold value. The output value is also stored
            in <see cref="P:BestCS.Neuro.Neuron.Output">Output</see> property.</para>
            
            <para><note>The method may be called safely from multiple threads to compute neuron's
            output value for the specified input values. However, the value of
            <see cref="P:BestCS.Neuro.Neuron.Output"/> property in multi-threaded environment is not predictable,
            since it may hold neuron's output computed from any of the caller threads. Multi-threaded
            access to the method is useful in those cases when it is required to improve performance
            by utilizing several threads and the computation is based on the immediate return value
            of the method, but not on neuron's output property.</note></para>
            </remarks>
            
            <exception cref="T:System.ArgumentException">Wrong length of the input vector, which is not
            equal to the <see cref="P:BestCS.Neuro.Neuron.InputsCount">expected value</see>.</exception>
            
        </member>
        <member name="P:BestCS.Neuro.ActivationNeuron.Threshold">
            <summary>
            Threshold value.
            </summary>
            
            <remarks>The value is added to inputs weighted sum before it is passed to activation
            function.</remarks>
            
        </member>
        <member name="P:BestCS.Neuro.ActivationNeuron.ActivationFunction">
            <summary>
            Neuron's activation function.
            </summary>
            
        </member>
        <member name="T:BestCS.Neuro.DistanceNeuron">
            <summary>
            Distance neuron.
            </summary>
            
            <remarks><para>Distance neuron computes its output as distance between
            its weights and inputs - sum of absolute differences between weights'
            values and corresponding inputs' values. The neuron is usually used in Kohonen
            Self Organizing Map.</para></remarks>
            
        </member>
        <member name="M:BestCS.Neuro.DistanceNeuron.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Neuro.DistanceNeuron"/> class.
            </summary>
            
            <param name="inputs">Neuron's inputs count.</param>
            
        </member>
        <member name="M:BestCS.Neuro.DistanceNeuron.Compute(System.Double[])">
            <summary>
            Computes output value of neuron.
            </summary>
            
            <param name="input">Input vector.</param>
            
            <returns>Returns neuron's output value.</returns>
            
            <remarks><para>The output value of distance neuron is equal to the distance
            between its weights and inputs - sum of absolute differences.
            The output value is also stored in <see cref="P:BestCS.Neuro.Neuron.Output">Output</see>
            property.</para>
            
            <para><note>The method may be called safely from multiple threads to compute neuron's
            output value for the specified input values. However, the value of
            <see cref="P:BestCS.Neuro.Neuron.Output"/> property in multi-threaded environment is not predictable,
            since it may hold neuron's output computed from any of the caller threads. Multi-threaded
            access to the method is useful in those cases when it is required to improve performance
            by utilizing several threads and the computation is based on the immediate return value
            of the method, but not on neuron's output property.</note></para>
            </remarks>
            
            <exception cref="T:System.ArgumentException">Wrong length of the input vector, which is not
            equal to the <see cref="P:BestCS.Neuro.Neuron.InputsCount">expected value</see>.</exception>
            
        </member>
        <member name="T:BestCS.Neuro.Neurons.StochasticNeuron">
            <summary>
              Stochastic Activation Neuron.
            </summary>
            
            <remarks>
              The Stochastic Activation Neuron is an activation neuron
              which activates (returns 1) only within a given probability.
              The neuron has a random component in the activation function,
              and the neuron fires only if the total sum, after applied
              to a logistic activation function, is greater than a randomly
              sampled value.
            </remarks>
            
        </member>
        <member name="M:BestCS.Neuro.Neurons.StochasticNeuron.#ctor(System.Int32,BestCS.Neuro.ActivationFunctions.IStochasticFunction)">
            <summary>
              Initializes a new instance of the <see cref="T:BestCS.Neuro.Neurons.StochasticNeuron"/> class.
            </summary>
            
            <param name="inputs">Number of inputs for the neuron.</param>
            <param name="function">Activation function for the neuron.</param>
            
        </member>
        <member name="M:BestCS.Neuro.Neurons.StochasticNeuron.Compute(System.Double[])">
            <summary>
              Computes output value of neuron.
            </summary>
            
            <param name="input">An input vector.</param>
            
            <returns>Returns the neuron's output value for the given input.</returns>
            
        </member>
        <member name="M:BestCS.Neuro.Neurons.StochasticNeuron.Generate(System.Double[])">
            <summary>
              Samples the neuron output considering
              the stochastic activation function.
            </summary>
            
            <param name="input">An input vector.</param>
            
            <returns>A possible output for the neuron drawn
            from the neuron's stochastic function.</returns>
            
        </member>
        <member name="M:BestCS.Neuro.Neurons.StochasticNeuron.Generate(System.Double)">
            <summary>
              Samples the neuron output considering
              the stochastic activation function.
            </summary>
            
            <param name="output">The (previously computed) neuron output.</param>
            
            <returns>A possible output for the neuron drawn
            from the neuron's stochastic function.</returns>
            
        </member>
        <member name="P:BestCS.Neuro.Neurons.StochasticNeuron.Sample">
            <summary>
              Gets the neuron sample value generated in the last
              call of any of the <see cref="M:BestCS.Neuro.Neurons.StochasticNeuron.Generate(System.Double[])"/> methods.
            </summary>
            
        </member>
        <member name="P:BestCS.Neuro.Neurons.StochasticNeuron.ActivationFunction">
            <summary>
              Gets or sets the stochastic activation 
              function for this stochastic neuron.
            </summary>
            
        </member>
        <member name="T:BestCS.Neuro.Visualization.ActivationMaximization">
            <summary>
              Activation-Maximization method for visualizing neuron's roles.
            </summary>
            
        </member>
        <member name="M:BestCS.Neuro.Visualization.ActivationMaximization.#ctor(BestCS.Neuro.ActivationNeuron)">
            <summary>
              Initializes a new instance of the <see cref="T:BestCS.Neuro.Visualization.ActivationMaximization"/> class.
            </summary>
            
            <param name="neuron">The neuron to be visualized.</param>
            
        </member>
        <member name="M:BestCS.Neuro.Visualization.ActivationMaximization.Maximize">
            <summary>
              Finds the value which maximizes
              the activation of this neuron.
            </summary>
            
        </member>
        <member name="T:BestCS.Robotics.Surveyor.SRV1">
             <summary>
             Manipulation of Surveyor SRV-1 Blackfin robot/camera.
             </summary>
            
             <remarks>
             <para>The class allows to manipulate with <a href="http://www.surveyor.com/SRV_info.html">Surveyor SRV-1 Blackfin Robot</a>
             - getting video from its camera, manipulating motors and servos,
             reading ultrasonic modules' values, sending direct commands, etc.</para>
             
             <para><img src="img/robotics/srv1-robot.jpg" width="240" height="216"/></para>
             
             <para>Sample usage:</para>
             <code>
             SRV1 srv = new SRV1( );
             // connect to SRV-1 robot
             srv.Connect( "169.254.0.10", 10001 );
             // stop motors
             srv.StopMotors( );
             // set video resolution and quality
             srv.SetQuality( 7 );
             srv.SetResolution( SRV1.VideoResolution.Small );
             // get version string
             string version = srv.GetVersion( );
             
             // get robot's camera
             SRV1Camera camera = srv.GetCamera( );
             
             // set NewFrame event handler
             camera.NewFrame += new NewFrameEventHandler( video_NewFrame );
             // start the video source
             camera.Start( );
             // ...
             
             private void video_NewFrame( object sender, NewFrameEventArgs eventArgs )
             {
                 // get new frame
                 Bitmap bitmap = eventArgs.Frame;
                 // process the frame
             }
             </code>
             </remarks>
             
             <seealso cref="T:BestCS.Robotics.Surveyor.SRV1Camera"/>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SRV1.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Robotics.Surveyor.SRV1"/> class.
            </summary>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SRV1.Connect(System.String,System.Int32)">
            <summary>
            Connect to SRV-1 Blackfin robot/camera.
            </summary>
            
            <param name="ip">IP address of SRV-1 robot.</param>
            <param name="port">Port number to connect to.</param>
            
            <remarks><para>The method establishes connection to SRV-1 Blackfin robot/camera.
            If it succeeds then other methods can be used to manipulate the robot.</para>
            
            <para><note>The method calls <see cref="M:BestCS.Robotics.Surveyor.SRV1.Disconnect"/> before making any connection
            attempts to make sure previous connection is closed.</note></para>
            </remarks>
            
            <exception cref="T:BestCS.ConnectionFailedException">Failed connecting to SRV-1.</exception>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SRV1.Disconnect">
            <summary>
            Disconnect from SRV-1 Blackfin robot.
            </summary>
            
            <remarks><para>The method disconnects from SRV-1 robot making all other methods
            unavailable (except <see cref="M:BestCS.Robotics.Surveyor.SRV1.Connect(System.String,System.Int32)"/> method). In the case if user
            obtained instance of camera using <see cref="M:BestCS.Robotics.Surveyor.SRV1.GetCamera"/> method, the video will
            be stopped automatically (and those <see cref="T:BestCS.Robotics.Surveyor.SRV1Camera"/> instances should be discarded).
            </para></remarks>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SRV1.GetCamera">
            <summary>
            Get camera object for the SRV-1 Blackfin robot/camera.
            </summary>
            
            <returns>Returns <see cref="T:BestCS.Robotics.Surveyor.SRV1Camera"/> object, which is connected to SRV1 Blackfin camera.
            Use <see cref="M:BestCS.Robotics.Surveyor.SRV1Camera.Start"/> method to start the camera and start receiving video
            frames it.</returns>
            
            <remarks><para>The method provides an instance of <see cref="T:BestCS.Robotics.Surveyor.SRV1Camera"/>, which can be used
            for receiving continuous video frames from the SRV-1 Blackfin camera.
            In the case if only one image is required, the <see cref="M:BestCS.Robotics.Surveyor.SRV1.GetImage"/> method can be used.</para>
            
            <para>Sample usage:</para>
            <code>
            // get SRV-1 camera
            SRV1Camera camera = srv.GetCamera( );
            // set NewFrame event handler
            camera.NewFrame += new NewFrameEventHandler( video_NewFrame );
            // start the video source
            camera.Start( );
            // ...
            
            private void video_NewFrame( object sender, NewFrameEventArgs eventArgs )
            {
                // get new frame
                Bitmap bitmap = eventArgs.Frame;
                // process the frame
            }
            </code>
            </remarks>
            
            <exception cref="T:BestCS.NotConnectedException">Not connected to SRV-1. Connect to SRV-1 robot/camera
            before using this method.</exception>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SRV1.Send(System.Byte[])">
            <summary>
            Enqueue communication request.
            </summary>
            
            <param name="request">Array of bytes (command) to send to SRV-1 Blackfin robot/camera.</param>
            
            <remarks><para>The method puts specified command into communication queue and leaves
            immediately. Once internal communication thread becomes free from sending/receiving previous
            commands/replies, it will send the queued command.</para>
            
            <para>The method is useful for those SRV-1 commands, which does not assume any response data
            in the command's reply.</para>
            
            <para><note>Since the method only queues a communication request, it does not provide any status
            of request's delivery and it does not generate any exceptions on failure.</note></para>
            </remarks>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SRV1.SendAndReceive(System.Byte[],System.Byte[])">
            <summary>
            Enqueue communication request and wait for reply.
            </summary>
            
            <param name="request">Array of bytes (command) to send to SRV-1 Blackfin robot/camera.</param>
            <param name="responseBuffer">Buffer to read response into.</param>
            
            <returns>Returns total bytes read into the response buffer.</returns>
            
            <remarks><para>The method puts specified command into communication queue and waits until
            the command is sent to SRV-1 Blackfin robot and reply is received.</para>
            
            <para><note>If SRV-1 responds with more data than response buffer can fit, then
            the response buffer will take all the data it can store, but the rest of response
            will be discarded. The only exception is image request - if response buffer is too
            small to fit image response, then <see cref="T:System.IndexOutOfRangeException"/> exception
            is thrown. It is user's responsibility to provide response buffer of the correct
            size. Check definition of the <a href="http://www.surveyor.com/SRV_protocol.html">SRV-1
            Control Protocol</a> for information about supported commands and responses.</note></para>
            </remarks>
            
            <exception cref="T:BestCS.NotConnectedException">Not connected to SRV-1.</exception>
            <exception cref="T:BestCS.ConnectionLostException">Connection lost or communicaton failure.</exception>
            <exception cref="T:System.IndexOutOfRangeException">Response buffer is too small.</exception>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SRV1.GetImage">
            <summary>
            Get single image from the SRV-1 Blackfin camera.
            </summary>
            
            <returns>Returns image received from the SRV-1 Blackfin camera or <see langword="null"/>
            if failed decoding provided response.</returns>
            
            <remarks><para>The method provides single video frame retrieved from the SRV-1 Blackfin
            camera. However in many cases it is required to receive video frames one after another, so
            the <see cref="M:BestCS.Robotics.Surveyor.SRV1.GetCamera"/> method is more preferred for continuous video frames.</para></remarks>
            
            <exception cref="T:BestCS.NotConnectedException">Not connected to SRV-1. Connect to SRV-1 before using
            this method.</exception>
            <exception cref="T:BestCS.ConnectionLostException">Connection lost or communicaton failure. Try to reconnect.</exception>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SRV1.GetVersion">
            <summary>
            Get SRV-1 firmware version string.
            </summary>
            
            <returns>Returns SRV-1 version string.</returns>
            
            <exception cref="T:BestCS.NotConnectedException">Not connected to SRV-1. Connect to SRV-1 before using
            this method.</exception>
            <exception cref="T:BestCS.ConnectionLostException">Connection lost or communicaton failure. Try to reconnect.</exception>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SRV1.GetRunningTime">
            <summary>
            Get SRV-1 running time.
            </summary>
            
            <returns>Returns SRV-1 running time in milliseconds.</returns>
            
            <exception cref="T:BestCS.NotConnectedException">Not connected to SRV-1. Connect to SRV-1 before using
            this method.</exception>
            <exception cref="T:BestCS.ConnectionLostException">Connection lost or communicaton failure. Try to reconnect.</exception>
            <exception cref="T:System.ApplicationException">Failed parsing response from SRV-1.</exception>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SRV1.RunMotors(System.Int32,System.Int32,System.Int32)">
            <summary>
            Run motors connected to SRV-1 robot.
            </summary>
            
            <param name="leftSpeed">Left motor's speed, [-127, 127].</param>
            <param name="rightSpeed">Right motor's speed, [-127, 127].</param>
            <param name="duration">Time duration to run motors measured in number
            of 10 milliseconds (0 for infinity), [0, 255].</param>
            
            <remarks><para>The method provides direct access to motors setting specified,
            speed to both motors connected to the SRV-1 robot. The maximum absolute speed
            equals to 127, but the sign specifies direction of motor's rotation (forward or backward).
            </para>
            
            <para><note>The method sends 'Mabc' SRV-1 command (see <a href="http://www.surveyor.com/SRV_protocol.html">SRV-1
            Control Protocol</a>), which uses 2<sup>nd</sup> and 3<sup>rd</sup> timers for
            controlling motors/servos.</note></para>
            </remarks>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SRV1.StopMotors">
            <summary>
            Stop both motors.
            </summary>
            
            <remarks><para>The method stops both motors connected to the SRV-1 robot by calling
            <see cref="M:BestCS.Robotics.Surveyor.SRV1.RunMotors(System.Int32,System.Int32,System.Int32)"/> method specifying 0 for motors' speed.</para></remarks>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SRV1.EnableFailsafeMode(System.Int32,System.Int32)">
             <summary>
             Enables fail safe mode - setting motors' speed after timeout.
             </summary>
             
             <param name="leftSpeed">Left motor's speed, [-127, 127].</param>
             <param name="rightSpeed">Right motor's speed, [-127, 127].</param>
             
             <remarks><para>In the case if fail safe mode is enabled and no commands are received
             by SRV-1 robot withing 2 seconds, motors' speed will be set to the specified values. The command
             is very useful to instruct robot to stop if no other commands were sent
             within 2 last seconds (probably lost connection).</para></remarks>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SRV1.DisableFailsafeMode">
            <summary>
            Disable fail safe mode.
            </summary>
            
            <remarks><para>The method disable fail safe mode, which was set using
            <see cref="M:BestCS.Robotics.Surveyor.SRV1.EnableFailsafeMode(System.Int32,System.Int32)"/> method.</para></remarks>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SRV1.ControlServos(System.Int32,System.Int32)">
            <summary>
            Direct servos control of SRV-1 robot.
            </summary>
            
            <param name="leftServo">Left servo setting, [0, 100].</param>
            <param name="rightServo">Right servo setting, [0, 100].</param>
            
            <remarks><para>Servo settings represent timing pulse widths ranging
            from 1ms to 2ms. 0 corresponds to a 1ms pulse, 100 corresponds to a 2ms pulse,
            and 50 is midrange with a 1.5ms pulse.</para>
            
            <para><note>The method sends 'sab' SRV-1 command (see <a href="http://www.surveyor.com/SRV_protocol.html">SRV-1
            Control Protocol</a>), which controls 2<sup>nd</sup> bank of servos
            using 6<sup>th</sup> and 7<sup>th</sup> timers.</note></para>
            </remarks>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SRV1.ControlMotors(BestCS.Robotics.Surveyor.SRV1.MotorCommand)">
            <summary>
            Control SRV-1 robot's motors using predefined commands.
            </summary>
            
            <param name="command">Motor command to send to the SRV-1 Blackfin robot.</param>
            
            <remarks><para><note>Controlling SRV-1 motors with this method is only available
            after at least one direct motor command is sent, which is done using <see cref="M:BestCS.Robotics.Surveyor.SRV1.StopMotors"/> or
            <see cref="M:BestCS.Robotics.Surveyor.SRV1.RunMotors(System.Int32,System.Int32,System.Int32)"/> methods.</note></para></remarks>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SRV1.SetQuality(System.Int32)">
             <summary>
             Set video quality.
             </summary>
             
             <param name="quality">Video quality to set, [1, 8].</param>
            
             <remarks><para>The method sets video quality, which is specified in [1, 8] range - 1 is
             the highest quality level, 8 is the lowest quality level.</para>
             
             <para><note>Setting higher quality level and <see cref="M:BestCS.Robotics.Surveyor.SRV1.SetResolution(BestCS.Robotics.Surveyor.SRV1.VideoResolution)">resolution</see>
             may increase delays for other requests sent to SRV-1. So if
             robot is used not only for video, but also for controlling servos/motors, and higher
             response level is required, then do not set very high quality and resolution.
             </note></para>
             </remarks>
             
             <exception cref="T:System.ArgumentOutOfRangeException">Invalid quality level was specified.</exception>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SRV1.SetResolution(BestCS.Robotics.Surveyor.SRV1.VideoResolution)">
             <summary>
             Set video resolution.
             </summary>
             
             <param name="resolution">Video resolution to set.</param>
             
             <remarks>
             <para><note>Setting higher <see cref="M:BestCS.Robotics.Surveyor.SRV1.SetQuality(System.Int32)">quality level</see> and resolution
             may increase delays for other requests sent to SRV-1. So if
             robot is used not only for video, but also for controlling servos/motors, and higher
             response level is required, then do not set very high quality and resolution.
             </note></para>
             </remarks>
             
             <exception cref="T:System.ArgumentOutOfRangeException">Invalid resolution was specified.</exception>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SRV1.FlipVideo(System.Boolean)">
            <summary>
            Flip video capture or not (for use with upside-down camera).
            </summary>
            
            <param name="isFlipped">Specifies if video should be flipped (<see langword="true"/>),
            or not (<see langword="false"/>).</param>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SRV1.UltrasonicPing">
            <summary>
            Ping ultrasonic ranging modules.
            </summary>
            
            <returns>Returns array of ranges (distances) obtained from ultrasonic sensors. The ranges
            are measured in inches.</returns>
            
            <remarks><para>The method sends 'p' SRV-1 command (see <a href="http://www.surveyor.com/SRV_protocol.html">SRV-1
            Control Protocol</a>), which gets values from ultrasonic ranging modules attached to
            pins 27, 28, 29, 30 with trigger on pin 18. Supports Maxbotics EZ0 and EZ1 ultrasonic modules.
            </para></remarks>
            
            <exception cref="T:BestCS.NotConnectedException">Not connected to SRV-1. Connect to SRV-1 before using
            this method.</exception>
            <exception cref="T:BestCS.ConnectionLostException">Connection lost or communicaton failure. Try to reconnect.</exception>
            <exception cref="T:System.ApplicationException">Failed parsing response from SRV-1.</exception>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SRV1.I2CReadByte(System.Byte,System.Byte)">
            <summary>
            Read byte from I2C device.
            </summary>
            
            <param name="deviceID">I2C device ID (7 bit notation).</param>
            <param name="register">I2C device register to read.</param>
            
            <returns>Returns byte read from the specified register of the specified I2C device.</returns>
            
            <para><note>The IC2 device ID should be specified in 7 bit notation. This means that low bit of the ID
            is not used for specifying read/write mode as in 8 bit notation. For example, if I2C device IDs are 0x44 for reading
            and 0x45 for writing in 8 bit notation, then it equals to 0x22 device ID in 7 bit notation.
            </note></para>
            
            <exception cref="T:BestCS.NotConnectedException">Not connected to SRV-1. Connect to SRV-1 before using
            this method.</exception>
            <exception cref="T:BestCS.ConnectionLostException">Connection lost or communicaton failure. Try to reconnect.</exception>
            <exception cref="T:System.ApplicationException">Failed parsing response from SRV-1.</exception>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SRV1.I2CReadWord(System.Byte,System.Byte)">
            <summary>
            Read word from I2C device.
            </summary>
            
            <param name="deviceID">I2C device ID (7 bit notation).</param>
            <param name="register">I2C device register to read.</param>
            
            <returns>Returns word read from the specified register of the specified I2C device.</returns>
            
            <para><note>The IC2 device ID should be specified in 7 bit notation. This means that low bit of the ID
            is not used for specifying read/write mode as in 8 bit notation. For example, if I2C device IDs are 0x44 for reading
            and 0x45 for writing in 8 bit notation, then it equals to 0x22 device ID in 7 bit notation.
            </note></para>
            
            <exception cref="T:BestCS.NotConnectedException">Not connected to SRV-1. Connect to SRV-1 before using
            this method.</exception>
            <exception cref="T:BestCS.ConnectionLostException">Connection lost or communicaton failure. Try to reconnect.</exception>
            <exception cref="T:System.ApplicationException">Failed parsing response from SRV-1.</exception>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SRV1.I2CWriteByte(System.Byte,System.Byte,System.Byte)">
            <summary>
            Write byte to I2C device.
            </summary>
            
            <param name="deviceID">I2C device ID (7 bit notation).</param>
            <param name="register">I2C device register to write to.</param>
            <param name="byteToWrite">Byte to write to the specified register of the specified device.</param>
            
            <para><note>The IC2 device ID should be specified in 7 bit notation. This means that low bit of the ID
            is not used for specifying read/write mode as in 8 bit notation. For example, if I2C device IDs are 0x44 for reading
            and 0x45 for writing in 8 bit notation, then it equals to 0x22 device ID in 7 bit notation.
            </note></para>
            
            <exception cref="T:BestCS.NotConnectedException">Not connected to SRV-1. Connect to SRV-1 before using
            this method.</exception>
            <exception cref="T:BestCS.ConnectionLostException">Connection lost or communicaton failure. Try to reconnect.</exception>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SRV1.I2CWriteWord(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Write two bytes to I2C device.
            </summary>
            
            <param name="deviceID">I2C device ID (7 bit notation).</param>
            <param name="register">I2C device register to write to.</param>
            <param name="firstByteToWrite">First byte to write to the specified register of the specified device.</param>
            <param name="secondByteToWrite">Second byte to write to the specified register of the specified device.</param>
            
            <para><note>The IC2 device ID should be specified in 7 bit notation. This means that low bit of the ID
            is not used for specifying read/write mode as in 8 bit notation. For example, if I2C device IDs are 0x44 for reading
            and 0x45 for writing in 8 bit notation, then it equals to 0x22 device ID in 7 bit notation.
            </note></para>
            
            <exception cref="T:BestCS.NotConnectedException">Not connected to SRV-1. Connect to SRV-1 before using
            this method.</exception>
            <exception cref="T:BestCS.ConnectionLostException">Connection lost or communicaton failure. Try to reconnect.</exception>
            
        </member>
        <member name="P:BestCS.Robotics.Surveyor.SRV1.HostAddress">
             <summary>
             SRV-1 host address.
             </summary>
             
             <remarks><para>The property keeps SRV-1 IP address if the class is connected
             to SRV-1 Blackfin robot/camera, otherwise it equals to <see langword="null."/>.</para></remarks>
            
        </member>
        <member name="P:BestCS.Robotics.Surveyor.SRV1.Port">
             <summary>
             SRV-1 port number.
             </summary>
             
             <remarks><para>The property keeps SRV-1 port number if the class is connected
             to SRV-1 Blackfin robot/camera, otherwise it equals to 0.</para></remarks>
            
        </member>
        <member name="P:BestCS.Robotics.Surveyor.SRV1.IsConnected">
            <summary>
            Connection state.
            </summary>
            
            <remarks><para>The property equals to <see langword="true"/> if the class is connected
            to SRV-1 Blackfin robot/camera, otherwise it equals to <see langword="false"/>.</para>
            
            <para><note>The property is not updated by the class, when connection was lost or
            communication failure was detected (which results into <see cref="T:BestCS.ConnectionLostException"/>
            exception). The property only shows status of <see cref="M:BestCS.Robotics.Surveyor.SRV1.Connect(System.String,System.Int32)"/> method.</note></para>
            </remarks>
            
        </member>
        <member name="T:BestCS.Robotics.Surveyor.SRV1.MotorCommand">
            <summary>
            Enumeration of predefined motors' commands.
            </summary>
            
            <remarks><para>This enumeration defines set of motors' commands, which can
            be executed using <see cref="M:BestCS.Robotics.Surveyor.SRV1.ControlMotors(BestCS.Robotics.Surveyor.SRV1.MotorCommand)"/> method.</para>
            
            <para><note>Controlling SRV-1 motors with these commands is only possible
            after at least one direct motor command is sent, which is done using <see cref="M:BestCS.Robotics.Surveyor.SRV1.StopMotors"/> or
            <see cref="M:BestCS.Robotics.Surveyor.SRV1.RunMotors(System.Int32,System.Int32,System.Int32)"/> methods.</note></para>
            
            <para><note>The <b>IncreaseSpeed</b> and <b>DecreaseSpeed</b> commands do not have any effect
            unless another driving command is sent. In other words, these do not increase/decrease speed of
            current operation, but affect speed of all following commands.</note></para>
            
            <para><note>The <b>RotateLeft</b> and <b>RotateRight</b> commands may be useful only for the original
            <a href="http://www.surveyor.com/SRV_info.html">Surveyor SRV-1 Blackfin Robot</a>.
            For most of other robots, which may have different motors and moving base, these commands
            will not be accurate  will not rotate for 20 degrees.
            </note></para>
            </remarks>
            
        </member>
        <member name="F:BestCS.Robotics.Surveyor.SRV1.MotorCommand.DriveForward">
            <summary>
            Robot drive forward.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Surveyor.SRV1.MotorCommand.DriveBack">
            <summary>
            Robot drive back.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Surveyor.SRV1.MotorCommand.DriveLeft">
            <summary>
            Robot drive left.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Surveyor.SRV1.MotorCommand.DriveRight">
            <summary>
            Robot drive right.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Surveyor.SRV1.MotorCommand.DriftLeft">
            <summary>
            Robot drift left.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Surveyor.SRV1.MotorCommand.DriftRight">
            <summary>
            Robot drift right.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Surveyor.SRV1.MotorCommand.Stop">
            <summary>
            Robot stop.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Surveyor.SRV1.MotorCommand.DriveBackRight">
            <summary>
            Robot drive back and right.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Surveyor.SRV1.MotorCommand.DriveBackLeft">
            <summary>
            Robot drive back and left.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Surveyor.SRV1.MotorCommand.RotateLeft">
            <summary>
            Robot rotate left 20 degrees.
            </summary>
            
        </member>
        <member name="F:BestCS.Robotics.Surveyor.SRV1.MotorCommand.RotateRight">
            <summary>
            Robot rotate right 20 degrees.
            </summary>
            
        </member>
        <member name="F:BestCS.Robotics.Surveyor.SRV1.MotorCommand.IncreaseSpeed">
             <summary>
             Increase motors' speed.
             </summary>
            
        </member>
        <member name="F:BestCS.Robotics.Surveyor.SRV1.MotorCommand.DecreaseSpeed">
            <summary>
            Decrease motors' speed.
            </summary>
            
        </member>
        <member name="T:BestCS.Robotics.Surveyor.SRV1.VideoResolution">
            <summary>
            Enumeration of Surveyor SRV-1 Blackfin cameras resolutions.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Surveyor.SRV1.VideoResolution.Tiny">
            <summary>
            160x120
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Surveyor.SRV1.VideoResolution.Small">
            <summary>
            320x240
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Surveyor.SRV1.VideoResolution.Medium">
            <summary>
            640x480
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Surveyor.SRV1.VideoResolution.Large">
            <summary>
            1280x1024
            </summary>
        </member>
        <member name="T:BestCS.Robotics.Surveyor.SRV1Camera">
            <summary>
            Provides access to video stream from Surveyor SRV-1 Blackfin camera.
            </summary>
            
            <remarks><para>The class allows to continuously receive video frames from
            Surveyor SRV-1 Blackfin camera. It creates a background thread and periodically requests
            new video frames from SRV-1 robot/camera, which are provided to user through <see cref="E:BestCS.Robotics.Surveyor.SRV1Camera.NewFrame"/>
            event. The video frame rate can be configured using <see cref="P:BestCS.Robotics.Surveyor.SRV1Camera.FrameInterval"/>
            property, which sets time interval between frames.</para>
            
            <para>In order to get instance of this class, use <see cref="M:BestCS.Robotics.Surveyor.SRV1.GetCamera"/>
            or <see cref="M:BestCS.Robotics.Surveyor.SVS.GetCamera(BestCS.Robotics.Surveyor.SVS.Camera)"/> methods.</para>
            
            <para>Sample usage:</para>
            <code>
            // get SRV-1 camera
            SRV1Camera camera = srv.GetCamera( );
            // in the case you work with Surveyor SVS board
            // the next line can be use
            // SRV1Camera camera = svs.GetCamera( SVS.Camera.Left );
            
            // set NewFrame event handler
            camera.NewFrame += new NewFrameEventHandler( video_NewFrame );
            // start the video source
            camera.Start( );
            // ...
            
            private void video_NewFrame( object sender, NewFrameEventArgs eventArgs )
            {
                // get new frame
                Bitmap bitmap = eventArgs.Frame;
                // process the frame
            }
            </code>
            </remarks>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SRV1Camera.Start">
            <summary>
            Start video source.
            </summary>
            
            <remarks>Starts video source and return execution to caller. Video source
            object creates background thread and notifies about new frames with the
            help of <see cref="E:BestCS.Robotics.Surveyor.SRV1Camera.NewFrame"/> event.</remarks>
            
            <exception cref="T:BestCS.NotConnectedException">Not connected to SRV-1. Connection to SRV-1
            was closed using <see cref="M:BestCS.Robotics.Surveyor.SRV1.Disconnect"/> method. New <see cref="T:BestCS.Robotics.Surveyor.SRV1Camera"/>
            instance must be obtained using <see cref="M:BestCS.Robotics.Surveyor.SRV1.GetCamera"/> or
            <see cref="M:BestCS.Robotics.Surveyor.SVS.GetCamera(BestCS.Robotics.Surveyor.SVS.Camera)"/> methods.
            </exception>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SRV1Camera.SignalToStop">
            <summary>
            Signal video source to stop its work.
            </summary>
            
            <remarks>Signals video source to stop its background thread, stop to
            provide new frames and free resources.</remarks>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SRV1Camera.WaitForStop">
            <summary>
            Wait for video source has stopped.
            </summary>
            
            <remarks>Waits for video source stopping after it was signalled to stop using
            <see cref="M:BestCS.Robotics.Surveyor.SRV1Camera.SignalToStop"/> method.</remarks>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SRV1Camera.Stop">
            <summary>
            Stop video source.
            </summary>
            
            <remarks><para>Stops video source aborting its thread.</para>
            
            <para><note>Since the method aborts background thread, its usage is highly not preferred
            and should be done only if there are no other options. The correct way of stopping camera
            is <see cref="M:BestCS.Robotics.Surveyor.SRV1Camera.SignalToStop">signaling it to stop</see> and then
            <see cref="M:BestCS.Robotics.Surveyor.SRV1Camera.WaitForStop">waiting</see> for background thread's completion.</note></para>
            </remarks>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SRV1Camera.Free">
            <summary>
            Free resource.
            </summary>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SRV1Camera.SetQuality(System.Int32)">
             <summary>
             Set video quality.
             </summary>
             
             <param name="quality">Video quality to set, [1, 8].</param>
            
             <remarks><para>The method sets video quality, which is specified in [1, 8] range - 1 is
             the highest quality level, 8 is the lowest quality level.</para>
             
             <para><note>Setting higher quality level and <see cref="M:BestCS.Robotics.Surveyor.SRV1Camera.SetResolution(BestCS.Robotics.Surveyor.SRV1.VideoResolution)">resolution</see>
             may increase delays for other requests processed by <see cref="T:BestCS.Robotics.Surveyor.SRV1"/> class. So if
             robot is used not only for video, but also for controlling servos/motors, and higher
             response level is required, then do not set very high quality and resolution.
             </note></para>
             </remarks>
             
             <exception cref="T:System.ArgumentOutOfRangeException">Invalid quality level was specified.</exception>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SRV1Camera.SetResolution(BestCS.Robotics.Surveyor.SRV1.VideoResolution)">
            <summary>
            Set video resolution.
            </summary>
            
            <param name="resolution">Video resolution to set.</param>
            
            <remarks>
            <para><note>Setting higher <see cref="M:BestCS.Robotics.Surveyor.SRV1Camera.SetQuality(System.Int32)">quality level</see> and resolution
            may increase delays for other requests processed by <see cref="T:BestCS.Robotics.Surveyor.SRV1"/> class. So if
            robot is used not only for video, but also for controlling servos/motors, and higher
            response level is required, then do not set very high quality and resolution.
            </note></para>
            </remarks>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SRV1Camera.FlipVideo(System.Boolean)">
            <summary>
            Flip video capture or not (for use with upside-down camera).
            </summary>
            
            <param name="isFlipped">Specifies if video should be flipped (<see langword="true"/>),
            or not (<see langword="false"/>).</param>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SRV1Camera.WorkerThread">
            <summary>
            Worker thread.
            </summary>
            
        </member>
        <member name="E:BestCS.Robotics.Surveyor.SRV1Camera.NewFrame">
            <summary>
            New frame event.
            </summary>
            
            <remarks><para>Notifies clients about new available frame from video source.</para>
            
            <para><note>Since video source may have multiple clients, each client is responsible for
            making a copy (cloning) of the passed video frame, because the video source disposes its
            own original copy after notifying of clients.</note></para>
            </remarks>
            
        </member>
        <member name="E:BestCS.Robotics.Surveyor.SRV1Camera.VideoSourceError">
            <summary>
            Video source error event.
            </summary>
            
            <remarks>This event is used to notify clients about any type of errors occurred in
            video source object, for example internal exceptions.</remarks>
            
        </member>
        <member name="E:BestCS.Robotics.Surveyor.SRV1Camera.PlayingFinished">
            <summary>
            Video playing finished event.
            </summary>
            
            <remarks><para>This event is used to notify clients that the video playing has finished.</para>
            </remarks>
            
        </member>
        <member name="P:BestCS.Robotics.Surveyor.SRV1Camera.FrameInterval">
            <summary>
            Frame interval.
            </summary>
            
            <remarks><para>The property sets the interval in milliseconds betwen frames. If the property is
            set to 100, then the desired frame rate will be 10 frames per second.</para>
            
            <para>Default value is set to <b>0</b> - get new frames as fast as possible.</para>
            </remarks>
            
        </member>
        <member name="P:BestCS.Robotics.Surveyor.SRV1Camera.Source">
            <summary>
            Video source string.
            </summary>
            
            <remarks>
            <para>The property keeps connection string, which was used to connect to SRV-1 Blackfin camera.</para>
            </remarks>
            
        </member>
        <member name="P:BestCS.Robotics.Surveyor.SRV1Camera.FramesReceived">
            <summary>
            Received frames count.
            </summary>
            
            <remarks>Number of frames the video source provided from the moment of the last
            access to the property.
            </remarks>
            
        </member>
        <member name="P:BestCS.Robotics.Surveyor.SRV1Camera.BytesReceived">
            <summary>
            Received bytes count.
            </summary>
            
            <remarks>Number of bytes the video source provided from the moment of the last
            access to the property.
            </remarks>
            
        </member>
        <member name="P:BestCS.Robotics.Surveyor.SRV1Camera.IsRunning">
            <summary>
            State of the video source.
            </summary>
            
            <remarks>Current state of video source object - running or not.</remarks>
            
        </member>
        <member name="T:BestCS.Robotics.Surveyor.SVS">
            <summary>
            Manipulation of Surveyor SVS (Stereo Vision System) board.
            </summary>
            
            <remarks>
            <para>The class allows to manipulate with <a href="http://www.surveyor.com/stereo/stereo_info.html">Surveyor SVS</a>
            board (stereo vision system) - getting video from both cameras, manipulating motors and servos,
            reading ultrasonic modules' values, sending direct commands, etc.</para>
            
            <para><img src="img/robotics/svs.jpg" width="320" height="189"/></para>
            
            <para>This class essentially creates to instances of <see cref="T:BestCS.Robotics.Surveyor.SRV1"/> class to communicate
            with both SVS's cameras (ports 10001 and 10002 are used) and directs all calls through them.</para>
            
            <para>Sample usage:</para>
            <code>
            SVS svs = new SVS( );
            // connect to SVS board
            svs.Connect( "169.254.0.10" );
            // stop motors
            svs.StopMotors( );
            // set video resolution and quality
            svs.SetQuality( 7 );
            svs.SetResolution( SRV1.VideoResolution.Small );
            // get version string
            string version = svs.GetVersion( );
            
            // get left camera
            SRV1Camera camera = svs.GetCamera( SVS.Camera.Left );
            
            // set NewFrame event handler
            camera.NewFrame += new NewFrameEventHandler( video_NewFrame );
            // start the video source
            camera.Start( );
            // ...
            
            private void video_NewFrame( object sender, NewFrameEventArgs eventArgs )
            {
                // get new frame
                Bitmap bitmap = eventArgs.Frame;
                // process the frame
            }
            </code>
            </remarks>
            
            <seealso cref="T:BestCS.Robotics.Surveyor.SRV1Camera"/>
            <seealso cref="T:BestCS.Robotics.Surveyor.SRV1"/>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SVS.#ctor">
             <summary>
             Initializes a new instance of the <see cref="T:BestCS.Robotics.Surveyor.SVS"/> class.
             </summary>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SVS.Connect(System.String)">
            <summary>
            Connect to SVS board.
            </summary>
            
            <param name="ipAddress">IP address of SVS board.</param>
            
            <remarks><para>The method establishes connection to SVS board. If it succeeds then
            other methods can be used to manipulate the board.</para>
            
            <para><note>The method calls <see cref="M:BestCS.Robotics.Surveyor.SVS.Disconnect"/> before making any connection
            attempts to make sure previous connection is closed.</note></para>
            </remarks>
            
            <exception cref="T:BestCS.ConnectionFailedException">Failed connecting to SVS.</exception>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SVS.Disconnect">
            <summary>
            Disconnect from SVS device.
            </summary>
            
            <remarks><para>The method disconnects from SVS board making all other methods
            unavailable (except <see cref="M:BestCS.Robotics.Surveyor.SVS.Connect(System.String)"/> method). In the case if user
            obtained instance of left or right camera using <see cref="M:BestCS.Robotics.Surveyor.SVS.GetCamera(BestCS.Robotics.Surveyor.SVS.Camera)"/>
            method, the video will be stopped automatically (and those <see cref="T:BestCS.Robotics.Surveyor.SRV1Camera"/>
            instances should be discarded).
            </para></remarks>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SVS.GetCamera(BestCS.Robotics.Surveyor.SVS.Camera)">
            <summary>
            Get SVS's camera.
            </summary>
            
            <param name="camera">SVS camera to get.</param>
            
            <returns>Returns <see cref="T:BestCS.Robotics.Surveyor.SRV1Camera"/> object, which is connected to SVS's Blackfin camera.
            Use <see cref="M:BestCS.Robotics.Surveyor.SRV1Camera.Start"/> method to start the camera and start receiving video
            frames from it.</returns>
            
            <remarks><para>The method provides an instance of <see cref="T:BestCS.Robotics.Surveyor.SRV1Camera"/>, which can be used
            for receiving continuous video frames from the SVS board.
            In the case if only one image is required, the <see cref="M:BestCS.Robotics.Surveyor.SVS.GetImage(BestCS.Robotics.Surveyor.SVS.Camera)"/> method can be used.</para>
            
            <para>Sample usage:</para>
            <code>
            // get SRV-1 camera
            SRV1Camera camera = svs.GetCamera( SVS.Camera.Left );
            // set NewFrame event handler
            camera.NewFrame += new NewFrameEventHandler( video_NewFrame );
            // start the video source
            camera.Start( );
            // ...
            
            private void video_NewFrame( object sender, NewFrameEventArgs eventArgs )
            {
                // get new frame
                Bitmap bitmap = eventArgs.Frame;
                // process the frame
            }
            </code>
            </remarks>
            
            <exception cref="T:BestCS.NotConnectedException">Not connected to SVS. Connect to SVS board before using
            this method.</exception>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SVS.GetImage(BestCS.Robotics.Surveyor.SVS.Camera)">
             <summary>
             Get single image from the SVS board.
             </summary>
             
             <param name="camera">Camera to get image from.</param>
             
             <returns>Returns image received from the specified camera of the SVS board or
             <see langword="null"/> if failed decoding provided response.</returns>
             
             <remarks><para>The method provides single video frame retrieved from the specified SVS's
             camera. However in many cases it is required to receive video frames one after another, so
             the <see cref="M:BestCS.Robotics.Surveyor.SVS.GetCamera(BestCS.Robotics.Surveyor.SVS.Camera)"/> method is more preferred for continuous video frames.</para></remarks>
            
             <exception cref="T:BestCS.NotConnectedException">Not connected to SRV-1. Connect to SRV-1 before using
             this method.</exception>
             <exception cref="T:BestCS.ConnectionLostException">Connection lost or communicaton failure. Try to reconnect.</exception>
             
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SVS.GetDirectAccessToSRV1(BestCS.Robotics.Surveyor.SVS.Camera)">
             <summary>
             Get direct access to one of the SVS's SRV-1 Blackfin cameras.
             </summary>
             
             <param name="camera">SRV-1 Blackfin to get direct access to.</param>
             
             <returns>Returns <see cref="T:BestCS.Robotics.Surveyor.SRV1"/> object connected to the requested
             SRV-1 Blackfin camera.</returns>
             
             <remarks><para>The method provides direct access to one of the SVS's SRV-1
             Blackfin cameras, so it could be possible to send some direct commands to it
             using <see cref="M:BestCS.Robotics.Surveyor.SRV1.Send(System.Byte[])"/> and <see cref="M:BestCS.Robotics.Surveyor.SRV1.SendAndReceive(System.Byte[],System.Byte[])"/> methods.</para></remarks>
             
             <exception cref="T:BestCS.NotConnectedException">Not connected to SVS. Connect to SVS board before using
             this method.</exception>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SVS.GetVersion">
            <summary>
            Get SVS board's firmware version string.
            </summary>
            
            <returns>Returns SVS's version string.</returns>
            
            <exception cref="T:BestCS.NotConnectedException">Not connected to SVS. Connect to SVS board before using
            this method.</exception>
            <exception cref="T:BestCS.ConnectionLostException">Connection lost or communicaton failure. Try to reconnect.</exception>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SVS.GetRunningTime">
            <summary>
            Get SVS's board's running time.
            </summary>
            
            <returns>Returns SVS boards running time in milliseconds.</returns>
            
            <exception cref="T:BestCS.NotConnectedException">Not connected to SVS. Connect to SVS board before using
            this method.</exception>
            <exception cref="T:BestCS.ConnectionLostException">Connection lost or communicaton failure. Try to reconnect.</exception>
            <exception cref="T:System.ApplicationException">Failed parsing response from SVS.</exception>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SVS.RunMotors(System.Int32,System.Int32,System.Int32)">
            <summary>
            Run motors connected to the SVS board.
            </summary>
            
            <param name="leftSpeed">Left motor's speed, [-127, 127].</param>
            <param name="rightSpeed">Right motor's speed, [-127, 127].</param>
            <param name="duration">Time duration to run motors measured in number
            of 10 milliseconds (0 for infinity), [0, 255].</param>
            
            <remarks><para>The method sets specified speed to both motors connected to
            the SVS board. The maximum absolute speed equals to 127, but the sign specifies
            direction of motor's rotation (forward or backward).
            </para></remarks>
            
            <exception cref="T:BestCS.NotConnectedException">Not connected to SVS. Connect to SVS board before using
            this method.</exception>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SVS.StopMotors">
            <summary>
            Stop both motors.
            </summary>
            
            <remarks><para>The method stops both motors connected to the SVS board by calling
            <see cref="M:BestCS.Robotics.Surveyor.SVS.RunMotors(System.Int32,System.Int32,System.Int32)"/> method specifying 0 for motors' speed.</para></remarks>
            
            <exception cref="T:BestCS.NotConnectedException">Not connected to SVS. Connect to SVS board before using
            this method.</exception>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SVS.EnableFailsafeMode(System.Int32,System.Int32)">
            <summary>
            Enables fail safe mode - setting motors' speed after timeout.
            </summary>
            
            <param name="leftSpeed">Left motor's speed, [-127, 127].</param>
            <param name="rightSpeed">Right motor's speed, [-127, 127].</param>
            
            <remarks><para>In the case if fail safe mode is enabled and no commands are received
            by SVS robot withing 2 seconds, motors' speed will be set to the specified values. The command
            is very useful to instruct robot to stop if no other commands were sent
            within 2 last seconds (probably lost connection).</para></remarks>
            
            <exception cref="T:BestCS.NotConnectedException">Not connected to SVS. Connect to SVS board before using
            this method.</exception>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SVS.DisableFailsafeMode">
            <summary>
            Disable fail safe mode.
            </summary>
            
            <remarks><para>The method disable fail safe mode, which was set using
            <see cref="M:BestCS.Robotics.Surveyor.SVS.EnableFailsafeMode(System.Int32,System.Int32)"/> method.</para></remarks>
            
            <exception cref="T:BestCS.NotConnectedException">Not connected to SVS. Connect to SVS board before using
            this method.</exception>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SVS.ControlMotors(BestCS.Robotics.Surveyor.SRV1.MotorCommand)">
            <summary>
            Control motors connected to SVS board using predefined commands.
            </summary>
            
            <param name="command">Motor command to send to the SVS board.</param>
            
            <remarks><para><note>Controlling SVS motors with this method is only available
            after at least one direct motor command is sent, which is done using <see cref="M:BestCS.Robotics.Surveyor.SVS.StopMotors"/> or
            <see cref="M:BestCS.Robotics.Surveyor.SVS.RunMotors(System.Int32,System.Int32,System.Int32)"/> methods.</note></para></remarks>
            
            <exception cref="T:BestCS.NotConnectedException">Not connected to SVS. Connect to SVS board before using
            this method.</exception>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SVS.ControlServos(BestCS.Robotics.Surveyor.SVS.ServosBank,System.Int32,System.Int32)">
            <summary>
            Direct servos control of the SVS board.
            </summary>
            
            <param name="servosBank">SVS's servo bank to control.</param>
            <param name="leftServo">Left servo setting, [0, 100].</param>
            <param name="rightServo">Right servo setting, [0, 100].</param>
            
            <remarks><para>The method performs servos control of the SVS board.
            For <see cref="F:BestCS.Robotics.Surveyor.SVS.ServosBank.Bank1"/> and <see cref="F:BestCS.Robotics.Surveyor.SVS.ServosBank.Bank3"/>
            banks it calls <see cref="M:BestCS.Robotics.Surveyor.SRV1.ControlServos(System.Int32,System.Int32)"/> method for the corresponding
            SRV-1 Blackfin camera. In the case of <see cref="F:BestCS.Robotics.Surveyor.SVS.ServosBank.Bank0"/> or <see cref="F:BestCS.Robotics.Surveyor.SVS.ServosBank.Bank2"/>,
            the method sends 'Sab' SRV-1 command (see <a href="http://www.surveyor.com/SRV_protocol.html">SRV-1
            Control Protocol</a>) to the appropriate SRV-1 Blackfin camera.</para>
            </remarks>
            
            <exception cref="T:BestCS.NotConnectedException">Not connected to SVS. Connect to SVS board before using
            this method.</exception>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SVS.UltrasonicPing(BestCS.Robotics.Surveyor.SVS.Camera)">
            <summary>
            Ping ultrasonic ranging modules.
            </summary>
            
            <param name="camera">SRV-1 Blackfin camera to check ultrasonic modules values.</param>
            
            <returns>Returns array of ranges (distances) obtained from ultrasonic sensors. The ranges
            are measured in inches.</returns>
            
            <remarks><para>The method calls <see cref="M:BestCS.Robotics.Surveyor.SRV1.UltrasonicPing"/> for the specified
            SRV-1 Blackfin camera.</para></remarks>
            
            <exception cref="T:BestCS.NotConnectedException">Not connected to SVS. Connect to SVS board before using
            this method.</exception>
            <exception cref="T:BestCS.ConnectionLostException">Connection lost or communicaton failure. Try to reconnect.</exception>
            <exception cref="T:System.ApplicationException">Failed parsing response from SVS.</exception>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SVS.I2CReadByte(BestCS.Robotics.Surveyor.SVS.Camera,System.Byte,System.Byte)">
            <summary>
            Read byte from I2C device.
            </summary>
            
            <param name="camera">SRV-1 Blackfin camera to access I2C device on.</param>
            <param name="deviceID">I2C device ID (7 bit notation).</param>
            <param name="register">I2C device register to read.</param>
            
            <returns>Returns byte read from the specified register of the specified I2C device.</returns>
            
            <para><note>The IC2 device ID should be specified in 7 bit notation. This means that low bit of the ID
            is not used for specifying read/write mode as in 8 bit notation. For example, if I2C device IDs are 0x44 for reading
            and 0x45 for writing in 8 bit notation, then it equals to 0x22 device ID in 7 bit notation.
            </note></para>
            
            <exception cref="T:BestCS.NotConnectedException">Not connected to SVS. Connect to SVS board before using
            this method.</exception>
            <exception cref="T:BestCS.ConnectionLostException">Connection lost or communicaton failure. Try to reconnect.</exception>
            <exception cref="T:System.ApplicationException">Failed parsing response from SRV-1.</exception>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SVS.I2CReadWord(BestCS.Robotics.Surveyor.SVS.Camera,System.Byte,System.Byte)">
             <summary>
             Read word from I2C device.
             </summary>
             
             <param name="camera">SRV-1 Blackfin camera to access I2C device on.</param>
             <param name="deviceID">I2C device ID (7 bit notation).</param>
             <param name="register">I2C device register to read.</param>
             
             <returns>Returns word read from the specified register of the specified I2C device.</returns>
             
             <para><note>The IC2 device ID should be specified in 7 bit notation. This means that low bit of the ID
             is not used for specifying read/write mode as in 8 bit notation. For example, if I2C device IDs are 0x44 for reading
             and 0x45 for writing in 8 bit notation, then it equals to 0x22 device ID in 7 bit notation.
             </note></para>
            
             <exception cref="T:BestCS.NotConnectedException">Not connected to SVS. Connect to SVS board before using
             this method.</exception>
             <exception cref="T:BestCS.ConnectionLostException">Connection lost or communicaton failure. Try to reconnect.</exception>
             <exception cref="T:System.ApplicationException">Failed parsing response from SRV-1.</exception>
             
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SVS.I2CWriteByte(BestCS.Robotics.Surveyor.SVS.Camera,System.Byte,System.Byte,System.Byte)">
            <summary>
            Write byte to I2C device.
            </summary>
            
            <param name="camera">SRV-1 Blackfin camera to access I2C device on.</param>
            <param name="deviceID">I2C device ID (7 bit notation).</param>
            <param name="register">I2C device register to write to.</param>
            <param name="byteToWrite">Byte to write to the specified register of the specified device.</param>
            
            <para><note>The IC2 device ID should be specified in 7 bit notation. This means that low bit of the ID
            is not used for specifying read/write mode as in 8 bit notation. For example, if I2C device IDs are 0x44 for reading
            and 0x45 for writing in 8 bit notation, then it equals to 0x22 device ID in 7 bit notation.
            </note></para>
            
            <exception cref="T:BestCS.NotConnectedException">Not connected to SVS. Connect to SVS board before using
            this method.</exception>
            <exception cref="T:BestCS.ConnectionLostException">Connection lost or communicaton failure. Try to reconnect.</exception>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SVS.I2CWriteWord(BestCS.Robotics.Surveyor.SVS.Camera,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Write two bytes to I2C device.
            </summary>
            
            <param name="camera">SRV-1 Blackfin camera to access I2C device on.</param>
            <param name="deviceID">I2C device ID (7 bit notation).</param>
            <param name="register">I2C device register to write to.</param>
            <param name="firstByteToWrite">First byte to write to the specified register of the specified device.</param>
            <param name="secondByteToWrite">Second byte to write to the specified register of the specified device.</param>
            
            <para><note>The IC2 device ID should be specified in 7 bit notation. This means that low bit of the ID
            is not used for specifying read/write mode as in 8 bit notation. For example, if I2C device IDs are 0x44 for reading
            and 0x45 for writing in 8 bit notation, then it equals to 0x22 device ID in 7 bit notation.
            </note></para>
            
            <exception cref="T:BestCS.NotConnectedException">Not connected to SVS. Connect to SVS board before using
            this method.</exception>
            <exception cref="T:BestCS.ConnectionLostException">Connection lost or communicaton failure. Try to reconnect.</exception>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SVS.SetQuality(System.Int32)">
             <summary>
             Set video quality for both cameras.
             </summary>
             
             <param name="quality">Video quality to set, [1, 8].</param>
            
             <remarks><para>The method sets video quality for both SVS cameras, which is specified in [1, 8] range - 1 is
             the highest quality level, 8 is the lowest quality level.</para>
             
             <para><note>Setting higher quality level and <see cref="M:BestCS.Robotics.Surveyor.SVS.SetResolution(BestCS.Robotics.Surveyor.SRV1.VideoResolution)">resolution</see>
             may increase delays for other requests sent to SVS. So if
             robot is used not only for video, but also for controlling servos/motors, and higher
             response level is required, then do not set very high quality and resolution.
             </note></para>
             </remarks>
             
             <exception cref="T:BestCS.NotConnectedException">Not connected to SVS. Connect to SVS board before using
             this method.</exception>
             <exception cref="T:System.ArgumentOutOfRangeException">Invalid quality level was specified.</exception>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SVS.SetResolution(BestCS.Robotics.Surveyor.SRV1.VideoResolution)">
            <summary>
            Set video resolution for both cameras.
            </summary>
            
            <param name="resolution">Video resolution to set.</param>
            
            <remarks>
            <para><note>Setting higher <see cref="M:BestCS.Robotics.Surveyor.SVS.SetQuality(System.Int32)">quality level</see> and resolution
            may increase delays for other requests sent to SVS. So if
            robot is used not only for video, but also for controlling servos/motors, and higher
            response level is required, then do not set very high quality and resolution.
            </note></para>
            </remarks>
            
            <exception cref="T:BestCS.NotConnectedException">Not connected to SVS. Connect to SVS board before using
            this method.</exception>
            
        </member>
        <member name="M:BestCS.Robotics.Surveyor.SVS.FlipVideo(System.Boolean)">
            <summary>
            Flip video capture for both cameras or not (for use with upside-down camera).
            </summary>
            
            <param name="isFlipped">Specifies if video should be flipped (<see langword="true"/>),
            or not (<see langword="false"/>).</param>
            
            <exception cref="T:BestCS.NotConnectedException">Not connected to SVS. Connect to SVS board before using
            this method.</exception>
            
        </member>
        <member name="P:BestCS.Robotics.Surveyor.SVS.HostAddress">
             <summary>
             SVS's host address.
             </summary>
             
             <remarks><para>The property keeps SVS's IP address if the class is connected
             to SVS board, otherwise it equals to <see langword="null."/>.</para></remarks>
            
        </member>
        <member name="P:BestCS.Robotics.Surveyor.SVS.IsConnected">
            <summary>
            Connection state.
            </summary>
            
            <remarks><para>The property equals to <see langword="true"/> if the class is connected
            to SVS board, otherwise it equals to <see langword="false"/>.</para>
            
            <para><note>The property is not updated by the class, when connection was lost or
            communication failure was detected (which results into <see cref="T:BestCS.ConnectionLostException"/>
            exception). The property only shows status of <see cref="M:BestCS.Robotics.Surveyor.SVS.Connect(System.String)"/> method.</note></para>
            </remarks>
            
        </member>
        <member name="T:BestCS.Robotics.Surveyor.SVS.Camera">
            <summary>
            Enumeration of SVS's Blackfin cameras.
            </summary>
            
            <remarks><para>Since SVS board consists of two SRV-1 Blackfin cameras, the enumeration
            is used by different methods to specify which one to access.</para></remarks>
            
        </member>
        <member name="F:BestCS.Robotics.Surveyor.SVS.Camera.Left">
            <summary>
            Left camera (default port number is 10000).
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Surveyor.SVS.Camera.Right">
            <summary>
            Right camera (default port number is 10001).
            </summary>
        </member>
        <member name="T:BestCS.Robotics.Surveyor.SVS.ServosBank">
            <summary>
            Enumeration of SVS's servos' banks.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Surveyor.SVS.ServosBank.Bank0">
            <summary>
            First bank of the first (<see cref="F:BestCS.Robotics.Surveyor.SVS.Camera.Left"/>) SRV-1 Blackfin camera,
            timers 2 and 3 (marked as TMR2-1 and TMR3-1 on the SVS board). Note: these
            timers on SVS board are supposed for controlling motors by default
            (see <see cref="M:BestCS.Robotics.Surveyor.SVS.RunMotors(System.Int32,System.Int32,System.Int32)"/> and <see cref="M:BestCS.Robotics.Surveyor.SVS.ControlMotors(BestCS.Robotics.Surveyor.SRV1.MotorCommand)"/>), so use 0th
            servos bank only when you've done proper configuration changes on SVS side.
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Surveyor.SVS.ServosBank.Bank1">
            <summary>
            Second bank of the first (<see cref="F:BestCS.Robotics.Surveyor.SVS.Camera.Left"/>) SRV-1 Blackfin camera,
            timers 6 and 7 (marked as TMR6-1 and TMR7-1 on the SVS board).
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Surveyor.SVS.ServosBank.Bank2">
            <summary>
            First bank of the second (<see cref="F:BestCS.Robotics.Surveyor.SVS.Camera.Right"/>) SRV-1 Blackfin camera,
            timers 2 and 3 (marked as TMR2-2 and TMR3-2 on the SVS board).
            </summary>
        </member>
        <member name="F:BestCS.Robotics.Surveyor.SVS.ServosBank.Bank3">
            <summary>
            Second bank of the second (<see cref="F:BestCS.Robotics.Surveyor.SVS.Camera.Right"/>) SRV-1 Blackfin camera,
            timers 6 and 7 (marked as TMR6-2 and TMR7-2 on the SVS board).
            </summary>
        </member>
        <member name="T:BestCS.Vision.Detection.Cascades.FaceHaarCascade">
            <summary>
              Default Face Haar Cascade for using with Haar Classifiers.
            </summary>
            
            <remarks>
              The definition was originally based on a hard coded partial transcription of
              OpenCV's <i>haarcascade_frontalface_alt.xml</i> by Mario Klingemann. This
              class, however, has been re-created using <see cref="T:BestCS.Vision.Detection.HaarCascadeWriter"/>.
            </remarks>
            
        </member>
        <member name="T:BestCS.Vision.Detection.HaarCascade">
            <summary>
              Cascade of Haar-like features' weak classification stages.
            </summary>
            
            <remarks>
            <para>
              The Viola-Jones object detection framework is the first object detection framework
              to provide competitive object detection rates in real-time proposed in 2001 by Paul
              Viola and Michael Jones. Although it can be trained to detect a variety of object
              classes, it was motivated primarily by the problem of face detection.</para>
              
            <para>
              The implementation of this code has used Viola and Jones' original publication, the
              OpenCV Library and the Marilena Project as reference. OpenCV is released under a BSD
              license, it is free for both academic and commercial use. Please be aware that some
              particular versions of the Haar object detection framework are patented by Viola and
              Jones and may be subject to restrictions for use in commercial applications. </para>
              
             <para>
                References:
                <list type="bullet">
                  <item><description>
                    <a href="http://www.cs.utexas.edu/~grauman/courses/spring2007/395T/papers/viola_cvpr2001.pdf">
                    Viola, P. and Jones, M. (2001). Rapid Object Detection using a Boosted Cascade
                    of Simple Features.</a></description></item>
                  <item><description>
                    <a href="http://en.wikipedia.org/wiki/Viola-Jones_object_detection_framework">
                    Wikipedia, The Free Encyclopedia. Viola-Jones object detection framework </a>
                  </description></item>
                </list></para>
            </remarks>
            
            <example>
            <para>
              To load an OpenCV-compatible XML definition for a Haar cascade, you can use HaarCascade's
              <see cref="M:BestCS.Vision.Detection.HaarCascade.FromXml(System.IO.Stream)">FromXml</see> static method. An example would be:</para>
              <code>
              String path = @"C:\Users\haarcascade-frontalface_alt2.xml";
              HaarCascade cascade1 = HaarCascade.FromXml(path);
              </code>
              
            <para>
              After the cascade has been loaded, it is possible to create a new <see cref="T:BestCS.Vision.Detection.HaarObjectDetector"/>
              using the cascade. Please see <see cref="T:BestCS.Vision.Detection.HaarObjectDetector"/> for more details. It is also
              possible to generate embeddable C# definitions from a cascade, avoiding the need to load
              XML files on program startup. Please see <see cref="M:BestCS.Vision.Detection.HaarCascade.ToCode(System.String,System.String)"/> method or 
              <see cref="T:BestCS.Vision.Detection.HaarCascadeWriter"/> class for details.</para> 
            </example>
            
        </member>
        <member name="M:BestCS.Vision.Detection.HaarCascade.#ctor(System.Int32,System.Int32,BestCS.Vision.Detection.HaarCascadeStage[])">
            <summary>
              Constructs a new Haar Cascade.
            </summary>
            
            <param name="baseWidth">Base feature width.</param>
            <param name="baseHeight">Base feature height.</param>
            <param name="stages">Haar-like features classification stages.</param>
            
        </member>
        <member name="M:BestCS.Vision.Detection.HaarCascade.#ctor(System.Int32,System.Int32)">
            <summary>
              Constructs a new Haar Cascade.
            </summary>
            
            <param name="baseWidth">Base feature width.</param>
            <param name="baseHeight">Base feature height.</param>
            
        </member>
        <member name="M:BestCS.Vision.Detection.HaarCascade.checkTiltedFeatures(BestCS.Vision.Detection.HaarCascadeStage[])">
            <summary>
              Checks if the classifier contains tilted (rotated) features
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Detection.HaarCascade.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            
            <returns>
              A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="M:BestCS.Vision.Detection.HaarCascade.FromXml(System.IO.Stream)">
            <summary>
              Loads a HaarCascade from a OpenCV-compatible XML file.
            </summary>
            
            <param name="stream">
               A <see cref="T:System.IO.Stream"/> containing the file stream
               for the xml definition of the classifier to be loaded.</param>
               
            <returns>The HaarCascadeClassifier loaded from the file.</returns>
            
        </member>
        <member name="M:BestCS.Vision.Detection.HaarCascade.FromXml(System.String)">
            <summary>
              Loads a HaarCascade from a OpenCV-compatible XML file.
            </summary>
            
            <param name="path">
               The file path for the xml definition of the classifier to be loaded.</param>
               
            <returns>The HaarCascadeClassifier loaded from the file.</returns>
            
        </member>
        <member name="M:BestCS.Vision.Detection.HaarCascade.FromXml(System.IO.TextReader)">
            <summary>
              Loads a HaarCascade from a OpenCV-compatible XML file.
            </summary>
            
            <param name="stringReader">
               A <see cref="T:System.IO.StringReader"/> containing the file stream
               for the xml definition of the classifier to be loaded.</param>
               
            <returns>The HaarCascadeClassifier loaded from the file.</returns>
            
        </member>
        <member name="M:BestCS.Vision.Detection.HaarCascade.ToCode(System.String,System.String)">
            <summary>
              Saves a HaarCascade to C# code.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Detection.HaarCascade.ToCode(System.IO.TextWriter,System.String)">
            <summary>
              Saves a HaarCascade to C# code.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Detection.HaarCascade.Width">
            <summary>
              Gets the stages' base width.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Detection.HaarCascade.Height">
            <summary>
              Gets the stages' base height.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Detection.HaarCascade.Stages">
            <summary>
              Gets the classification stages.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Detection.HaarCascade.HasTiltedFeatures">
            <summary>
              Gets a value indicating whether this cascade has tilted features.
            </summary>
            
            <value>
            	<c>true</c> if this cascade has tilted features; otherwise, <c>false</c>.
            </value>
            
        </member>
        <member name="M:BestCS.Vision.Detection.Cascades.FaceHaarCascade.#ctor">
            <summary>
              Hard-coded partial transcription of <i>haarcascade_frontalface_alt.xml</i>
              based on code by Mario Klingemann.
            </summary>
            
        </member>
        <member name="T:BestCS.Vision.Detection.Cascades.NoseHaarCascade">
            <summary>
              Automatic transcription of Haar cascade definitions 
              for facial features by Modesto Castrillon-Santana.
            </summary>
            
            <remarks>
            <para>
              This code has been automatically generated by the BestCS.NET Framework
              based on original research by Modesto Castrillon-Santana. The original
              code has been shared under a BSD license in the OpenCV library and has
              been incorporated in the BestCS.NET Framework under permission of the
              original author.</para>
              
            <code>
              // Copyright (c) 2008, Modesto Castrillon-Santana (IUSIANI, University of
              // Las Palmas de Gran Canaria, Spain).
              //  All rights reserved.
              //  
              // Redistribution and use in source and binary forms, with or without
              // modification, are permitted provided that the following conditions are
              // met:
              //       
              //    * Redistributions of source code must retain the above copyright
              //      notice, this list of conditions and the following disclaimer.
              //    * Redistributions in binary form must reproduce the above
              //      copyright notice, this list of conditions and the following
              //      disclaimer in the documentation and/or other materials provided
              //      with the distribution.  
              //    * The name of Contributor may not used to endorse or promote products 
              //      derived from this software without specific prior written permission.
              //
              //  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
              //  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
              //  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
              //  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
              //  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
              //  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
              //  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
              //  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
              //  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
              //  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
              //  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
            </code>
            
            </remarks>
            
        </member>
        <member name="M:BestCS.Vision.Detection.Cascades.NoseHaarCascade.#ctor">
            <summary>
              Creates a new cascade for nose detection.
            </summary>
            
        </member>
        <member name="T:BestCS.Vision.Detection.HaarCascadeStage">
            <summary>
              Haar Cascade Classifier Stage.
            </summary>
            
            <remarks>
              A Haar Cascade Classifier is composed of several stages. Each stage
              contains a set of classifier trees used in the decision process.
            </remarks>
            
        </member>
        <member name="M:BestCS.Vision.Detection.HaarCascadeStage.#ctor">
            <summary>
              Constructs a new Haar Cascade Stage.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Detection.HaarCascadeStage.#ctor(System.Double)">
            <summary>
              Constructs a new Haar Cascade Stage.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Detection.HaarCascadeStage.#ctor(System.Double,System.Int32,System.Int32)">
            <summary>
              Constructs a new Haar Cascade Stage.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Detection.HaarCascadeStage.Classify(BestCS.Imaging.IntegralImage2,System.Int32,System.Int32,System.Double)">
            <summary>
              Classifies an image as having the searched object or not.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Detection.HaarCascadeStage.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            
            <returns>
              A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:BestCS.Vision.Detection.HaarCascadeStage.Trees">
            <summary>
              Gets or sets the feature trees and its respective
              feature tree nodes which compose this stage.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Detection.HaarCascadeStage.Threshold">
            <summary>
              Gets or sets the threshold associated with this stage,
              i.e. the minimum value the classifiers should output
              to decide if the image contains the object or not.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Detection.HaarCascadeStage.ParentIndex">
            <summary>
              Gets the index of the parent stage from this stage.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Detection.HaarCascadeStage.NextIndex">
            <summary>
              Gets the index of the next stage from this stage.
            </summary>
            
        </member>
        <member name="T:BestCS.Vision.Detection.HaarCascadeSerializationObject">
            <summary>
              Haar Cascade Serialization Root. This class is used
              only for XML serialization/deserialization.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Detection.HaarCascadeSerializationObject.Stages">
            <summary>
              The stages retrieved after deserialization.
            </summary>
        </member>
        <member name="T:BestCS.Vision.Detection.HaarCascadeWriter">
            <summary>
              Automatic transcriber for Haar cascades.
            </summary>
            
            <remarks>
              This class can be used to generate code-only definitions for Haar cascades,
              avoiding the need for loading and parsing XML files during application startup.
              This class generates C# code for a class inheriting from <see cref="T:BestCS.Vision.Detection.HaarCascade"/>
              which may be used to create a <see cref="T:BestCS.Vision.Detection.HaarObjectDetector"/>.
            </remarks>
            
        </member>
        <member name="M:BestCS.Vision.Detection.HaarCascadeWriter.#ctor(System.IO.TextWriter)">
            <summary>
              Constructs a new <see cref="T:BestCS.Vision.Detection.HaarCascadeWriter"/> class.
            </summary>
            <param name="stream">The stream to write to.</param>
            
        </member>
        <member name="M:BestCS.Vision.Detection.HaarCascadeWriter.Write(BestCS.Vision.Detection.HaarCascade,System.String)">
            <summary>
              Writes the specified cascade.
            </summary>
            <param name="cascade">The cascade to write.</param>
            <param name="className">The name for the generated class.</param>
            
        </member>
        <member name="T:BestCS.Vision.Detection.HaarClassifier">
             <summary>
               Strong classifier based on a weaker cascade of
               classifiers using Haar-like rectangular features.
             </summary>
            
             <remarks>
             <para>
               The Viola-Jones object detection framework is the first object detection framework
               to provide competitive object detection rates in real-time proposed in 2001 by Paul
               Viola and Michael Jones. Although it can be trained to detect a variety of object
               classes, it was motivated primarily by the problem of face detection.</para>
               
             <para>
               The implementation of this code has used Viola and Jones' original publication, the
               OpenCV Library and the Marilena Project as reference. OpenCV is released under a BSD
               license, it is free for both academic and commercial use. Please be aware that some
               particular versions of the Haar object detection framework are patented by Viola and
               Jones and may be subject to restrictions for use in commercial applications. The code
               has been implemented with full support for tilted Haar features.</para>
               
              <para>
                 References:
                 <list type="bullet">
                   <item><description>
                     <a href="http://www.cs.utexas.edu/~grauman/courses/spring2007/395T/papers/viola_cvpr2001.pdf">
                     Viola, P. and Jones, M. (2001). Rapid Object Detection using a Boosted Cascade
                     of Simple Features.</a></description></item>
                   <item><description>
                     <a href="http://en.wikipedia.org/wiki/Viola-Jones_object_detection_framework">
                     http://en.wikipedia.org/wiki/Viola-Jones_object_detection_framework</a>
                   </description></item>
                 </list>
               </para>
             </remarks>
             
        </member>
        <member name="M:BestCS.Vision.Detection.HaarClassifier.#ctor(BestCS.Vision.Detection.HaarCascade)">
            <summary>
              Constructs a new classifier.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Detection.HaarClassifier.#ctor(System.Int32,System.Int32,BestCS.Vision.Detection.HaarCascadeStage[])">
            <summary>
              Constructs a new classifier.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Detection.HaarClassifier.Compute(BestCS.Imaging.IntegralImage2,System.Drawing.Rectangle)">
            <summary>
              Detects the presence of an object in a given window.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Detection.HaarClassifier.Cascade">
            <summary>
              Gets the cascade of weak-classifiers
              used by this strong classifier.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Detection.HaarClassifier.Scale">
            <summary>
              Gets or sets the scale of the search window
              being currently used by the classifier.
            </summary>
            
        </member>
        <member name="T:BestCS.Vision.Detection.HaarFeature">
            <summary>
              Rectangular Haar-like feature container.
            </summary>
            
            <remarks>
              References:
              - http://en.wikipedia.org/wiki/Haar-like_features#Rectangular_Haar-like_features
            </remarks>
            
        </member>
        <member name="M:BestCS.Vision.Detection.HaarFeature.#ctor">
            <summary>
              Constructs a new Haar-like feature.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Detection.HaarFeature.#ctor(BestCS.Vision.Detection.HaarRectangle[])">
            <summary>
              Constructs a new Haar-like feature.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Detection.HaarFeature.#ctor(System.Int32[][])">
            <summary>
              Constructs a new Haar-like feature.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Detection.HaarFeature.#ctor(System.Boolean,System.Int32[][])">
            <summary>
              Constructs a new Haar-like feature.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Detection.HaarFeature.GetSum(BestCS.Imaging.IntegralImage2,System.Int32,System.Int32)">
            <summary>
              Gets the sum of the areas of the rectangular features in an integral image.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Detection.HaarFeature.SetScaleAndWeight(System.Single,System.Single)">
            <summary>
              Sets the scale and weight of a Haar-like rectangular feature container.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Detection.HaarFeature.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            
            <returns>
              A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:BestCS.Vision.Detection.HaarFeature.Tilted">
            <summary>
              Gets or sets whether this feature is tilted.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Detection.HaarFeature.Rectangles">
            <summary>
              Gets or sets the Haar rectangles for this feature.
            </summary>
            
        </member>
        <member name="T:BestCS.Vision.Detection.HaarFeatureNode">
            <summary>
              Haar Cascade Feature Tree Node.
            </summary>
            
            <remarks>
              The Feature Node is a node belonging to a feature tree,
              containing information about child nodes and an associated 
              <see cref="T:BestCS.Vision.Detection.HaarFeature"/>.
            </remarks>
            
        </member>
        <member name="M:BestCS.Vision.Detection.HaarFeatureNode.#ctor">
            <summary>
              Constructs a new feature tree node.
            </summary>
        </member>
        <member name="M:BestCS.Vision.Detection.HaarFeatureNode.#ctor(System.Double,System.Double,System.Double,System.Int32[][])">
            <summary>
              Constructs a new feature tree node.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Detection.HaarFeatureNode.#ctor(System.Double,System.Double,System.Double,System.Boolean,System.Int32[][])">
            <summary>
              Constructs a new feature tree node.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Detection.HaarFeatureNode.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            <returns>
              A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:BestCS.Vision.Detection.HaarFeatureNode.Threshold">
            <summary>
              Gets the threshold for this feature.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Detection.HaarFeatureNode.LeftValue">
            <summary>
              Gets the left value for this feature.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Detection.HaarFeatureNode.RightValue">
            <summary>
              Gets the right value for this feature.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Detection.HaarFeatureNode.LeftNodeIndex">
            <summary>
              Gets the left node index for this feature.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Detection.HaarFeatureNode.RightNodeIndex">
            <summary>
              Gets the right node index for this feature.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Detection.HaarFeatureNode.Feature">
            <summary>
              Gets the feature associated with this node.
            </summary>
            
        </member>
        <member name="T:BestCS.Vision.Detection.HaarRectangle">
            <summary>
              Scalable rectangular area.
            </summary>
            
            <remarks>
              A rectangle which can be at any position and scale within the original image.
            </remarks>
            
        </member>
        <member name="M:BestCS.Vision.Detection.HaarRectangle.#ctor(System.Int32[])">
            <summary>
              Constructs a new Haar-like feature rectangle.
            </summary>
            <param name="values">Values for this rectangle.</param>
            
        </member>
        <member name="M:BestCS.Vision.Detection.HaarRectangle.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Single)">
            <summary>
              Constructs a new Haar-like feature rectangle.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Detection.HaarRectangle.ScaleRectangle(System.Single)">
            <summary>
              Scales the values of this rectangle.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Detection.HaarRectangle.ScaleWeight(System.Single)">
            <summary>
              Scales the weight of this rectangle.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Detection.HaarRectangle.Parse(System.String)">
            <summary>
              Converts from a string representation.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Detection.HaarRectangle.Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            
            <returns>
              A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="P:BestCS.Vision.Detection.HaarRectangle.X">
            <summary>
              Gets or sets the x-coordinate of this Haar feature rectangle.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Detection.HaarRectangle.Y">
            <summary>
              Gets or sets the y-coordinate of this Haar feature rectangle.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Detection.HaarRectangle.Width">
            <summary>
              Gets or sets the width of this Haar feature rectangle.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Detection.HaarRectangle.Height">
            <summary>
              Gets or sets the height of this Haar feature rectangle.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Detection.HaarRectangle.Weight">
            <summary>
              Gets or sets the weight of this Haar feature rectangle.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Detection.HaarRectangle.ScaledX">
            <summary>
              Gets or sets the scaled x-coordinate of this Haar feature rectangle.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Detection.HaarRectangle.ScaledY">
            <summary>
              Gets or sets the scaled y-coordinate of this Haar feature rectangle.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Detection.HaarRectangle.ScaledWidth">
            <summary>
              Gets or sets the scaled width of this Haar feature rectangle.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Detection.HaarRectangle.ScaledHeight">
            <summary>
              Gets or sets the scaled height of this Haar feature rectangle.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Detection.HaarRectangle.ScaledWeight">
            <summary>
              Gets or sets the scaled weight of this Haar feature rectangle.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Detection.HaarRectangle.Area">
            <summary>
              Gets the area of this rectangle.
            </summary>
            
        </member>
        <member name="T:BestCS.Vision.Detection.ObjectDetectorSearchMode">
            <summary>
              Object detector options for the search procedure.
            </summary>
            
        </member>
        <member name="F:BestCS.Vision.Detection.ObjectDetectorSearchMode.Default">
            <summary>
              Entire image will be scanned.
            </summary>
            
        </member>
        <member name="F:BestCS.Vision.Detection.ObjectDetectorSearchMode.Single">
            <summary>
              Only a single object will be retrieved.
            </summary>
            
        </member>
        <member name="F:BestCS.Vision.Detection.ObjectDetectorSearchMode.NoOverlap">
            <summary>
              If a object has already been detected inside an area,
              it will not be scanned twice for inner or overlapping
              objects, saving computation time.
            </summary>
            
        </member>
        <member name="F:BestCS.Vision.Detection.ObjectDetectorSearchMode.Average">
            <summary>
              If several objects are located within one another, 
              they will be averaged. Additionally, objects which
              have not been detected sufficient times may be dropped
              by setting <see cref="P:BestCS.Vision.Detection.HaarObjectDetector.Suppression"/>.
            </summary>
            
        </member>
        <member name="T:BestCS.Vision.Detection.ObjectDetectorScalingMode">
            <summary>
              Object detector options for window scaling.
            </summary>
            
        </member>
        <member name="F:BestCS.Vision.Detection.ObjectDetectorScalingMode.GreaterToSmaller">
            <summary>
              Will start with a big search window and
              gradually scale into smaller ones.
            </summary>
            
        </member>
        <member name="F:BestCS.Vision.Detection.ObjectDetectorScalingMode.SmallerToGreater">
            <summary>
              Will start with small search windows and
              gradually scale into greater ones.
            </summary>
            
        </member>
        <member name="T:BestCS.Vision.Detection.HaarObjectDetector">
            <summary>
              Viola-Jones Object Detector based on Haar-like features.
            </summary>
            <remarks>
            
            <para>
              The Viola-Jones object detection framework is the first object detection framework
              to provide competitive object detection rates in real-time proposed in 2001 by Paul
              Viola and Michael Jones. Although it can be trained to detect a variety of object
              classes, it was motivated primarily by the problem of face detection.</para>
              
            <para>
              The implementation of this code has used Viola and Jones' original publication, the
              OpenCV Library and the Marilena Project as reference. OpenCV is released under a BSD
              license, it is free for both academic and commercial use. Please be aware that some
              particular versions of the Haar object detection framework are patented by Viola and
              Jones and may be subject to restrictions for use in commercial applications. The code
              has been implemented with full support for tilted Haar features from the ground up.</para>
              
             <para>
                References:
                <list type="bullet">
                  <item><description>
                    <a href="http://www.cs.utexas.edu/~grauman/courses/spring2007/395T/papers/viola_cvpr2001.pdf">
                    Viola, P. and Jones, M. (2001). Rapid Object Detection using a Boosted Cascade
                    of Simple Features.</a></description></item>
                  <item><description>
                    <a href="http://en.wikipedia.org/wiki/Viola-Jones_object_detection_framework">
                    http://en.wikipedia.org/wiki/Viola-Jones_object_detection_framework</a>
                  </description></item>
                </list>
              </para>
            </remarks>
            
        </member>
        <member name="T:BestCS.Vision.Detection.IObjectDetector">
            <summary>
              Object detector interface.
            </summary>
        </member>
        <member name="M:BestCS.Vision.Detection.IObjectDetector.ProcessFrame(BestCS.Imaging.UnmanagedImage)">
            <summary>
              Process a new image scene looking for objects.
            </summary>
        </member>
        <member name="P:BestCS.Vision.Detection.IObjectDetector.DetectedObjects">
            <summary>
              Gets the location of the detected objects.
            </summary>
        </member>
        <member name="M:BestCS.Vision.Detection.HaarObjectDetector.#ctor(BestCS.Vision.Detection.HaarCascade)">
            <summary>
              Constructs a new Haar object detector.
            </summary>
            
            <param name="cascade">
              The <see cref="T:BestCS.Vision.Detection.HaarCascade"/> to use in the detector's classifier.
              For the default face cascade, please take a look on
              <see cref="T:BestCS.Vision.Detection.Cascades.FaceHaarCascade"/>.
            </param>
            
        </member>
        <member name="M:BestCS.Vision.Detection.HaarObjectDetector.#ctor(BestCS.Vision.Detection.HaarCascade,System.Int32)">
            <summary>
              Constructs a new Haar object detector.
            </summary>
            
            <param name="cascade">
              The <see cref="T:BestCS.Vision.Detection.HaarCascade"/> to use in the detector's classifier.
              For the default face cascade, please take a look on
              <see cref="T:BestCS.Vision.Detection.Cascades.FaceHaarCascade"/>.</param>
            <param name="minSize">
              Minimum window size to consider when searching for 
              objects. Default value is <c>15</c>.</param>
            
        </member>
        <member name="M:BestCS.Vision.Detection.HaarObjectDetector.#ctor(BestCS.Vision.Detection.HaarCascade,System.Int32,BestCS.Vision.Detection.ObjectDetectorSearchMode)">
            <summary>
              Constructs a new Haar object detector.
            </summary>
            
            <param name="cascade">
              The <see cref="T:BestCS.Vision.Detection.HaarCascade"/> to use in the detector's classifier.
              For the default face cascade, please take a look on
              <see cref="T:BestCS.Vision.Detection.Cascades.FaceHaarCascade"/>.
            </param>
            <param name="minSize">
              Minimum window size to consider when searching for
              objects. Default value is <c>15</c>.</param>
            <param name="searchMode">The <see cref="T:BestCS.Vision.Detection.ObjectDetectorSearchMode"/> to use
              during search. Please see documentation of <see cref="T:BestCS.Vision.Detection.ObjectDetectorSearchMode"/>
              for details. Default value is <see cref="F:BestCS.Vision.Detection.ObjectDetectorSearchMode.NoOverlap"/></param>
            
        </member>
        <member name="M:BestCS.Vision.Detection.HaarObjectDetector.#ctor(BestCS.Vision.Detection.HaarCascade,System.Int32,BestCS.Vision.Detection.ObjectDetectorSearchMode,System.Single)">
            <summary>
              Constructs a new Haar object detector.
            </summary>
            
            <param name="cascade">
              The <see cref="T:BestCS.Vision.Detection.HaarCascade"/> to use in the detector's classifier.
              For the default face cascade, please take a look on
              <see cref="T:BestCS.Vision.Detection.Cascades.FaceHaarCascade"/>.</param>
            <param name="minSize">
              Minimum window size to consider when searching for
              objects. Default value is <c>15</c>.</param>
            <param name="searchMode">
              The <see cref="T:BestCS.Vision.Detection.ObjectDetectorSearchMode"/> to use
              during search. Please see documentation of <see cref="T:BestCS.Vision.Detection.ObjectDetectorSearchMode"/>
              for details. Default value is <see cref="F:BestCS.Vision.Detection.ObjectDetectorSearchMode.NoOverlap"/></param>
            <param name="scaleFactor">The re-scaling factor to use when re-scaling the window during search.</param>
            
        </member>
        <member name="M:BestCS.Vision.Detection.HaarObjectDetector.#ctor(BestCS.Vision.Detection.HaarCascade,System.Int32,BestCS.Vision.Detection.ObjectDetectorSearchMode,System.Single,BestCS.Vision.Detection.ObjectDetectorScalingMode)">
            <summary>
              Constructs a new Haar object detector.
            </summary>
            
            <param name="cascade">
              The <see cref="T:BestCS.Vision.Detection.HaarCascade"/> to use in the detector's classifier.
              For the default face cascade, please take a look on
              <see cref="T:BestCS.Vision.Detection.Cascades.FaceHaarCascade"/>. </param>
            <param name="minSize">
              Minimum window size to consider when searching for
              objects. Default value is <c>15</c>.</param>
            <param name="searchMode">The <see cref="T:BestCS.Vision.Detection.ObjectDetectorSearchMode"/> to use
              during search. Please see documentation of <see cref="T:BestCS.Vision.Detection.ObjectDetectorSearchMode"/>
              for details. Default is <see cref="F:BestCS.Vision.Detection.ObjectDetectorSearchMode.NoOverlap"/>.</param>
            <param name="scaleFactor">The scaling factor to rescale the window
              during search. Default value is <c>1.2f</c>.</param>
            <param name="scalingMode">The <see cref="T:BestCS.Vision.Detection.ObjectDetectorScalingMode"/> to use
              when re-scaling the search window during search. Default is
              <see cref="F:BestCS.Vision.Detection.ObjectDetectorScalingMode.SmallerToGreater"/>.</param>
            
        </member>
        <member name="M:BestCS.Vision.Detection.HaarObjectDetector.ProcessFrame(System.Drawing.Bitmap)">
            <summary>
              Performs object detection on the given frame.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Detection.HaarObjectDetector.ProcessFrame(BestCS.Imaging.UnmanagedImage)">
            <summary>
              Performs object detection on the given frame.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Detection.HaarObjectDetector.UseParallelProcessing">
            <summary>
              Gets or sets a value indicating whether this <see cref="T:BestCS.Vision.Detection.HaarObjectDetector"/>
              should scan the image using multiple threads. This setting can only be changed
              to true on .NET version which support the Parallel Tasks framework (4.0+).
            </summary>
            
            <value><c>true</c> to use multiple threads; otherwise, <c>false</c>.</value>
            
        </member>
        <member name="P:BestCS.Vision.Detection.HaarObjectDetector.MinSize">
            <summary>
              Minimum window size to consider when searching objects.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Detection.HaarObjectDetector.MaxSize">
            <summary>
              Maximum window size to consider when searching objects.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Detection.HaarObjectDetector.Channel">
            <summary>
              Gets or sets the color channel to use when processing color images. 
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Detection.HaarObjectDetector.ScalingFactor">
            <summary>
              Gets or sets the scaling factor to rescale the window during search.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Detection.HaarObjectDetector.SearchMode">
            <summary>
              Gets or sets the desired searching method.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Detection.HaarObjectDetector.ScalingMode">
            <summary>
              Gets or sets the desired scaling method.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Detection.HaarObjectDetector.Suppression">
            <summary>
              Gets or sets the minimum threshold used to suppress rectangles which
              have not been detected sufficient number of times. This property only
              has effect when <see cref="P:BestCS.Vision.Detection.HaarObjectDetector.SearchMode"/> is set to <see cref="F:BestCS.Vision.Detection.ObjectDetectorSearchMode.Average"/>.
            </summary>
            
            <remarks>
            <para>
              The value of this property represents the minimum amount of detections
              made inside a region to report this region as an actual detection. For
              example, setting this property to two will discard all regions which 
              had not achieved at least two detected rectangles within it.</para>
              
            <para>
              Setting this property to a value higher than zero may decrease the
              number of false positives.</para>
            </remarks>
            
        </member>
        <member name="P:BestCS.Vision.Detection.HaarObjectDetector.DetectedObjects">
            <summary>
              Gets the detected objects bounding boxes.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Detection.HaarObjectDetector.Classifier">
            <summary>
              Gets the internal Cascade Classifier used by this detector.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Detection.HaarObjectDetector.Steady">
            <summary>
              Gets how many frames the object has
              been detected in a steady position.
            </summary>
            <value>
              The number of frames the detected object
              has been in a steady position.</value>
              
        </member>
        <member name="T:BestCS.Vision.GroupMatching">
            <summary>
              Group matching algorithm for detection region averaging.
            </summary>
            
            <remarks>
              This class can be seen as a post-processing filter. Its goal is to
              group near or contained regions together in order to produce more
              robust and smooth estimates of the detected regions.
            </remarks>
            
        </member>
        <member name="T:BestCS.Vision.GroupMatching`1">
            <summary>
              Group matching algorithm for detection region averaging.
            </summary>
            
            <remarks>
              This class can be seen as a post-processing filter. Its goal is to
              group near or contained regions together in order to produce more
              robust and smooth estimates of the detected regions.
            </remarks>
            
        </member>
        <member name="M:BestCS.Vision.GroupMatching`1.#ctor(System.Int32)">
            <summary>
              Creates a new <see cref="T:BestCS.Vision.GroupMatching"/> object.
            </summary>
            
            <param name="minimumNeighbors">
              The minimum number of neighbors needed to keep a detection. If a rectangle
              has less than this minimum number, it will be discarded as a false positive.</param>
            
        </member>
        <member name="M:BestCS.Vision.GroupMatching`1.Group(`0[])">
            <summary>
              Groups possibly near rectangles into a smaller
              set of distinct and averaged rectangles.
            </summary>
            
            <param name="shapes">The rectangles to group.</param>
            
        </member>
        <member name="M:BestCS.Vision.GroupMatching`1.classify(`0[])">
            <summary>
              Detects rectangles which are near and 
              assigns similar class labels accordingly.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.GroupMatching`1.merge(System.Int32,System.Int32)">
            <summary>
              Merges two labels.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.GroupMatching`1.Near(`0,`0)">
            <summary>
              When overridden in a child class, should compute
              whether two given shapes are near. Definition of
              near is up to the implementation.
            </summary>
            
            <returns>True if the two shapes are near; false otherwise.</returns>
            
        </member>
        <member name="M:BestCS.Vision.GroupMatching`1.Average(System.Int32[],`0[],System.Int32[]@)">
            <summary>
              When overridden in a child class, should compute
              an average of the shapes given as parameters.
            </summary>
            
            <param name="labels">The label of each shape.</param>
            <param name="shapes">The shapes themselves.</param>
            <param name="neighborCounts">Should return how many neighbors each shape had.</param>
            
            <returns>The averaged shapes found in the given parameters.</returns>
            
        </member>
        <member name="P:BestCS.Vision.GroupMatching`1.MinimumNeighbors">
            <summary>
              Gets or sets the minimum number of neighbors necessary to keep a detection.
              If a rectangle has less neighbors than this number, it will be discarded as
              a false positive.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.GroupMatching`1.Classes">
            <summary>
              Gets how many classes were found in the
              last call to <see cref="M:BestCS.Vision.GroupMatching`1.Group(`0[])"/>.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.GroupMatching.#ctor(System.Int32,System.Double)">
            <summary>
              Creates a new <see cref="T:BestCS.Vision.GroupMatching"/> object.
            </summary>
            
            <param name="minimumNeighbors">
              The minimum number of neighbors needed to keep a detection. If a rectangle
              has less than this minimum number, it will be discarded as a false positive.</param>
            <param name="threshold">
              The minimum distance threshold to consider two rectangles as neighbors.
              Default is 0.2.</param>
            
        </member>
        <member name="M:BestCS.Vision.GroupMatching.Near(System.Drawing.Rectangle,System.Drawing.Rectangle)">
            <summary>
              Checks if two rectangles are near.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.GroupMatching.Average(System.Int32[],System.Drawing.Rectangle[],System.Int32[]@)">
            <summary>
              Averages rectangles which belongs to the
              same class (have the same class label)
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.GroupMatching.Threshold">
            <summary>
              Gets the minimum distance threshold to consider
              two rectangles as neighbors. Default is 0.2.
            </summary>
            
        </member>
        <member name="T:BestCS.Vision.Motion.BlobCountingObjectsProcessing">
            <summary>
            Motion processing algorithm, which counts separate moving objects and highlights them.
            </summary>
            
            <remarks><para>The aim of this motion processing algorithm is to count separate objects
            in the motion frame, which is provided by <see cref="T:BestCS.Vision.Motion.IMotionDetector">motion detection algorithm</see>.
            In the case if <see cref="P:BestCS.Vision.Motion.BlobCountingObjectsProcessing.HighlightMotionRegions"/> property is set to <see langword="true"/>,
            found objects are also highlighted on the original video frame. The algorithm
            counts and highlights only those objects, which size satisfies <see cref="P:BestCS.Vision.Motion.BlobCountingObjectsProcessing.MinObjectsWidth"/>
            and <see cref="P:BestCS.Vision.Motion.BlobCountingObjectsProcessing.MinObjectsHeight"/> properties.</para>
            
            <para><note>The motion processing algorithm is supposed to be used only with motion detection
            algorithms, which are based on finding difference with background frame
            (see <see cref="T:BestCS.Vision.Motion.SimpleBackgroundModelingDetector"/> and <see cref="T:BestCS.Vision.Motion.CustomFrameDifferenceDetector"/>
            as simple implementations) and allow extract moving objects clearly.</note></para>
            
            <para>Sample usage:</para>
            <code>
            // create instance of motion detection algorithm
            IMotionDetector motionDetector = new ... ;
            // create instance of motion processing algorithm
            BlobCountingObjectsProcessing motionProcessing = new BlobCountingObjectsProcessing( );
            // create motion detector
            MotionDetector detector = new MotionDetector( motionDetector, motionProcessing );
            
            // continuously feed video frames to motion detector
            while ( ... )
            {
                // process new video frame and check motion level
                if ( detector.ProcessFrame( videoFrame ) &gt; 0.02 )
                {
                    // check number of detected objects
                    if ( motionProcessing.ObjectsCount &gt; 1 )
                    {
                        // ...
                    }
                }
            }
            </code>
            </remarks>
            
            <seealso cref="T:BestCS.Vision.Motion.MotionDetector"/>
            <seealso cref="T:BestCS.Vision.Motion.IMotionDetector"/>
            
        </member>
        <member name="T:BestCS.Vision.Motion.IMotionProcessing">
             <summary>
             Interface of motion processing algorithm.
             </summary>
            
             <remarks><para>The interface specifies methods, which should be implemented
             by all motion processng algorithms - algorithm which perform further post processing
             of detected motion, which is done by motion detection algorithms (see <see cref="T:BestCS.Vision.Motion.IMotionDetector"/>).
             </para></remarks>
             
             <seealso cref="T:BestCS.Vision.Motion.MotionDetector"/>
             <seealso cref="T:BestCS.Vision.Motion.IMotionDetector"/>
            
        </member>
        <member name="M:BestCS.Vision.Motion.IMotionProcessing.ProcessFrame(BestCS.Imaging.UnmanagedImage,BestCS.Imaging.UnmanagedImage)">
            <summary>
            Process video and motion frames doing further post processing after
            performed motion detection.
            </summary>
            
            <param name="videoFrame">Original video frame.</param>
            <param name="motionFrame">Motion frame provided by motion detection
            algorithm (see <see cref="T:BestCS.Vision.Motion.IMotionDetector"/>).</param>
            
            <remarks><para>The method does father post processing of detected motion.
            Type of motion post processing is specified by specific implementation
            of the <see cref="T:BestCS.Vision.Motion.IMotionProcessing"/> interface - it may motion
            area highlighting, motion objects counting, etc.</para></remarks>
            
        </member>
        <member name="M:BestCS.Vision.Motion.IMotionProcessing.Reset">
             <summary>
             Reset internal state of motion processing algorithm.
             </summary>
             
             <remarks><para>The method allows to reset internal state of motion processing
             algorithm and prepare it for processing of next video stream or to restart
             the algorithm.</para>
             
             <para><note>Some motion processing algorithms may not have any stored internal
             states and may just process provided video frames without relying on any motion
             history etc. In this case such algorithms provide empty implementation of this method.</note></para>
             </remarks>
            
        </member>
        <member name="M:BestCS.Vision.Motion.BlobCountingObjectsProcessing.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Vision.Motion.BlobCountingObjectsProcessing"/> class.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Motion.BlobCountingObjectsProcessing.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Vision.Motion.BlobCountingObjectsProcessing"/> class.
            </summary>
            
            <param name="highlightMotionRegions">Highlight motion regions or not (see <see cref="P:BestCS.Vision.Motion.BlobCountingObjectsProcessing.HighlightMotionRegions"/> property).</param>
            
        </member>
        <member name="M:BestCS.Vision.Motion.BlobCountingObjectsProcessing.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Vision.Motion.BlobCountingObjectsProcessing"/> class.
            </summary>
            
            <param name="minWidth">Minimum width of acceptable object (see <see cref="P:BestCS.Vision.Motion.BlobCountingObjectsProcessing.MinObjectsWidth"/> property).</param>
            <param name="minHeight">Minimum height of acceptable object (see <see cref="P:BestCS.Vision.Motion.BlobCountingObjectsProcessing.MinObjectsHeight"/> property).</param>
            
        </member>
        <member name="M:BestCS.Vision.Motion.BlobCountingObjectsProcessing.#ctor(System.Int32,System.Int32,System.Drawing.Color)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Vision.Motion.BlobCountingObjectsProcessing"/> class.
            </summary>
            
            <param name="minWidth">Minimum width of acceptable object (see <see cref="P:BestCS.Vision.Motion.BlobCountingObjectsProcessing.MinObjectsWidth"/> property).</param>
            <param name="minHeight">Minimum height of acceptable object (see <see cref="P:BestCS.Vision.Motion.BlobCountingObjectsProcessing.MinObjectsHeight"/> property).</param>
            <param name="highlightColor">Color used to highlight motion regions.</param>
            
        </member>
        <member name="M:BestCS.Vision.Motion.BlobCountingObjectsProcessing.#ctor(System.Int32,System.Int32,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Vision.Motion.BlobCountingObjectsProcessing"/> class.
            </summary>
            
            <param name="minWidth">Minimum width of acceptable object (see <see cref="P:BestCS.Vision.Motion.BlobCountingObjectsProcessing.MinObjectsWidth"/> property).</param>
            <param name="minHeight">Minimum height of acceptable object (see <see cref="P:BestCS.Vision.Motion.BlobCountingObjectsProcessing.MinObjectsHeight"/> property).</param>
            <param name="highlightMotionRegions">Highlight motion regions or not (see <see cref="P:BestCS.Vision.Motion.BlobCountingObjectsProcessing.HighlightMotionRegions"/> property).</param>
            
        </member>
        <member name="M:BestCS.Vision.Motion.BlobCountingObjectsProcessing.ProcessFrame(BestCS.Imaging.UnmanagedImage,BestCS.Imaging.UnmanagedImage)">
            <summary>
            Process video and motion frames doing further post processing after
            performed motion detection.
            </summary>
            
            <param name="videoFrame">Original video frame.</param>
            <param name="motionFrame">Motion frame provided by motion detection
            algorithm (see <see cref="T:BestCS.Vision.Motion.IMotionDetector"/>).</param>
            
            <remarks><para>Processes provided motion frame and counts number of separate
            objects, which size satisfies <see cref="P:BestCS.Vision.Motion.BlobCountingObjectsProcessing.MinObjectsWidth"/> and <see cref="P:BestCS.Vision.Motion.BlobCountingObjectsProcessing.MinObjectsHeight"/>
            properties. In the case if <see cref="P:BestCS.Vision.Motion.BlobCountingObjectsProcessing.HighlightMotionRegions"/> property is
            set to <see langword="true"/>, the found object are also highlighted on the
            original video frame.
            </para></remarks>
            
            <exception cref="T:BestCS.Imaging.InvalidImagePropertiesException">Motion frame is not 8 bpp image, but it must be so.</exception>
            <exception cref="T:BestCS.Imaging.UnsupportedImageFormatException">Video frame must be 8 bpp grayscale image or 24/32 bpp color image.</exception>
            
        </member>
        <member name="M:BestCS.Vision.Motion.BlobCountingObjectsProcessing.Reset">
             <summary>
             Reset internal state of motion processing algorithm.
             </summary>
             
             <remarks><para>The method allows to reset internal state of motion processing
             algorithm and prepare it for processing of next video stream or to restart
             the algorithm.</para></remarks>
            
        </member>
        <member name="P:BestCS.Vision.Motion.BlobCountingObjectsProcessing.HighlightMotionRegions">
             <summary>
             Highlight motion regions or not.
             </summary>
             
             <remarks><para>The property specifies if detected moving objects should be highlighted
             with rectangle or not.</para>
             
             <para>Default value is set to <see langword="true"/>.</para>
            
             <para><note>Turning the value on leads to additional processing time of video frame.</note></para>
             </remarks>
             
        </member>
        <member name="P:BestCS.Vision.Motion.BlobCountingObjectsProcessing.HighlightColor">
            <summary>
            Color used to highlight motion regions.
            </summary>
            
            <remarks>
            <para>Default value is set to <b>red</b> color.</para>
            </remarks>
            
        </member>
        <member name="P:BestCS.Vision.Motion.BlobCountingObjectsProcessing.MinObjectsWidth">
            <summary>
            Minimum width of acceptable object.
            </summary>
            
            <remarks><para>The property sets minimum width of an object to count and highlight. If
            objects have smaller width, they are not counted and are not highlighted.</para>
            
            <para>Default value is set to <b>10</b>.</para>
            </remarks>
            
        </member>
        <member name="P:BestCS.Vision.Motion.BlobCountingObjectsProcessing.MinObjectsHeight">
            <summary>
            Minimum height of acceptable object.
            </summary>
            
            <remarks><para>The property sets minimum height of an object to count and highlight. If
            objects have smaller height, they are not counted and are not highlighted.</para>
            
            <para>Default value is set to <b>10</b>.</para>
            </remarks>
            
        </member>
        <member name="P:BestCS.Vision.Motion.BlobCountingObjectsProcessing.ObjectsCount">
            <summary>
            Number of detected objects.
            </summary>
            
            <remarks><para>The property provides number of moving objects detected by
            the last call of <see cref="M:BestCS.Vision.Motion.BlobCountingObjectsProcessing.ProcessFrame(BestCS.Imaging.UnmanagedImage,BestCS.Imaging.UnmanagedImage)"/> method.</para></remarks>
            
        </member>
        <member name="P:BestCS.Vision.Motion.BlobCountingObjectsProcessing.ObjectRectangles">
            <summary>
            Rectangles of moving objects.
            </summary>
            
            <remarks><para>The property provides array of moving objects' rectangles
            detected by the last call of <see cref="M:BestCS.Vision.Motion.BlobCountingObjectsProcessing.ProcessFrame(BestCS.Imaging.UnmanagedImage,BestCS.Imaging.UnmanagedImage)"/> method.</para></remarks>
            
        </member>
        <member name="T:BestCS.Vision.Motion.CustomFrameDifferenceDetector">
            <summary>
            Motion detector based on difference with predefined background frame.
            </summary>
            
            <remarks><para>The class implements motion detection algorithm, which is based on
            difference of current video frame with predefined background frame. The <see cref="P:BestCS.Vision.Motion.CustomFrameDifferenceDetector.MotionFrame">difference frame</see>
            is thresholded and the <see cref="P:BestCS.Vision.Motion.CustomFrameDifferenceDetector.MotionLevel">amount of difference pixels</see> is calculated.
            To suppress stand-alone noisy pixels erosion morphological operator may be applied, which
            is controlled by <see cref="P:BestCS.Vision.Motion.CustomFrameDifferenceDetector.SuppressNoise"/> property.</para>
            
            <para><note>In the case if precise motion area's borders are required (for example,
            for further motion post processing), then <see cref="P:BestCS.Vision.Motion.CustomFrameDifferenceDetector.KeepObjectsEdges"/> property
            may be used to restore borders after noise suppression.</note></para>
            
            <para><note>In the case if custom background frame is not specified by using
            <see cref="M:BestCS.Vision.Motion.CustomFrameDifferenceDetector.SetBackgroundFrame(System.Drawing.Bitmap)"/> method, the algorithm takes first video frame
            as a background frame and calculates difference of further video frames with it.</note></para>
            
            <para>Unlike <see cref="T:BestCS.Vision.Motion.TwoFramesDifferenceDetector"/> motion detection algorithm, this algorithm
            allows to identify quite clearly all objects, which are not part of the background (scene) -
            most likely moving objects.</para>
            
            <para>Sample usage:</para>
            <code>
            // create motion detector
            MotionDetector detector = new MotionDetector(
                new CustomFrameDifferenceDetector( ),
                new MotionAreaHighlighting( ) );
            
            // continuously feed video frames to motion detector
            while ( ... )
            {
                // process new video frame and check motion level
                if ( detector.ProcessFrame( videoFrame ) &gt; 0.02 )
                {
                    // ring alarm or do somethng else
                }
            }
            </code>
            </remarks>
            
            <seealso cref="T:BestCS.Vision.Motion.MotionDetector"/>
            
        </member>
        <member name="T:BestCS.Vision.Motion.IMotionDetector">
             <summary>
             Interface of motion detector algorithm.
             </summary>
             
             <remarks><para>The interface specifies methods, which should be implemented
             by all motion detection algorithms - algorithms which perform processing of video
             frames in order to detect motion. Amount of detected motion may be checked using
             <see cref="P:BestCS.Vision.Motion.IMotionDetector.MotionLevel"/> property. Also <see cref="P:BestCS.Vision.Motion.IMotionDetector.MotionFrame"/> property may
             be used in order to see all the detected motion areas. For example, the <see cref="P:BestCS.Vision.Motion.IMotionDetector.MotionFrame"/> property
             is used by motion processing algorithms for further motion post processing, like
             highlighting motion areas, counting number of detected moving object, etc.
             </para></remarks>
             
             <seealso cref="T:BestCS.Vision.Motion.MotionDetector"/>
             <seealso cref="T:BestCS.Vision.Motion.IMotionProcessing"/>
            
            
        </member>
        <member name="M:BestCS.Vision.Motion.IMotionDetector.ProcessFrame(BestCS.Imaging.UnmanagedImage)">
            <summary>
            Process new video frame.
            </summary>
            
            <param name="videoFrame">Video frame to process (detect motion in).</param>
            
            <remarks><para>Processes new frame from video source and detects motion in it.</para></remarks>
            
        </member>
        <member name="M:BestCS.Vision.Motion.IMotionDetector.Reset">
            <summary>
            Reset motion detector to initial state.
            </summary>
            
            <remarks><para>Resets internal state and variables of motion detection algorithm.
            Usually this is required to be done before processing new video source, but
            may be also done at any time to restart motion detection algorithm.</para>
            </remarks>
            
        </member>
        <member name="P:BestCS.Vision.Motion.IMotionDetector.MotionLevel">
            <summary>
            Motion level value, [0, 1].
            </summary>
            
            <remarks><para>Amount of changes in the last processed frame. For example, if value of
            this property equals to 0.1, then it means that last processed frame has 10% of changes
            (however it is up to specific implementation to decide how to compare specified frame).</para>
            </remarks>
            
        </member>
        <member name="P:BestCS.Vision.Motion.IMotionDetector.MotionFrame">
            <summary>
            Motion frame containing detected areas of motion.
            </summary>
            
            <remarks><para>Motion frame is a grayscale image, which shows areas of detected motion.
            All black pixels in the motion frame correspond to areas, where no motion is
            detected. But white pixels correspond to areas, where motion is detected.</para></remarks>
            
        </member>
        <member name="M:BestCS.Vision.Motion.CustomFrameDifferenceDetector.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Vision.Motion.CustomFrameDifferenceDetector"/> class.
            </summary>
        </member>
        <member name="M:BestCS.Vision.Motion.CustomFrameDifferenceDetector.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Vision.Motion.CustomFrameDifferenceDetector"/> class.
            </summary>
            
            <param name="suppressNoise">Suppress noise in video frames or not (see <see cref="P:BestCS.Vision.Motion.CustomFrameDifferenceDetector.SuppressNoise"/> property).</param>
            
        </member>
        <member name="M:BestCS.Vision.Motion.CustomFrameDifferenceDetector.#ctor(System.Boolean,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Vision.Motion.CustomFrameDifferenceDetector"/> class.
            </summary>
            
            <param name="suppressNoise">Suppress noise in video frames or not (see <see cref="P:BestCS.Vision.Motion.CustomFrameDifferenceDetector.SuppressNoise"/> property).</param>
            <param name="keepObjectEdges">Restore objects edges after noise suppression or not (see <see cref="P:BestCS.Vision.Motion.CustomFrameDifferenceDetector.KeepObjectsEdges"/> property).</param>
            
        </member>
        <member name="M:BestCS.Vision.Motion.CustomFrameDifferenceDetector.ProcessFrame(BestCS.Imaging.UnmanagedImage)">
            <summary>
            Process new video frame.
            </summary>
            
            <param name="videoFrame">Video frame to process (detect motion in).</param>
            
            <remarks><para>Processes new frame from video source and detects motion in it.</para>
            
            <para>Check <see cref="P:BestCS.Vision.Motion.CustomFrameDifferenceDetector.MotionLevel"/> property to get information about amount of motion
            (changes) in the processed frame.</para>
            </remarks>
            
        </member>
        <member name="M:BestCS.Vision.Motion.CustomFrameDifferenceDetector.Reset">
            <summary>
            Reset motion detector to initial state.
            </summary>
            
            <remarks><para>Resets internal state and variables of motion detection algorithm.
            Usually this is required to be done before processing new video source, but
            may be also done at any time to restart motion detection algorithm.</para>
            
            <para><note>In the case if custom background frame was set using
            <see cref="M:BestCS.Vision.Motion.CustomFrameDifferenceDetector.SetBackgroundFrame(System.Drawing.Bitmap)"/> method, this method does not reset it.
            The method resets only automatically generated background frame.
            </note></para>
            </remarks>
            
        </member>
        <member name="M:BestCS.Vision.Motion.CustomFrameDifferenceDetector.SetBackgroundFrame(System.Drawing.Bitmap)">
            <summary>
            Set background frame.
            </summary>
            
            <param name="backgroundFrame">Background frame to set.</param>
            
            <remarks><para>The method sets background frame, which will be used to calculate
            difference with.</para></remarks>
            
        </member>
        <member name="M:BestCS.Vision.Motion.CustomFrameDifferenceDetector.SetBackgroundFrame(System.Drawing.Imaging.BitmapData)">
            <summary>
            Set background frame.
            </summary>
            
            <param name="backgroundFrame">Background frame to set.</param>
            
            <remarks><para>The method sets background frame, which will be used to calculate
            difference with.</para></remarks>
            
        </member>
        <member name="M:BestCS.Vision.Motion.CustomFrameDifferenceDetector.SetBackgroundFrame(BestCS.Imaging.UnmanagedImage)">
            <summary>
            Set background frame.
            </summary>
            
            <param name="backgroundFrame">Background frame to set.</param>
            
            <remarks><para>The method sets background frame, which will be used to calculate
            difference with.</para></remarks>
            
        </member>
        <member name="P:BestCS.Vision.Motion.CustomFrameDifferenceDetector.DifferenceThreshold">
            <summary>
            Difference threshold value, [1, 255].
            </summary>
            
            <remarks><para>The value specifies the amount off difference between pixels, which is treated
            as motion pixel.</para>
            
            <para>Default value is set to <b>15</b>.</para>
            </remarks>
            
        </member>
        <member name="P:BestCS.Vision.Motion.CustomFrameDifferenceDetector.MotionLevel">
            <summary>
            Motion level value, [0, 1].
            </summary>
            
            <remarks><para>Amount of changes in the last processed frame. For example, if value of
            this property equals to 0.1, then it means that last processed frame has 10% difference
            with defined background frame.</para>
            </remarks>
            
        </member>
        <member name="P:BestCS.Vision.Motion.CustomFrameDifferenceDetector.MotionFrame">
             <summary>
             Motion frame containing detected areas of motion.
             </summary>
             
             <remarks><para>Motion frame is a grayscale image, which shows areas of detected motion.
             All black pixels in the motion frame correspond to areas, where no motion is
             detected. But white pixels correspond to areas, where motion is detected.</para>
             
             <para><note>The property is set to <see langword="null"/> after processing of the first
             video frame by the algorithm in the case if custom background frame was not set manually
             by using <see cref="M:BestCS.Vision.Motion.CustomFrameDifferenceDetector.SetBackgroundFrame(System.Drawing.Bitmap)"/> method (it will be not <see langword="null"/>
             after second call in this case). If correct custom background
             was set then the property should bet set to estimated motion frame after
             <see cref="M:BestCS.Vision.Motion.CustomFrameDifferenceDetector.ProcessFrame(BestCS.Imaging.UnmanagedImage)"/> method call.</note></para>
             </remarks>
            
        </member>
        <member name="P:BestCS.Vision.Motion.CustomFrameDifferenceDetector.SuppressNoise">
            <summary>
            Suppress noise in video frames or not.
            </summary>
            
            <remarks><para>The value specifies if additional filtering should be
            done to suppress standalone noisy pixels by applying 3x3 erosion image processing
            filter. See <see cref="P:BestCS.Vision.Motion.CustomFrameDifferenceDetector.KeepObjectsEdges"/> property, if it is required to restore
            edges of objects, which are not noise.</para>
            
            <para>Default value is set to <see langword="true"/>.</para>
            
            <para><note>Turning the value on leads to more processing time of video frame.</note></para>
            </remarks>
            
        </member>
        <member name="P:BestCS.Vision.Motion.CustomFrameDifferenceDetector.KeepObjectsEdges">
            <summary>
            Restore objects edges after noise suppression or not.
            </summary>
            
            <remarks><para>The value specifies if additional filtering should be done
            to restore objects' edges after noise suppression by applying 3x3 dilatation
            image processing filter.</para>
            
            <para>Default value is set to <see langword="false"/>.</para>
            
            <para><note>Turning the value on leads to more processing time of video frame.</note></para>
            </remarks>
            
        </member>
        <member name="T:BestCS.Vision.Motion.GridMotionAreaProcessing">
            <summary>
            Motion processing algorithm, which performs grid processing of motion frame.
            </summary>
            
            <remarks><para>The aim of this motion processing algorithm is to do grid processing
            of motion frame. This means that entire motion frame is divided by a grid into
            certain amount of cells and the motion level is calculated for each cell. The
            information about each cell's motion level may be retrieved using <see cref="P:BestCS.Vision.Motion.GridMotionAreaProcessing.MotionGrid"/>
            property.</para>
            
            <para><para>In addition the algorithm can highlight those cells, which have motion
            level above the specified threshold (see <see cref="P:BestCS.Vision.Motion.GridMotionAreaProcessing.MotionAmountToHighlight"/>
            property). To enable this it is required to set <see cref="P:BestCS.Vision.Motion.GridMotionAreaProcessing.HighlightMotionGrid"/>
            property to <see langword="true"/>.</para></para>
            
            <para>Sample usage:</para>
            <code>
            // create instance of motion detection algorithm
            IMotionDetector motionDetector = new ... ;
            // create instance of motion processing algorithm
            GridMotionAreaProcessing motionProcessing = new GridMotionAreaProcessing( 16, 16 );
            // create motion detector
            MotionDetector detector = new MotionDetector( motionDetector, motionProcessing );
            
            // continuously feed video frames to motion detector
            while ( ... )
            {
                // process new video frame
                detector.ProcessFrame( videoFrame );
                
                // check motion level in 5th row 8th column
                if ( motionProcessing.MotionGrid[5, 8] &gt; 0.15 )
                {
                    // ...
                }
            }
            </code>
            </remarks>
            
            <seealso cref="T:BestCS.Vision.Motion.MotionDetector"/>
            <seealso cref="T:BestCS.Vision.Motion.IMotionDetector"/>
            
        </member>
        <member name="M:BestCS.Vision.Motion.GridMotionAreaProcessing.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Vision.Motion.GridMotionAreaProcessing"/> class.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Motion.GridMotionAreaProcessing.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Vision.Motion.GridMotionAreaProcessing"/> class.
            </summary>
            
            <param name="gridWidth">Width of motion grid (see <see cref="P:BestCS.Vision.Motion.GridMotionAreaProcessing.GridWidth"/> property).</param>
            <param name="gridHeight">Height of motion grid (see <see cref="P:BestCS.Vision.Motion.GridMotionAreaProcessing.GridHeight"/> property).</param>
            
        </member>
        <member name="M:BestCS.Vision.Motion.GridMotionAreaProcessing.#ctor(System.Int32,System.Int32,System.Boolean)">
             <summary>
             Initializes a new instance of the <see cref="T:BestCS.Vision.Motion.GridMotionAreaProcessing"/> class.
             </summary>
             
             <param name="gridWidth">Width of motion grid (see <see cref="P:BestCS.Vision.Motion.GridMotionAreaProcessing.GridWidth"/> property).</param>
             <param name="gridHeight">Height of motion grid (see <see cref="P:BestCS.Vision.Motion.GridMotionAreaProcessing.GridHeight"/> property).</param>
             <param name="highlightMotionGrid">Highlight motion regions or not (see <see cref="P:BestCS.Vision.Motion.GridMotionAreaProcessing.HighlightMotionGrid"/> property).</param>
            
        </member>
        <member name="M:BestCS.Vision.Motion.GridMotionAreaProcessing.#ctor(System.Int32,System.Int32,System.Boolean,System.Single)">
             <summary>
             Initializes a new instance of the <see cref="T:BestCS.Vision.Motion.GridMotionAreaProcessing"/> class.
             </summary>
             
             <param name="gridWidth">Width of motion grid (see <see cref="P:BestCS.Vision.Motion.GridMotionAreaProcessing.GridWidth"/> property).</param>
             <param name="gridHeight">Height of motion grid (see <see cref="P:BestCS.Vision.Motion.GridMotionAreaProcessing.GridHeight"/> property).</param>
             <param name="highlightMotionGrid">Highlight motion regions or not (see <see cref="P:BestCS.Vision.Motion.GridMotionAreaProcessing.HighlightMotionGrid"/> property).</param>
             <param name="motionAmountToHighlight">Motion amount to highlight cell (see <see cref="P:BestCS.Vision.Motion.GridMotionAreaProcessing.MotionAmountToHighlight"/> property).</param>
            
        </member>
        <member name="M:BestCS.Vision.Motion.GridMotionAreaProcessing.ProcessFrame(BestCS.Imaging.UnmanagedImage,BestCS.Imaging.UnmanagedImage)">
             <summary>
             Process video and motion frames doing further post processing after
             performed motion detection.
             </summary>
             
             <param name="videoFrame">Original video frame.</param>
             <param name="motionFrame">Motion frame provided by motion detection
             algorithm (see <see cref="T:BestCS.Vision.Motion.IMotionDetector"/>).</param>
             
             <remarks><para>Processes provided motion frame and calculates motion level
             for each grid's cell. In the case if <see cref="P:BestCS.Vision.Motion.GridMotionAreaProcessing.HighlightMotionGrid"/> property is
             set to <see langword="true"/>, the cell with motion level above threshold are
             highlighted.</para></remarks>
            
             <exception cref="T:BestCS.Imaging.InvalidImagePropertiesException">Motion frame is not 8 bpp image, but it must be so.</exception>
             <exception cref="T:BestCS.Imaging.UnsupportedImageFormatException">Video frame must be 8 bpp grayscale image or 24/32 bpp color image.</exception>
            
        </member>
        <member name="M:BestCS.Vision.Motion.GridMotionAreaProcessing.Reset">
             <summary>
             Reset internal state of motion processing algorithm.
             </summary>
             
             <remarks><para>The method allows to reset internal state of motion processing
             algorithm and prepare it for processing of next video stream or to restart
             the algorithm.</para></remarks>
            
        </member>
        <member name="P:BestCS.Vision.Motion.GridMotionAreaProcessing.HighlightColor">
            <summary>
            Color used to highlight motion regions.
            </summary>
            
            <remarks>
            <para>Default value is set to <b>red</b> color.</para>
            </remarks>
            
        </member>
        <member name="P:BestCS.Vision.Motion.GridMotionAreaProcessing.HighlightMotionGrid">
             <summary>
             Highlight motion regions or not.
             </summary>
             
             <remarks><para>The property specifies if motion grid should be highlighted -
             if cell, which have motion level above the
             <see cref="P:BestCS.Vision.Motion.GridMotionAreaProcessing.MotionAmountToHighlight">specified value</see>, should be highlighted.</para>
             
             <para>Default value is set to <see langword="true"/>.</para>
            
             <para><note>Turning the value on leads to additional processing time of video frame.</note></para>
             </remarks>
             
        </member>
        <member name="P:BestCS.Vision.Motion.GridMotionAreaProcessing.MotionAmountToHighlight">
            <summary>
            Motion amount to highlight cell.
            </summary>
            
            <remarks><para>The property specifies motion level threshold for highlighting grid's
            cells. If motion level of a certain cell is higher than this value, then the cell
            is highlighted.</para>
            
            <para>Default value is set to <b>0.15</b>.</para>
            </remarks>
            
        </member>
        <member name="P:BestCS.Vision.Motion.GridMotionAreaProcessing.MotionGrid">
            <summary>
            Motion levels of each grid's cell.
            </summary>
            
            <remarks><para>The property represents an array of size
            <see cref="P:BestCS.Vision.Motion.GridMotionAreaProcessing.GridHeight"/>x<see cref="P:BestCS.Vision.Motion.GridMotionAreaProcessing.GridWidth"/>, which keeps motion level
            of each grid's cell. If certain cell has motion level equal to 0.2, then it
            means that this cell has 20% of changes.</para>
            </remarks>
            
        </member>
        <member name="P:BestCS.Vision.Motion.GridMotionAreaProcessing.GridWidth">
             <summary>
             Width of motion grid, [2, 64].
             </summary>
             
             <remarks><para>The property specifies motion grid's width - number of grid' columns.</para>
            
             <para>Default value is set to <b>16</b>.</para>
             </remarks>
             
        </member>
        <member name="P:BestCS.Vision.Motion.GridMotionAreaProcessing.GridHeight">
             <summary>
             Height of motion grid, [2, 64].
             </summary>
             
             <remarks><para>The property specifies motion grid's height - number of grid' rows.</para>
            
             <para>Default value is set to <b>16</b>.</para>
             </remarks>
             
        </member>
        <member name="T:BestCS.Vision.Motion.MotionAreaHighlighting">
            <summary>
            Motion processing algorithm, which highlights motion areas.
            </summary>
            
            <remarks><para>The aim of this motion processing algorithm is to highlight
            motion areas with grid pattern of the <see cref="P:BestCS.Vision.Motion.MotionAreaHighlighting.HighlightColor">specified color</see>.
            </para>
            
            <para>Sample usage:</para>
            <code>
            // create motion detector
            MotionDetector detector = new MotionDetector(
                /* motion detection algorithm */,
                new MotionAreaHighlighting( ) );
            
            // continuously feed video frames to motion detector
            while ( ... )
            {
                // process new video frame
                detector.ProcessFrame( videoFrame );
            }
            </code>
            </remarks>
            
            <seealso cref="T:BestCS.Vision.Motion.MotionDetector"/>
            <seealso cref="T:BestCS.Vision.Motion.IMotionDetector"/>
            
        </member>
        <member name="M:BestCS.Vision.Motion.MotionAreaHighlighting.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Vision.Motion.MotionAreaHighlighting"/> class.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Motion.MotionAreaHighlighting.#ctor(System.Drawing.Color)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Vision.Motion.MotionAreaHighlighting"/> class.
            </summary>
            
            <param name="highlightColor">Color used to highlight motion regions.</param>
            
        </member>
        <member name="M:BestCS.Vision.Motion.MotionAreaHighlighting.ProcessFrame(BestCS.Imaging.UnmanagedImage,BestCS.Imaging.UnmanagedImage)">
             <summary>
             Process video and motion frames doing further post processing after
             performed motion detection.
             </summary>
             
             <param name="videoFrame">Original video frame.</param>
             <param name="motionFrame">Motion frame provided by motion detection
             algorithm (see <see cref="T:BestCS.Vision.Motion.IMotionDetector"/>).</param>
             
             <remarks><para>Processes provided motion frame and highlights motion areas
             on the original video frame with <see cref="P:BestCS.Vision.Motion.MotionAreaHighlighting.HighlightColor">specified color</see>.</para>
             </remarks>
             
             <exception cref="T:BestCS.Imaging.InvalidImagePropertiesException">Motion frame is not 8 bpp image, but it must be so.</exception>
             <exception cref="T:BestCS.Imaging.UnsupportedImageFormatException">Video frame must be 8 bpp grayscale image or 24/32 bpp color image.</exception>
            
        </member>
        <member name="M:BestCS.Vision.Motion.MotionAreaHighlighting.Reset">
             <summary>
             Reset internal state of motion processing algorithm.
             </summary>
             
             <remarks><para>The method allows to reset internal state of motion processing
             algorithm and prepare it for processing of next video stream or to restart
             the algorithm.</para></remarks>
            
        </member>
        <member name="P:BestCS.Vision.Motion.MotionAreaHighlighting.HighlightColor">
            <summary>
            Color used to highlight motion regions.
            </summary>
            
            <remarks>
            <para>Default value is set to <b>red</b> color.</para>
            </remarks>
            
        </member>
        <member name="T:BestCS.Vision.Motion.MotionBorderHighlighting">
            <summary>
            Motion processing algorithm, which highlights border of motion areas.
            </summary>
            
            <remarks><para>The aim of this motion processing algorithm is to highlight
            borders of motion areas with the <see cref="P:BestCS.Vision.Motion.MotionBorderHighlighting.HighlightColor">specified color</see>.
            </para>
            
            <para><note>The motion processing algorithm is supposed to be used only with motion detection
            algorithms, which are based on finding difference with background frame
            (see <see cref="T:BestCS.Vision.Motion.SimpleBackgroundModelingDetector"/> and <see cref="T:BestCS.Vision.Motion.CustomFrameDifferenceDetector"/>
            as simple implementations) and allow extract moving objects clearly.</note></para>
            
            <para>Sample usage:</para>
            <code>
            // create motion detector
            MotionDetector detector = new MotionDetector(
                /* motion detection algorithm */,
                new MotionBorderHighlighting( ) );
            
            // continuously feed video frames to motion detector
            while ( ... )
            {
                // process new video frame
                detector.ProcessFrame( videoFrame );
            }
            </code>
            </remarks>
            
            <seealso cref="T:BestCS.Vision.Motion.MotionDetector"/>
            <seealso cref="T:BestCS.Vision.Motion.IMotionDetector"/>
            
        </member>
        <member name="M:BestCS.Vision.Motion.MotionBorderHighlighting.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Vision.Motion.MotionBorderHighlighting"/> class.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Motion.MotionBorderHighlighting.#ctor(System.Drawing.Color)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Vision.Motion.MotionBorderHighlighting"/> class.
            </summary>
            
            <param name="highlightColor">Color used to highlight motion regions.</param>
            
        </member>
        <member name="M:BestCS.Vision.Motion.MotionBorderHighlighting.ProcessFrame(BestCS.Imaging.UnmanagedImage,BestCS.Imaging.UnmanagedImage)">
             <summary>
             Process video and motion frames doing further post processing after
             performed motion detection.
             </summary>
             
             <param name="videoFrame">Original video frame.</param>
             <param name="motionFrame">Motion frame provided by motion detection
             algorithm (see <see cref="T:BestCS.Vision.Motion.IMotionDetector"/>).</param>
             
             <remarks><para>Processes provided motion frame and highlights borders of motion areas
             on the original video frame with <see cref="P:BestCS.Vision.Motion.MotionBorderHighlighting.HighlightColor">specified color</see>.</para>
             </remarks>
            
             <exception cref="T:BestCS.Imaging.InvalidImagePropertiesException">Motion frame is not 8 bpp image, but it must be so.</exception>
             <exception cref="T:BestCS.Imaging.UnsupportedImageFormatException">Video frame must be 8 bpp grayscale image or 24/32 bpp color image.</exception>
            
        </member>
        <member name="M:BestCS.Vision.Motion.MotionBorderHighlighting.Reset">
             <summary>
             Reset internal state of motion processing algorithm.
             </summary>
             
             <remarks><para>The method allows to reset internal state of motion processing
             algorithm and prepare it for processing of next video stream or to restart
             the algorithm.</para></remarks>
            
        </member>
        <member name="P:BestCS.Vision.Motion.MotionBorderHighlighting.HighlightColor">
            <summary>
            Color used to highlight motion regions.
            </summary>
            
            <remarks>
            <para>Default value is set to <b>red</b> color.</para>
            </remarks>
            
        </member>
        <member name="T:BestCS.Vision.Motion.MotionDetector">
             <summary>
             Motion detection wrapper class, which performs motion detection and processing.
             </summary>
            
             <remarks><para>The class serves as a wrapper class for
             <see cref="T:BestCS.Vision.Motion.IMotionDetector">motion detection</see> and
             <see cref="T:BestCS.Vision.Motion.IMotionProcessing">motion processing</see> algorithms, allowing to call them with
             single call. Unlike motion detection and motion processing interfaces, the class also
             provides additional methods for convenience, so the algorithms could be applied not
             only to <see cref="T:BestCS.Imaging.UnmanagedImage"/>, but to .NET's <see cref="T:System.Drawing.Bitmap"/> class
             as well.</para>
             
             <para>In addition to wrapping of motion detection and processing algorthms, the class provides
             some additional functionality. Using <see cref="P:BestCS.Vision.Motion.MotionDetector.MotionZones"/> property it is possible to specify
             set of rectangular zones to observe - only motion in these zones is counted and post procesed.</para>
             
             <para>Sample usage:</para>
             <code>
             // create motion detector
             MotionDetector detector = new MotionDetector(
                 new SimpleBackgroundModelingDetector( ),
                 new MotionAreaHighlighting( ) );
             
             // continuously feed video frames to motion detector
             while ( ... )
             {
                 // process new video frame and check motion level
                 if ( detector.ProcessFrame( videoFrame ) &gt; 0.02 )
                 {
                     // ring alarm or do somethng else
                 }
             }
             </code>
             </remarks>
            
        </member>
        <member name="M:BestCS.Vision.Motion.MotionDetector.#ctor(BestCS.Vision.Motion.IMotionDetector)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Vision.Motion.MotionDetector"/> class.
            </summary>
            
            <param name="detector">Motion detection algorithm to apply to each video frame.</param>
            
        </member>
        <member name="M:BestCS.Vision.Motion.MotionDetector.#ctor(BestCS.Vision.Motion.IMotionDetector,BestCS.Vision.Motion.IMotionProcessing)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Vision.Motion.MotionDetector"/> class.
            </summary>
            
            <param name="detector">Motion detection algorithm to apply to each video frame.</param>
            <param name="processor">Motion processing algorithm to apply to each video frame after
            motion detection is done.</param>
            
        </member>
        <member name="M:BestCS.Vision.Motion.MotionDetector.ProcessFrame(System.Drawing.Bitmap)">
            <summary>
            Process new video frame.
            </summary>
            
            <param name="videoFrame">Video frame to process (detect motion in).</param>
            
            <returns>Returns amount of motion, which is provided <see cref="P:BestCS.Vision.Motion.IMotionDetector.MotionLevel"/>
            property of the <see cref="P:BestCS.Vision.Motion.MotionDetector.MotionDetectionAlgorithm">motion detection algorithm in use</see>.</returns>
            
            <remarks><para>See <see cref="M:BestCS.Vision.Motion.MotionDetector.ProcessFrame(BestCS.Imaging.UnmanagedImage)"/> for additional details.</para>
            </remarks>
            
        </member>
        <member name="M:BestCS.Vision.Motion.MotionDetector.ProcessFrame(System.Drawing.Imaging.BitmapData)">
             <summary>
             Process new video frame.
             </summary>
             
             <param name="videoFrame">Video frame to process (detect motion in).</param>
             
             <returns>Returns amount of motion, which is provided <see cref="P:BestCS.Vision.Motion.IMotionDetector.MotionLevel"/>
             property of the <see cref="P:BestCS.Vision.Motion.MotionDetector.MotionDetectionAlgorithm">motion detection algorithm in use</see>.</returns>
             
             <remarks><para>See <see cref="M:BestCS.Vision.Motion.MotionDetector.ProcessFrame(BestCS.Imaging.UnmanagedImage)"/> for additional details.</para>
             </remarks>
            
        </member>
        <member name="M:BestCS.Vision.Motion.MotionDetector.ProcessFrame(BestCS.Imaging.UnmanagedImage)">
            <summary>
            Process new video frame.
            </summary>
            
            <param name="videoFrame">Video frame to process (detect motion in).</param>
            
            <returns>Returns amount of motion, which is provided <see cref="P:BestCS.Vision.Motion.IMotionDetector.MotionLevel"/>
            property of the <see cref="P:BestCS.Vision.Motion.MotionDetector.MotionDetectionAlgorithm">motion detection algorithm in use</see>.</returns>
            
            <remarks><para>The method first of all applies motion detection algorithm to the specified video
            frame to calculate <see cref="P:BestCS.Vision.Motion.IMotionDetector.MotionLevel">motion level</see> and
            <see cref="P:BestCS.Vision.Motion.IMotionDetector.MotionFrame">motion frame</see>. After this it applies motion processing algorithm
            (if it was set) to do further post processing, like highlighting motion areas, counting moving
            objects, etc.</para>
            
            <para><note>In the case if <see cref="P:BestCS.Vision.Motion.MotionDetector.MotionZones"/> property is set, this method will perform
            motion filtering right after motion algorithm is done and before passing motion frame to motion
            processing algorithm. The method does filtering right on the motion frame, which is produced
            by motion detection algorithm. At the same time the method recalculates motion level and returns
            new value, which takes motion zones into account (but the new value is not set back to motion detection
            algorithm' <see cref="P:BestCS.Vision.Motion.IMotionDetector.MotionLevel"/> property).
            </note></para>
            </remarks>
            
        </member>
        <member name="M:BestCS.Vision.Motion.MotionDetector.Reset">
            <summary>
            Reset motion detector to initial state.
            </summary>
            
            <remarks><para>The method resets motion detection and motion processing algotithms by calling
            their <see cref="M:BestCS.Vision.Motion.IMotionDetector.Reset"/> and <see cref="M:BestCS.Vision.Motion.IMotionProcessing.Reset"/> methods.</para>
            </remarks>
            
        </member>
        <member name="P:BestCS.Vision.Motion.MotionDetector.MotionDetectionAlgorithm">
             <summary>
             Motion detection algorithm to apply to each video frame.
             </summary>
            
             <remarks><para>The property sets motion detection algorithm, which is used by
             <see cref="M:BestCS.Vision.Motion.MotionDetector.ProcessFrame(BestCS.Imaging.UnmanagedImage)"/> method in order to calculate
             <see cref="P:BestCS.Vision.Motion.IMotionDetector.MotionLevel">motion level</see> and
             <see cref="P:BestCS.Vision.Motion.IMotionDetector.MotionFrame">motion frame</see>.
             </para></remarks>
            
        </member>
        <member name="P:BestCS.Vision.Motion.MotionDetector.MotionProcessingAlgorithm">
            <summary>
            Motion processing algorithm to apply to each video frame after
            motion detection is done.
            </summary>
            
            <remarks><para>The property sets motion processing algorithm, which is used by
            <see cref="M:BestCS.Vision.Motion.MotionDetector.ProcessFrame(BestCS.Imaging.UnmanagedImage)"/> method after motion detection in order to do further
            post processing of motion frames. The aim of further post processing depends on
            actual implementation of the specified motion processing algorithm - it can be
            highlighting of motion area, objects counting, etc.
            </para></remarks>
            
        </member>
        <member name="P:BestCS.Vision.Motion.MotionDetector.MotionZones">
            <summary>
            Set of zones to detect motion in.
            </summary>
            
            <remarks><para>The property keeps array of rectangular zones, which are observed for motion detection.
            Motion outside of these zones is ignored.</para>
            
            <para>In the case if this property is set, the <see cref="M:BestCS.Vision.Motion.MotionDetector.ProcessFrame(BestCS.Imaging.UnmanagedImage)"/> method
            will filter out all motion witch was detected by motion detection algorithm, but is not
            located in the specified zones.</para>
            </remarks>
            
        </member>
        <member name="T:BestCS.Vision.Motion.SimpleBackgroundModelingDetector">
            <summary>
            Motion detector based on simple background modeling.
            </summary>
            
            <remarks><para>The class implements motion detection algorithm, which is based on
            difference of current video frame with modeled background frame.
            The <see cref="P:BestCS.Vision.Motion.SimpleBackgroundModelingDetector.MotionFrame">difference frame</see> is thresholded and the
            <see cref="P:BestCS.Vision.Motion.SimpleBackgroundModelingDetector.MotionLevel">amount of difference pixels</see> is calculated.
            To suppress stand-alone noisy pixels erosion morphological operator may be applied, which
            is controlled by <see cref="P:BestCS.Vision.Motion.SimpleBackgroundModelingDetector.SuppressNoise"/> property.</para>
            
            <para><note>In the case if precise motion area's borders are required (for example,
            for further motion post processing), then <see cref="P:BestCS.Vision.Motion.SimpleBackgroundModelingDetector.KeepObjectsEdges"/> property
            may be used to restore borders after noise suppression.</note></para>
            
            <para>As the first approximation of background frame, the first frame of video stream is taken.
            During further video processing the background frame is constantly updated, so it
            changes in the direction to decrease difference with current video frame (the background
            frame is moved towards current frame). See <see cref="P:BestCS.Vision.Motion.SimpleBackgroundModelingDetector.FramesPerBackgroundUpdate"/>
            <see cref="P:BestCS.Vision.Motion.SimpleBackgroundModelingDetector.MillisecondsPerBackgroundUpdate"/> properties, which control the rate of
            background frame update.</para>
            
            <para>Unlike <see cref="T:BestCS.Vision.Motion.TwoFramesDifferenceDetector"/> motion detection algorithm, this algorithm
            allows to identify quite clearly all objects, which are not part of the background (scene) -
            most likely moving objects. And unlike <see cref="T:BestCS.Vision.Motion.CustomFrameDifferenceDetector"/> motion
            detection algorithm, this algorithm includes background adaptation feature, which allows it
            to update its modeled background frame in order to take scene changes into account.</para>
            
            <para><note>Because of the adaptation feature of the algorithm, it may adopt
            to background changes, what <see cref="T:BestCS.Vision.Motion.CustomFrameDifferenceDetector"/> algorithm can not do.
            However, if moving object stays on the scene for a while (so algorithm adopts to it and does
            not treat it as a new moving object any more) and then starts to move again, the algorithm may
            find two moving objects - the true one, which is really moving, and the false one, which does not (the
            place, where the object stayed for a while).</note></para>
            
            <para><note>The algorithm is not applicable to such cases, when moving object resides
            in camera's view most of the time (laptops camera monitoring a person sitting in front of it,
            for example). The algorithm is mostly supposed for cases, when camera monitors some sort
            of static scene, where moving objects appear from time to time - street, road, corridor, etc.
            </note></para>
            
            <para>Sample usage:</para>
            <code>
            // create motion detector
            MotionDetector detector = new MotionDetector(
                new SimpleBackgroundModelingDetector( ),
                new MotionAreaHighlighting( ) );
            
            // continuously feed video frames to motion detector
            while ( ... )
            {
                // process new video frame and check motion level
                if ( detector.ProcessFrame( videoFrame ) &gt; 0.02 )
                {
                    // ring alarm or do somethng else
                }
            }
            </code>
            </remarks>
            
            <seealso cref="T:BestCS.Vision.Motion.MotionDetector"/>
            
        </member>
        <member name="M:BestCS.Vision.Motion.SimpleBackgroundModelingDetector.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Vision.Motion.SimpleBackgroundModelingDetector"/> class.
            </summary>
        </member>
        <member name="M:BestCS.Vision.Motion.SimpleBackgroundModelingDetector.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Vision.Motion.SimpleBackgroundModelingDetector"/> class.
            </summary>
            
            <param name="suppressNoise">Suppress noise in video frames or not (see <see cref="P:BestCS.Vision.Motion.SimpleBackgroundModelingDetector.SuppressNoise"/> property).</param>
            
        </member>
        <member name="M:BestCS.Vision.Motion.SimpleBackgroundModelingDetector.#ctor(System.Boolean,System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Vision.Motion.SimpleBackgroundModelingDetector"/> class.
            </summary>
            
            <param name="suppressNoise">Suppress noise in video frames or not (see <see cref="P:BestCS.Vision.Motion.SimpleBackgroundModelingDetector.SuppressNoise"/> property).</param>
            <param name="keepObjectEdges">Restore objects edges after noise suppression or not (see <see cref="P:BestCS.Vision.Motion.SimpleBackgroundModelingDetector.KeepObjectsEdges"/> property).</param>
            
        </member>
        <member name="M:BestCS.Vision.Motion.SimpleBackgroundModelingDetector.ProcessFrame(BestCS.Imaging.UnmanagedImage)">
             <summary>
             Process new video frame.
             </summary>
             
             <param name="videoFrame">Video frame to process (detect motion in).</param>
             
             <remarks><para>Processes new frame from video source and detects motion in it.</para>
             
             <para>Check <see cref="P:BestCS.Vision.Motion.SimpleBackgroundModelingDetector.MotionLevel"/> property to get information about amount of motion
             (changes) in the processed frame.</para>
             </remarks>
            
        </member>
        <member name="M:BestCS.Vision.Motion.SimpleBackgroundModelingDetector.Reset">
            <summary>
            Reset motion detector to initial state.
            </summary>
            
            <remarks><para>Resets internal state and variables of motion detection algorithm.
            Usually this is required to be done before processing new video source, but
            may be also done at any time to restart motion detection algorithm.</para>
            </remarks>
            
        </member>
        <member name="P:BestCS.Vision.Motion.SimpleBackgroundModelingDetector.DifferenceThreshold">
            <summary>
            Difference threshold value, [1, 255].
            </summary>
            
            <remarks><para>The value specifies the amount off difference between pixels, which is treated
            as motion pixel.</para>
            
            <para>Default value is set to <b>15</b>.</para>
            </remarks>
            
        </member>
        <member name="P:BestCS.Vision.Motion.SimpleBackgroundModelingDetector.MotionLevel">
            <summary>
            Motion level value, [0, 1].
            </summary>
            
            <remarks><para>Amount of changes in the last processed frame. For example, if value of
            this property equals to 0.1, then it means that last processed frame has 10% difference
            with modeled background frame.</para>
            </remarks>
            
        </member>
        <member name="P:BestCS.Vision.Motion.SimpleBackgroundModelingDetector.MotionFrame">
             <summary>
             Motion frame containing detected areas of motion.
             </summary>
             
             <remarks><para>Motion frame is a grayscale image, which shows areas of detected motion.
             All black pixels in the motion frame correspond to areas, where no motion is
             detected. But white pixels correspond to areas, where motion is detected.</para>
             
             <para><note>The property is set to <see langword="null"/> after processing of the first
             video frame by the algorithm.</note></para>
             </remarks>
            
        </member>
        <member name="P:BestCS.Vision.Motion.SimpleBackgroundModelingDetector.SuppressNoise">
            <summary>
            Suppress noise in video frames or not.
            </summary>
            
            <remarks><para>The value specifies if additional filtering should be
            done to suppress standalone noisy pixels by applying 3x3 erosion image processing
            filter. See <see cref="P:BestCS.Vision.Motion.SimpleBackgroundModelingDetector.KeepObjectsEdges"/> property, if it is required to restore
            edges of objects, which are not noise.</para>
            
            <para>Default value is set to <see langword="true"/>.</para>
            
            <para><note>Turning the value on leads to more processing time of video frame.</note></para>
            </remarks>
            
        </member>
        <member name="P:BestCS.Vision.Motion.SimpleBackgroundModelingDetector.KeepObjectsEdges">
            <summary>
            Restore objects edges after noise suppression or not.
            </summary>
            
            <remarks><para>The value specifies if additional filtering should be done
            to restore objects' edges after noise suppression by applying 3x3 dilatation
            image processing filter.</para>
            
            <para>Default value is set to <see langword="false"/>.</para>
            
            <para><note>Turning the value on leads to more processing time of video frame.</note></para>
            </remarks>
            
        </member>
        <member name="P:BestCS.Vision.Motion.SimpleBackgroundModelingDetector.FramesPerBackgroundUpdate">
            <summary>
            Frames per background update, [1, 50].
            </summary>
            
            <remarks><para>The value controls the speed of modeled background adaptation to
            scene changes. After each specified amount of frames the background frame is updated
            in the direction to decrease difference with current processing frame.</para>
            
            <para>Default value is set to <b>2</b>.</para>
            
            <para><note>The property has effect only in the case if <see cref="P:BestCS.Vision.Motion.SimpleBackgroundModelingDetector.MillisecondsPerBackgroundUpdate"/>
            property is set to <b>0</b>. Otherwise it does not have effect and background
            update is managed according to the <see cref="P:BestCS.Vision.Motion.SimpleBackgroundModelingDetector.MillisecondsPerBackgroundUpdate"/>
            property settings.</note></para>
            </remarks>
            
        </member>
        <member name="P:BestCS.Vision.Motion.SimpleBackgroundModelingDetector.MillisecondsPerBackgroundUpdate">
            <summary>
            Milliseconds per background update, [0, 5000].
            </summary>
            
            <remarks><para>The value represents alternate way of controlling the speed of modeled
            background adaptation to scene changes. The value sets number of milliseconds, which
            should elapse between two consequent video frames to result in background update
            for one intensity level. For example, if this value is set to 100 milliseconds and
            the amount of time elapsed between two last video frames equals to 350, then background
            frame will be update for 3 intensity levels in the direction to decrease difference
            with current video frame (the remained 50 milliseconds will be added to time difference
            between two next consequent frames, so the accuracy is preserved).</para>
            
            <para>Unlike background update method controlled using <see cref="P:BestCS.Vision.Motion.SimpleBackgroundModelingDetector.FramesPerBackgroundUpdate"/>
            method, the method guided by this property is not affected by changes
            in frame rates. If, for some reasons, a video source starts to provide delays between
            frames (frame rate drops down), the amount of background update still stays consistent.
            When background update is controlled by this property, it is always possible to estimate
            amount of time required to change, for example, absolutely black background (0 intensity
            values) into absolutely white background (255 intensity values). If value of this
            property is set to 100, then it will take approximately 25.5 seconds for such update
            regardless of frame rate.</para>
            
            <para><note>Background update controlled by this property is slightly slower then
            background update controlled by <see cref="P:BestCS.Vision.Motion.SimpleBackgroundModelingDetector.FramesPerBackgroundUpdate"/> property,
            so it has a bit greater impact on performance.</note></para>
            
            <para><note>If this property is set to 0, then corresponding background updating
            method is not used (turned off), but background update guided by
            <see cref="P:BestCS.Vision.Motion.SimpleBackgroundModelingDetector.FramesPerBackgroundUpdate"/> property is used.</note></para>
            
            <para>Default value is set to <b>0</b>.</para>
            </remarks>
            
        </member>
        <member name="T:BestCS.Vision.Motion.TwoFramesDifferenceDetector">
            <summary>
            Motion detector based on two continues frames difference.
            </summary>
            
            <remarks><para>The class implements the simplest motion detection algorithm, which is
            based on difference of two continues frames. The <see cref="P:BestCS.Vision.Motion.TwoFramesDifferenceDetector.MotionFrame">difference frame</see>
            is thresholded and the <see cref="P:BestCS.Vision.Motion.TwoFramesDifferenceDetector.MotionLevel">amount of difference pixels</see> is calculated.
            To suppress stand-alone noisy pixels erosion morphological operator may be applied, which
            is controlled by <see cref="P:BestCS.Vision.Motion.TwoFramesDifferenceDetector.SuppressNoise"/> property.</para>
            
            <para>Although the class may be used on its own to perform motion detection, it is preferred
            to use it in conjunction with <see cref="T:BestCS.Vision.Motion.MotionDetector"/> class, which provides additional
            features and allows to use moton post processing algorithms.</para>
            
            <para>Sample usage:</para>
            <code>
            // create motion detector
            MotionDetector detector = new MotionDetector(
                new TwoFramesDifferenceDetector( ),
                new MotionAreaHighlighting( ) );
            
            // continuously feed video frames to motion detector
            while ( ... )
            {
                // process new video frame and check motion level
                if ( detector.ProcessFrame( videoFrame ) &gt; 0.02 )
                {
                    // ring alarm or do somethng else
                }
            }
            </code>
            </remarks>
            
            <seealso cref="T:BestCS.Vision.Motion.MotionDetector"/>
            
        </member>
        <member name="M:BestCS.Vision.Motion.TwoFramesDifferenceDetector.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Vision.Motion.TwoFramesDifferenceDetector"/> class.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Motion.TwoFramesDifferenceDetector.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:BestCS.Vision.Motion.TwoFramesDifferenceDetector"/> class.
            </summary>
            
            <param name="suppressNoise">Suppress noise in video frames or not (see <see cref="P:BestCS.Vision.Motion.TwoFramesDifferenceDetector.SuppressNoise"/> property).</param>
            
        </member>
        <member name="M:BestCS.Vision.Motion.TwoFramesDifferenceDetector.ProcessFrame(BestCS.Imaging.UnmanagedImage)">
            <summary>
            Process new video frame.
            </summary>
            
            <param name="videoFrame">Video frame to process (detect motion in).</param>
            
            <remarks><para>Processes new frame from video source and detects motion in it.</para>
            
            <para>Check <see cref="P:BestCS.Vision.Motion.TwoFramesDifferenceDetector.MotionLevel"/> property to get information about amount of motion
            (changes) in the processed frame.</para>
            </remarks>
            
        </member>
        <member name="M:BestCS.Vision.Motion.TwoFramesDifferenceDetector.Reset">
            <summary>
            Reset motion detector to initial state.
            </summary>
            
            <remarks><para>Resets internal state and variables of motion detection algorithm.
            Usually this is required to be done before processing new video source, but
            may be also done at any time to restart motion detection algorithm.</para>
            </remarks>
            
        </member>
        <member name="P:BestCS.Vision.Motion.TwoFramesDifferenceDetector.DifferenceThreshold">
            <summary>
            Difference threshold value, [1, 255].
            </summary>
            
            <remarks><para>The value specifies the amount off difference between pixels, which is treated
            as motion pixel.</para>
            
            <para>Default value is set to <b>15</b>.</para>
            </remarks>
            
        </member>
        <member name="P:BestCS.Vision.Motion.TwoFramesDifferenceDetector.MotionLevel">
            <summary>
            Motion level value, [0, 1].
            </summary>
            
            <remarks><para>Amount of changes in the last processed frame. For example, if value of
            this property equals to 0.1, then it means that last processed frame has 10% difference
            with previous frame.</para>
            </remarks>
            
        </member>
        <member name="P:BestCS.Vision.Motion.TwoFramesDifferenceDetector.MotionFrame">
             <summary>
             Motion frame containing detected areas of motion.
             </summary>
             
             <remarks><para>Motion frame is a grayscale image, which shows areas of detected motion.
             All black pixels in the motion frame correspond to areas, where no motion is
             detected. But white pixels correspond to areas, where motion is detected.</para>
             
             <para><note>The property is set to <see langword="null"/> after processing of the first
             video frame by the algorithm.</note></para>
             </remarks>
            
        </member>
        <member name="P:BestCS.Vision.Motion.TwoFramesDifferenceDetector.SuppressNoise">
            <summary>
            Suppress noise in video frames or not.
            </summary>
            
            <remarks><para>The value specifies if additional filtering should be
            done to suppress standalone noisy pixels by applying 3x3 erosion image processing
            filter.</para>
            
            <para>Default value is set to <see langword="true"/>.</para>
            
            <para><note>Turning the value on leads to more processing time of video frame.</note></para>
            </remarks>
            
        </member>
        <member name="T:BestCS.Vision.Tracking.CamshiftMode">
            <summary>
              Modes for the Camshift Tracker.
            </summary>
            
        </member>
        <member name="F:BestCS.Vision.Tracking.CamshiftMode.RGB">
            <summary>
              By choosing RGB, the tracker will process raw high-intensity RGB values.
            </summary>
            
        </member>
        <member name="F:BestCS.Vision.Tracking.CamshiftMode.HSL">
            <summary>
              By choosing HSL, the tracker will perform a RGB-to-HSL conversion and use the Hue value instead.
            </summary>
            
        </member>
        <member name="F:BestCS.Vision.Tracking.CamshiftMode.Mixed">
            <summary>
              By choosing Mixed, the tracker will use HSL with some lightness information.
            </summary>
            
        </member>
        <member name="T:BestCS.Vision.Tracking.Camshift">
            <summary>
              Continuously Adaptive Mean Shift (Camshift) Object Tracker
            </summary>
            <remarks>
            <para>
              Camshift stands for "Continuously Adaptive Mean Shift". It combines the basic
              Mean Shift algorithm with an adaptive region-sizing step. The kernel is a step
              function applied to a probability map. The probability of each image pixel is
              based on color using a method called histogram backprojection.</para>
            <para>
              The implementation of this code has used Gary Bradski's original publication,
              the OpenCV Library and the FaceIt implementation as references. The OpenCV
              library is distributed under a BSD license. FaceIt is distributed under a MIT
              license. The original licensing terms for FaceIt are described in the source
              code and in the Copyright.txt file accompanying the framework.</para>  
              
            <para>
              References:
              <list type="bullet">
                <item><description>
                  G.R. Bradski, Computer video face tracking for use in a perceptual user interface,
                  Intel Technology Journal, Q2 1998. Available on:
                  <a href="ftp://download.intel.com/technology/itj/q21998/pdf/camshift.pdf">
                  ftp://download.intel.com/technology/itj/q21998/pdf/camshift.pdf </a></description></item>
                <item><description>
                  R. Hewitt, Face tracking project description: Camshift Algorithm. Available on:
                  <a href="http://www.robinhewitt.com/research/track/camshift.html">
                  http://www.robinhewitt.com/research/track/camshift.html </a></description></item>
                <item><description>
                  OpenCV Computer Vision Library. Available on:
                  <a href="http://sourceforge.net/projects/opencvlibrary/">
                  http://sourceforge.net/projects/opencvlibrary/ </a></description></item>
                <item><description>
                  FaceIt object tracking in Flash AS3. Available on:
                  <a href="http://www.libspark.org/browser/as3/FaceIt">
                  http://www.libspark.org/browser/as3/FaceIt </a></description></item>
             </list></para>  
            </remarks>
            
        </member>
        <member name="T:BestCS.Vision.Tracking.IObjectTracker">
            <summary>
              Object tracker interface.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Tracking.IObjectTracker.ProcessFrame(BestCS.Imaging.UnmanagedImage)">
            <summary>
              Process a new video frame.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Tracking.IObjectTracker.TrackingObject">
            <summary>
              Gets the current location of the object being tracked.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Tracking.IObjectTracker.Extract">
            <summary>
              Gets or sets a value indicating whether the tracker should
              extract the object image from the source. The extracted image
              should be stored in <see cref="P:BestCS.Vision.Tracking.IObjectTracker.TrackingObject"/>.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Tracking.Camshift.#ctor">
            <summary>
              Constructs a new Camshift tracking algorithm.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Tracking.Camshift.#ctor(BestCS.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
              Constructs a new Camshift tracking algorithm.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Tracking.Camshift.#ctor(System.Drawing.Rectangle)">
            <summary>
              Constructs a new Camshift tracking algorithm.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Tracking.Camshift.#ctor(BestCS.Imaging.UnmanagedImage,System.Drawing.Rectangle,BestCS.Vision.Tracking.CamshiftMode)">
            <summary>
              Constructs a new Camshift tracking algorithm.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Tracking.Camshift.#ctor(System.Drawing.Rectangle,BestCS.Vision.Tracking.CamshiftMode)">
            <summary>
              Constructs a new Camshift tracking algorithm.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Tracking.Camshift.Reset">
            <summary>
              Resets the object tracking algorithm.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Tracking.Camshift.GetBackprojection">
            <summary>
              Generates a image of the histogram back projection
            </summary>
        </member>
        <member name="M:BestCS.Vision.Tracking.Camshift.GetBackprojection(System.Drawing.Imaging.PixelFormat)">
            <summary>
              Generates a image of the histogram backprojection
            </summary>
        </member>
        <member name="M:BestCS.Vision.Tracking.Camshift.GetBackprojection(System.Drawing.Imaging.PixelFormat,System.Drawing.Rectangle)">
            <summary>
              Generates a image of the histogram backprojection
            </summary>
        </member>
        <member name="M:BestCS.Vision.Tracking.Camshift.GetBackprojection(BestCS.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
              Generates a image of the histogram backprojection
            </summary>
        </member>
        <member name="M:BestCS.Vision.Tracking.Camshift.ProcessFrame(BestCS.Imaging.UnmanagedImage)">
            <summary>
              Processes a new video frame.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Tracking.Camshift.camshift(BestCS.Imaging.UnmanagedImage)">
            <summary>
              Camshift algorithm
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Tracking.Camshift.meanShift(BestCS.Imaging.UnmanagedImage)">
            <summary>
              Mean shift algorithm
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Tracking.Camshift.computeHistogramRatio(System.Single[],System.Single[],System.Single[])">
            <summary>
              Computes the ratio histogram between to histograms.
            </summary>
            
            <remarks>
              http://www.robinhewitt.com/research/track/backproject.html
            </remarks>
            
        </member>
        <member name="M:BestCS.Vision.Tracking.Camshift.generateBackprojectionMap(BestCS.Imaging.UnmanagedImage,System.Single[])">
            <summary>
              Image histogram back-projection.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Tracking.Camshift.createHistogram(BestCS.Imaging.UnmanagedImage,System.Drawing.Rectangle)">
            <summary>
              Creates a color histogram discarding low intensity colors
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Tracking.Camshift.checkSteadiness">
            <summary>
              Checks for aberrant fluctuations in the tracking object.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Tracking.Camshift.SearchWindow">
            <summary>
              Gets or sets the current search window.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Tracking.Camshift.AspectRatio">
            <summary>
              Gets or sets the desired window aspect ratio.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Tracking.Camshift.Mode">
            <summary>
              Gets or sets the mode of operation for this tracker.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Tracking.Camshift.HslSaturationRange">
            <summary>
              If using HSL mode, specifies the operational saturation range for the tracker.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Tracking.Camshift.HslLightnessRange">
            <summary>
              If using HSL mode, specifies the operational lightness range for the tracker.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Tracking.Camshift.TrackingObject">
            <summary>
              Gets the location of the object being tracked.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Tracking.Camshift.Extract">
            <summary>
              Gets or sets a value indicating whether the tracker
              should extract the object image from the source. The
              extracted image will be available in <see cref="P:BestCS.Vision.Tracking.TrackingObject.Image"/>.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Tracking.Camshift.Map">
            <summary>
              Probability map
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Tracking.Camshift.Conservative">
            <summary>
              Gets or sets whether the algorithm should scan only the
              active window or the entire image for histogram ratio.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Tracking.Camshift.Smooth">
            <summary>
              Gets or sets a value indicating whether the angular
              movements should be smoothed using a moving average.
            </summary>
            <value><c>true</c> to smooth angular movements; otherwise, <c>false</c>.</value>
            
        </member>
        <member name="P:BestCS.Vision.Tracking.Camshift.IsSteady">
            <summary>
              Gets whether the tracking object is
              showing little variation of fluctuation.
            </summary>
            <value><c>true</c> if the tracking object is steady; otherwise, <c>false</c>.</value>
            
        </member>
        <member name="T:BestCS.Vision.Tracking.HslBlobTracker">
            <summary>
              Blob object tracker.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Tracking.HslBlobTracker.#ctor">
            <summary>
              Initializes a new instance of the <see cref="T:BestCS.Vision.Tracking.HslBlobTracker"/> class.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Tracking.HslBlobTracker.#ctor(BestCS.Imaging.Filters.HSLFiltering)">
            <summary>
              Initializes a new instance of the <see cref="T:BestCS.Vision.Tracking.HslBlobTracker"/> class.
            </summary>
            
            <param name="filter">The filter.</param>
            
        </member>
        <member name="M:BestCS.Vision.Tracking.HslBlobTracker.ProcessFrame(BestCS.Imaging.UnmanagedImage)">
            <summary>
            Process a new video frame.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Tracking.HslBlobTracker.Reset">
            <summary>
            Resets this instance.
            </summary>
        </member>
        <member name="P:BestCS.Vision.Tracking.HslBlobTracker.MaxWidth">
            <summary>
            Gets or sets the maximum width of tracked objects.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Tracking.HslBlobTracker.MaxHeight">
            <summary>
            Gets or sets the maximum height of tracked objects.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Tracking.HslBlobTracker.MinWidth">
            <summary>
            Gets or sets the minimum width of tracked objects.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Tracking.HslBlobTracker.MinHeight">
            <summary>
            Gets or sets the minimum height of tracked objects.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Tracking.HslBlobTracker.Extract">
            <summary>
              Gets or sets a value indicating whether the tracker
              should extract the object image from the source. The
              extracted image will be available in <see cref="P:BestCS.Vision.Tracking.TrackingObject.Image"/>.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Tracking.HslBlobTracker.ComputeOrientation">
            <summary>
              Gets or sets whether the tracker should compute blob's orientation.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Tracking.HslBlobTracker.Filter">
            <summary>
              Gets the HSL filter used in color segmentation.
            </summary>
            
            <value>The HSL filter used in segmentation.</value>
            
        </member>
        <member name="P:BestCS.Vision.Tracking.HslBlobTracker.FilterImage">
            <summary>
              Gets the HSL filtered image.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Tracking.HslBlobTracker.TrackingObject">
            <summary>
            Gets the current location of the object being tracked.
            </summary>
            
        </member>
        <member name="T:BestCS.Vision.Tracking.MatchingTracker">
            <summary>
              Template matching object tracker.
            </summary>
            
            <remarks>
              The matching tracker will track the object presented in the search window
              of the first frame given to the tracker. To reset the tracker and start
              tracking another object, one can call the Reset method, then set the search
              window around a new object of interest present the image containing the new
              object to the tracker.
            </remarks>
            
        </member>
        <member name="M:BestCS.Vision.Tracking.MatchingTracker.#ctor">
            <summary>
              Constructs a new <see cref="T:BestCS.Vision.Tracking.MatchingTracker"/> object tracker.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Tracking.MatchingTracker.ProcessFrame(BestCS.Imaging.UnmanagedImage)">
            <summary>
              Process a new video frame.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Tracking.MatchingTracker.Reset">
            <summary>
              Resets this instance.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Tracking.MatchingTracker.SearchWindow">
            <summary>
              Gets or sets the current search window.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Tracking.MatchingTracker.TrackingObject">
            <summary>
              Gets the current location of the object being tracked.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Tracking.MatchingTracker.Threshold">
            <summary>
              Gets or sets the similarity threshold to 
              determine when the object has been lost.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Tracking.MatchingTracker.Extract">
            <summary>
              Gets or sets a value indicating whether the tracker should
              extract the object image from the source. The extracted image
              should be stored in <see cref="P:BestCS.Vision.Tracking.MatchingTracker.TrackingObject"/>.
            </summary>
            
        </member>
        <member name="T:BestCS.Vision.Tracking.AxisOrientation">
            <summary>
              Axis orientation.
            </summary>
            
        </member>
        <member name="F:BestCS.Vision.Tracking.AxisOrientation.Horizontal">
            <summary>
              Horizontal axis.
            </summary>
            
        </member>
        <member name="F:BestCS.Vision.Tracking.AxisOrientation.Vertical">
            <summary>
              Vertical axis.
            </summary>
            
        </member>
        <member name="T:BestCS.Vision.Tracking.TrackingObject">
            <summary>
              Tracking object to represent an object in a scene.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Tracking.TrackingObject.#ctor">
            <summary>
              Constructs a new tracking object.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Tracking.TrackingObject.#ctor(BestCS.IntPoint)">
            <summary>
              Constructs a new tracking object.
            </summary>
            
            <param name="center">The center of gravity of the object.</param>
            
        </member>
        <member name="M:BestCS.Vision.Tracking.TrackingObject.#ctor(System.Drawing.Rectangle,BestCS.IntPoint,System.Single)">
            <summary>
              Constructs a new tracking object.
            </summary>
            
            <param name="angle">The angle of orientation for the object.</param>
            <param name="center">The center of gravity of the object.</param>
            <param name="rectangle">The rectangle containing the object.</param>
            
        </member>
        <member name="M:BestCS.Vision.Tracking.TrackingObject.#ctor(System.Drawing.Rectangle,System.Single)">
            <summary>
              Constructs a new tracking object.
            </summary>
            
            <param name="rectangle">The rectangle containing the object.</param>
            <param name="angle">The angle of the object.</param>
            
        </member>
        <member name="M:BestCS.Vision.Tracking.TrackingObject.GetAxis">
            <summary>
              Gets two points defining the horizontal axis of the object.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Tracking.TrackingObject.GetAxis(BestCS.Vision.Tracking.AxisOrientation)">
            <summary>
              Gets two points defining the axis of the object.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Tracking.TrackingObject.Reset">
            <summary>
              Resets this tracking object.
            </summary>
            
        </member>
        <member name="M:BestCS.Vision.Tracking.TrackingObject.System#ICloneable#Clone">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            
            <returns>
              A new object that is a copy of this instance.
            </returns>
            
        </member>
        <member name="M:BestCS.Vision.Tracking.TrackingObject.Clone(System.Boolean)">
            <summary>
              Creates a new object that is a copy of the current instance.
            </summary>
            
            <returns>
              A new object that is a copy of this instance.
            </returns>
            
            <param name="excludeImage">Pass true to not include
              the <see cref="P:BestCS.Vision.Tracking.TrackingObject.Image"/> in the copy object.</param>
            
        </member>
        <member name="P:BestCS.Vision.Tracking.TrackingObject.Tag">
            <summary>
            Gets or sets an user-defined tag associated with this object.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Tracking.TrackingObject.Rectangle">
            <summary>
              Gets or sets the rectangle containing the object.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Tracking.TrackingObject.Center">
            <summary>
              Gets or sets the center of gravity of the object 
              relative to the original image from where it has 
              been extracted.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Tracking.TrackingObject.Image">
            <summary>
              Gets or sets the object's extracted image.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Tracking.TrackingObject.IsEmpty">
            <summary>
            Gets a value indicating whether the object is empty.
            </summary>
            
            <value><c>true</c> if this instance is empty; otherwise, <c>false</c>.</value>
            
        </member>
        <member name="P:BestCS.Vision.Tracking.TrackingObject.Area">
            <summary>
              Gets the area of the object.
            </summary>
            
        </member>
        <member name="P:BestCS.Vision.Tracking.TrackingObject.Angle">
            <summary>
              Gets or sets the angle of the object.
            </summary>
            
        </member>
    </members>
</doc>
